import {
  createPopper3 as createPopper
} from "./chunk-JHJOBDZT.js";
import {
  fade
} from "./chunk-UYDFXFL5.js";
import "./chunk-M6MB33T7.js";
import {
  writable
} from "./chunk-E6ZP6LG5.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  afterUpdate,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  head_selector,
  init,
  init_binding_group,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prevent_default,
  run_all,
  safe_not_equal,
  select_option,
  select_options,
  select_value,
  setContext,
  set_attributes,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots,
  validate_store
} from "./chunk-RVLVW3YK.js";
import "./chunk-76J2PTFD.js";

// node_modules/sveltestrap/src/utils.js
function getOriginalBodyPadding() {
  const style = window ? window.getComputedStyle(document.body, null) : {};
  return parseInt(style && style.getPropertyValue("padding-right") || 0, 10);
}
function getScrollbarWidth() {
  let scrollDiv = document.createElement("div");
  scrollDiv.style.position = "absolute";
  scrollDiv.style.top = "-9999px";
  scrollDiv.style.width = "50px";
  scrollDiv.style.height = "50px";
  scrollDiv.style.overflow = "scroll";
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}
function setScrollbarWidth(padding) {
  document.body.style.paddingRight = padding > 0 ? `${padding}px` : null;
}
function isBodyOverflowing() {
  return window ? document.body.clientWidth < window.innerWidth : false;
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type == "object" || type == "function");
}
function conditionallyUpdateScrollbar() {
  const scrollbarWidth = getScrollbarWidth();
  const fixedContent = document.querySelectorAll(
    ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"
  )[0];
  const bodyPadding = fixedContent ? parseInt(fixedContent.style.paddingRight || 0, 10) : 0;
  if (isBodyOverflowing()) {
    setScrollbarWidth(bodyPadding + scrollbarWidth);
  }
}
function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === "") {
    return isXs ? "col" : `col-${colWidth}`;
  } else if (colSize === "auto") {
    return isXs ? "col-auto" : `col-${colWidth}-auto`;
  }
  return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
}
function browserEvent(target, ...args) {
  target.addEventListener(...args);
  return () => target.removeEventListener(...args);
}
function getNewCarouselActiveIndex(direction, items, activeIndex) {
  if (direction === "prev") {
    return activeIndex === 0 ? items.length - 1 : activeIndex - 1;
  } else if (direction === "next") {
    return activeIndex === items.length - 1 ? 0 : activeIndex + 1;
  }
}
function toClassName(value) {
  let result = "";
  if (typeof value === "string" || typeof value === "number") {
    result += value;
  } else if (typeof value === "object") {
    if (Array.isArray(value)) {
      result = value.map(toClassName).filter(Boolean).join(" ");
    } else {
      for (let key in value) {
        if (value[key]) {
          result && (result += " ");
          result += key;
        }
      }
    }
  }
  return result;
}
function classnames(...args) {
  return args.map(toClassName).filter(Boolean).join(" ");
}
function getTransitionDuration(element2) {
  if (!element2)
    return 0;
  let { transitionDuration, transitionDelay } = window.getComputedStyle(element2);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * 1e3;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}

// node_modules/sveltestrap/src/Accordion.svelte
var file = "node_modules/sveltestrap/src/Accordion.svelte";
function create_fragment(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 29, 0, 643);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["flush", "stayOpen", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { flush = false } = $$props;
  let { stayOpen = false } = $$props;
  let { class: className = "" } = $$props;
  const open = writable();
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  setContext("accordion", {
    open,
    stayOpen,
    toggle: (id) => {
      if ($open === id)
        open.set();
      else
        open.set(id);
      dispatch("toggle", { [id]: $open === id });
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("flush" in $$new_props)
      $$invalidate(3, flush = $$new_props.flush);
    if ("stayOpen" in $$new_props)
      $$invalidate(4, stayOpen = $$new_props.stayOpen);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    createEventDispatcher,
    setContext,
    writable,
    dispatch,
    flush,
    stayOpen,
    className,
    open,
    classes,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("flush" in $$props)
      $$invalidate(3, flush = $$new_props.flush);
    if ("stayOpen" in $$props)
      $$invalidate(4, stayOpen = $$new_props.stayOpen);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, flush*/
    40) {
      $:
        $$invalidate(0, classes = classnames(className, "accordion", { "accordion-flush": flush }));
    }
  };
  return [classes, open, $$restProps, flush, stayOpen, className, $$scope, slots];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { flush: 3, stayOpen: 4, class: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment.name
    });
  }
  get flush() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flush(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stayOpen() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stayOpen(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/sveltestrap/src/AccordionHeader.svelte
var file2 = "node_modules/sveltestrap/src/AccordionHeader.svelte";
function create_fragment2(ctx) {
  let h2;
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let h2_levels = [
    { class: "accordion-header" },
    /*$$restProps*/
    ctx[1]
  ];
  let h2_data = {};
  for (let i = 0; i < h2_levels.length; i += 1) {
    h2_data = assign(h2_data, h2_levels[i]);
  }
  const block = {
    c: function create() {
      h2 = element("h2");
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", { class: true });
      var h2_nodes = children(h2);
      button = claim_element(h2_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      h2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "class",
        /*classes*/
        ctx[0]
      );
      add_location(button, file2, 9, 2, 219);
      set_attributes(h2, h2_data);
      add_location(h2, file2, 8, 0, 170);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      append_hydration_dev(h2, button);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      1) {
        attr_dev(
          button,
          "class",
          /*classes*/
          ctx2[0]
        );
      }
      set_attributes(h2, h2_data = get_spread_update(h2_levels, [
        { class: "accordion-header" },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionHeader", slots, ["default"]);
  let { class: className = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "accordion-button"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots, click_handler];
}
var AccordionHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionHeader",
      options,
      id: create_fragment2.name
    });
  }
  get class() {
    throw new Error("<AccordionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AccordionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionHeader_default = AccordionHeader;

// node_modules/sveltestrap/src/transitions.js
function backdropIn(node) {
  node.style.display = "block";
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.classList.add("show");
      }
    }
  };
}
function backdropOut(node) {
  node.classList.remove("show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.style.display = "none";
      }
    }
  };
}
function collapseOut(node, params) {
  const dimension = params.horizontal ? "width" : "height";
  node.style[dimension] = `${node.getBoundingClientRect()[dimension]}px`;
  node.classList.add("collapsing");
  node.classList.remove("collapse", "show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.style[dimension] = "";
      } else if (t === 0) {
        node.classList.remove("collapsing");
        node.classList.add("collapse");
      }
    }
  };
}
function collapseIn(node, params) {
  const horizontal = params.horizontal;
  const dimension = horizontal ? "width" : "height";
  node.classList.add("collapsing");
  node.classList.remove("collapse", "show");
  node.style[dimension] = 0;
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t < 1) {
        if (horizontal) {
          node.style.width = `${node.scrollWidth}px`;
        } else {
          node.style.height = `${node.scrollHeight}px`;
        }
      } else {
        node.classList.remove("collapsing");
        node.classList.add("collapse", "show");
        node.style[dimension] = "";
      }
    }
  };
}
function modalIn(node) {
  node.style.display = "block";
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.classList.add("show");
      }
    }
  };
}
function modalOut(node) {
  node.classList.remove("show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 1) {
        node.style.display = "none";
      }
    }
  };
}

// node_modules/sveltestrap/src/toggle.js
var defaultToggleEvents = ["touchstart", "click"];
var toggle_default = (toggler, togglerFn) => {
  let unbindEvents;
  if (typeof toggler === "string" && typeof window !== "undefined" && document && document.createElement) {
    let selection = document.querySelectorAll(toggler);
    if (!selection.length) {
      selection = document.querySelectorAll(`#${toggler}`);
    }
    if (!selection.length) {
      throw new Error(
        `The target '${toggler}' could not be identified in the dom, tip: check spelling`
      );
    }
    defaultToggleEvents.forEach((event) => {
      selection.forEach((element2) => {
        element2.addEventListener(event, togglerFn);
      });
    });
    unbindEvents = () => {
      defaultToggleEvents.forEach((event) => {
        selection.forEach((element2) => {
          element2.removeEventListener(event, togglerFn);
        });
      });
    };
  }
  return () => {
    if (typeof unbindEvents === "function") {
      unbindEvents();
      unbindEvents = void 0;
    }
  };
};

// node_modules/sveltestrap/src/Collapse.svelte
var file3 = "node_modules/sveltestrap/src/Collapse.svelte";
function create_if_block(ctx) {
  let div;
  let div_style_value;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let div_levels = [
    {
      style: div_style_value = /*navbar*/
      ctx[2] ? void 0 : "overflow: hidden;"
    },
    /*$$restProps*/
    ctx[9],
    { class: (
      /*classes*/
      ctx[8]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true, class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file3, 63, 2, 1564);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "introstart",
            /*introstart_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            /*introend_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            /*outrostart_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            /*outroend_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introstart",
            function() {
              if (is_function(
                /*onEntering*/
                ctx[3]
              ))
                ctx[3].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            function() {
              if (is_function(
                /*onEntered*/
                ctx[4]
              ))
                ctx[4].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            function() {
              if (is_function(
                /*onExiting*/
                ctx[5]
              ))
                ctx[5].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            function() {
              if (is_function(
                /*onExited*/
                ctx[6]
              ))
                ctx[6].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*navbar*/
        4 && div_style_value !== (div_style_value = /*navbar*/
        ctx[2] ? void 0 : "overflow: hidden;")) && { style: div_style_value },
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx[9],
        (!current || dirty & /*classes*/
        256) && { class: (
          /*classes*/
          ctx[8]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, collapseIn, { horizontal: (
          /*horizontal*/
          ctx[1]
        ) });
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, collapseOut, { horizontal: (
          /*horizontal*/
          ctx[1]
        ) });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(63:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowresize*/
    ctx[21]
  );
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "resize",
          /*onwindowresize*/
          ctx[21]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "isOpen",
    "class",
    "horizontal",
    "navbar",
    "onEntering",
    "onEntered",
    "onExiting",
    "onExited",
    "expand",
    "toggler"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Collapse", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { isOpen = false } = $$props;
  let { class: className = "" } = $$props;
  let { horizontal = false } = $$props;
  let { navbar = false } = $$props;
  let { onEntering = () => dispatch("opening") } = $$props;
  let { onEntered = () => dispatch("open") } = $$props;
  let { onExiting = () => dispatch("closing") } = $$props;
  let { onExited = () => dispatch("close") } = $$props;
  let { expand = false } = $$props;
  let { toggler = null } = $$props;
  onMount(() => toggle_default(toggler, (e) => {
    $$invalidate(0, isOpen = !isOpen);
    e.preventDefault();
  }));
  let windowWidth = 0;
  let _wasMaximized = false;
  const minWidth = {};
  minWidth["xs"] = 0;
  minWidth["sm"] = 576;
  minWidth["md"] = 768;
  minWidth["lg"] = 992;
  minWidth["xl"] = 1200;
  function notify() {
    dispatch("update", isOpen);
  }
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function onwindowresize() {
    $$invalidate(7, windowWidth = window.innerWidth);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("horizontal" in $$new_props)
      $$invalidate(1, horizontal = $$new_props.horizontal);
    if ("navbar" in $$new_props)
      $$invalidate(2, navbar = $$new_props.navbar);
    if ("onEntering" in $$new_props)
      $$invalidate(3, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$new_props)
      $$invalidate(4, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$new_props)
      $$invalidate(5, onExiting = $$new_props.onExiting);
    if ("onExited" in $$new_props)
      $$invalidate(6, onExited = $$new_props.onExited);
    if ("expand" in $$new_props)
      $$invalidate(11, expand = $$new_props.expand);
    if ("toggler" in $$new_props)
      $$invalidate(12, toggler = $$new_props.toggler);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    collapseIn,
    collapseOut,
    classnames,
    toggle: toggle_default,
    dispatch,
    isOpen,
    className,
    horizontal,
    navbar,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    expand,
    toggler,
    windowWidth,
    _wasMaximized,
    minWidth,
    notify,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("horizontal" in $$props)
      $$invalidate(1, horizontal = $$new_props.horizontal);
    if ("navbar" in $$props)
      $$invalidate(2, navbar = $$new_props.navbar);
    if ("onEntering" in $$props)
      $$invalidate(3, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$props)
      $$invalidate(4, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$props)
      $$invalidate(5, onExiting = $$new_props.onExiting);
    if ("onExited" in $$props)
      $$invalidate(6, onExited = $$new_props.onExited);
    if ("expand" in $$props)
      $$invalidate(11, expand = $$new_props.expand);
    if ("toggler" in $$props)
      $$invalidate(12, toggler = $$new_props.toggler);
    if ("windowWidth" in $$props)
      $$invalidate(7, windowWidth = $$new_props.windowWidth);
    if ("_wasMaximized" in $$props)
      $$invalidate(13, _wasMaximized = $$new_props._wasMaximized);
    if ("classes" in $$props)
      $$invalidate(8, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, horizontal, navbar*/
    1030) {
      $:
        $$invalidate(8, classes = classnames(className, {
          "collapse-horizontal": horizontal,
          "navbar-collapse": navbar
        }));
    }
    if ($$self.$$.dirty & /*navbar, expand, windowWidth, minWidth, isOpen, _wasMaximized*/
    26757) {
      $:
        if (navbar && expand) {
          if (windowWidth >= minWidth[expand] && !isOpen) {
            $$invalidate(0, isOpen = true);
            $$invalidate(13, _wasMaximized = true);
            notify();
          } else if (windowWidth < minWidth[expand] && _wasMaximized) {
            $$invalidate(0, isOpen = false);
            $$invalidate(13, _wasMaximized = false);
            notify();
          }
        }
    }
  };
  return [
    isOpen,
    horizontal,
    navbar,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    windowWidth,
    classes,
    $$restProps,
    className,
    expand,
    toggler,
    _wasMaximized,
    minWidth,
    $$scope,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    onwindowresize
  ];
}
var Collapse = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      isOpen: 0,
      class: 10,
      horizontal: 1,
      navbar: 2,
      onEntering: 3,
      onEntered: 4,
      onExiting: 5,
      onExited: 6,
      expand: 11,
      toggler: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Collapse",
      options,
      id: create_fragment3.name
    });
  }
  get isOpen() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbar() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbar(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntering() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntering(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntered() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntered(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExiting() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExiting(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExited() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExited(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expand(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggler() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggler(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Collapse_default = Collapse;

// node_modules/sveltestrap/src/AccordionItem.svelte
var file4 = "node_modules/sveltestrap/src/AccordionItem.svelte";
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_default_slot_1(ctx) {
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[9].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_header_slot_context
  );
  const block = {
    c: function create() {
      if (header_slot)
        header_slot.c();
      t0 = space();
      t1 = text(
        /*header*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      if (header_slot)
        header_slot.l(nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(
        nodes,
        /*header*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (!current || dirty & /*header*/
      1)
        set_data_dev(
          t1,
          /*header*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (header_slot)
        header_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(31:2) <AccordionHeader     on:click={() => onToggle()}     class={!accordionOpen && 'collapsed'}   >",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "accordion-body");
      add_location(div, file4, 45, 4, 1133);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(38:2) <Collapse     isOpen={accordionOpen}     class=\\"accordion-collapse\\"     on:introstart     on:introend     on:outrostart     on:outroend   >',
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div;
  let accordionheader;
  let t;
  let collapse;
  let current;
  accordionheader = new AccordionHeader_default({
    props: {
      class: !/*accordionOpen*/
      ctx[2] && "collapsed",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  accordionheader.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  collapse = new Collapse_default({
    props: {
      isOpen: (
        /*accordionOpen*/
        ctx[2]
      ),
      class: "accordion-collapse",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  collapse.$on(
    "introstart",
    /*introstart_handler*/
    ctx[11]
  );
  collapse.$on(
    "introend",
    /*introend_handler*/
    ctx[12]
  );
  collapse.$on(
    "outrostart",
    /*outrostart_handler*/
    ctx[13]
  );
  collapse.$on(
    "outroend",
    /*outroend_handler*/
    ctx[14]
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(accordionheader.$$.fragment);
      t = space();
      create_component(collapse.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(accordionheader.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      claim_component(collapse.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[3]
      );
      add_location(div, file4, 29, 0, 783);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(accordionheader, div, null);
      append_hydration_dev(div, t);
      mount_component(collapse, div, null);
      ctx[15](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const accordionheader_changes = {};
      if (dirty & /*accordionOpen*/
      4)
        accordionheader_changes.class = !/*accordionOpen*/
        ctx2[2] && "collapsed";
      if (dirty & /*$$scope, header*/
      65537) {
        accordionheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordionheader.$set(accordionheader_changes);
      const collapse_changes = {};
      if (dirty & /*accordionOpen*/
      4)
        collapse_changes.isOpen = /*accordionOpen*/
        ctx2[2];
      if (dirty & /*$$scope*/
      65536) {
        collapse_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapse.$set(collapse_changes);
      if (!current || dirty & /*classes*/
      8) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(accordionheader.$$.fragment, local);
      transition_in(collapse.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(accordionheader.$$.fragment, local);
      transition_out(collapse.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(accordionheader);
      destroy_component(collapse);
      ctx[15](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let classes;
  let accordionOpen;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["header", "default"]);
  let { class: className = "" } = $$props;
  let { header = "" } = $$props;
  let { active = false } = $$props;
  let accordionId;
  const dispatch = createEventDispatcher();
  const { stayOpen, toggle, open } = getContext("accordion");
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  onMount(() => {
    if (active)
      toggle(accordionId);
  });
  const onToggle = () => {
    if (stayOpen)
      $$invalidate(6, active = !active);
    toggle(accordionId);
    dispatch("toggle", !accordionOpen);
  };
  const writable_props = ["class", "header", "active"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AccordionItem> was created with unknown prop '${key}'`);
  });
  const click_handler = () => onToggle();
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      accordionId = $$value;
      $$invalidate(1, accordionId);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(7, className = $$props2.class);
    if ("header" in $$props2)
      $$invalidate(0, header = $$props2.header);
    if ("active" in $$props2)
      $$invalidate(6, active = $$props2.active);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    onMount,
    classnames,
    Collapse: Collapse_default,
    AccordionHeader: AccordionHeader_default,
    className,
    header,
    active,
    accordionId,
    dispatch,
    stayOpen,
    toggle,
    open,
    onToggle,
    accordionOpen,
    classes,
    $open
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(7, className = $$props2.className);
    if ("header" in $$props2)
      $$invalidate(0, header = $$props2.header);
    if ("active" in $$props2)
      $$invalidate(6, active = $$props2.active);
    if ("accordionId" in $$props2)
      $$invalidate(1, accordionId = $$props2.accordionId);
    if ("accordionOpen" in $$props2)
      $$invalidate(2, accordionOpen = $$props2.accordionOpen);
    if ("classes" in $$props2)
      $$invalidate(3, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    128) {
      $:
        $$invalidate(3, classes = classnames(className, "accordion-item"));
    }
    if ($$self.$$.dirty & /*active, $open, accordionId*/
    322) {
      $:
        $$invalidate(2, accordionOpen = stayOpen ? active : $open === accordionId);
    }
  };
  return [
    header,
    accordionId,
    accordionOpen,
    classes,
    open,
    onToggle,
    active,
    className,
    $open,
    slots,
    click_handler,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    div_binding,
    $$scope
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { class: 7, header: 0, active: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment4.name
    });
  }
  get class() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/sveltestrap/src/Alert.svelte
var file5 = "node_modules/sveltestrap/src/Alert.svelte";
var get_heading_slot_changes = (dirty) => ({});
var get_heading_slot_context = (ctx) => ({});
function create_if_block2(ctx) {
  let div;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block2;
  let div_transition;
  let current;
  let if_block0 = (
    /*heading*/
    (ctx[3] || /*$$slots*/
    ctx[10].heading) && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*showClose*/
    ctx[5] && create_if_block_2(ctx)
  );
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[9],
    { class: (
      /*classes*/
      ctx[7]
    ) },
    { role: "alert" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if_block2.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file5, 26, 2, 808);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*heading*/
        ctx[3] || /*$$slots*/
        ctx[10].heading
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*heading, $$slots*/
          1032) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showClose*/
        ctx[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2(ctx);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block2.c();
        } else {
          if_block2.p(ctx, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx[9],
        (!current || dirty & /*classes*/
        128) && { class: (
          /*classes*/
          ctx[7]
        ) },
        { role: "alert" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            fade,
            /*transition*/
            ctx[4],
            true
          );
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      if (!div_transition)
        div_transition = create_bidirectional_transition(
          div,
          fade,
          /*transition*/
          ctx[4],
          false
        );
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(26:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let h4;
  let t;
  let current;
  const heading_slot_template = (
    /*#slots*/
    ctx[18].heading
  );
  const heading_slot = create_slot(
    heading_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_heading_slot_context
  );
  const block = {
    c: function create() {
      h4 = element("h4");
      t = text(
        /*heading*/
        ctx[3]
      );
      if (heading_slot)
        heading_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h4 = claim_element(nodes, "H4", { class: true });
      var h4_nodes = children(h4);
      t = claim_text(
        h4_nodes,
        /*heading*/
        ctx[3]
      );
      if (heading_slot)
        heading_slot.l(h4_nodes);
      h4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h4, "class", "alert-heading");
      add_location(h4, file5, 33, 6, 961);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h4, anchor);
      append_hydration_dev(h4, t);
      if (heading_slot) {
        heading_slot.m(h4, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*heading*/
      8)
        set_data_dev(
          t,
          /*heading*/
          ctx2[3]
        );
      if (heading_slot) {
        if (heading_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            heading_slot,
            heading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              heading_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_heading_slot_changes
            ),
            get_heading_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(heading_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(heading_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4);
      if (heading_slot)
        heading_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(33:4) {#if heading || $$slots.heading}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        "aria-label": true
      });
      children(button).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "class",
        /*closeClassNames*/
        ctx[6]
      );
      attr_dev(
        button,
        "aria-label",
        /*closeAriaLabel*/
        ctx[2]
      );
      add_location(button, file5, 38, 6, 1077);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*handleToggle*/
              ctx[8]
            ))
              ctx[8].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*closeClassNames*/
      64) {
        attr_dev(
          button,
          "class",
          /*closeClassNames*/
          ctx[6]
        );
      }
      if (dirty & /*closeAriaLabel*/
      4) {
        attr_dev(
          button,
          "aria-label",
          /*closeAriaLabel*/
          ctx[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(38:4) {#if showClose}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(48:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(46:4) {#if children}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let showClose;
  let handleToggle;
  let classes;
  let closeClassNames;
  const omit_props_names = [
    "class",
    "children",
    "color",
    "closeClassName",
    "closeAriaLabel",
    "dismissible",
    "heading",
    "isOpen",
    "toggle",
    "fade",
    "transition"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Alert", slots, ["heading", "default"]);
  const $$slots = compute_slots(slots);
  let { class: className = "" } = $$props;
  let { children: children2 = void 0 } = $$props;
  let { color = "success" } = $$props;
  let { closeClassName = "" } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  let { dismissible = false } = $$props;
  let { heading = void 0 } = $$props;
  let { isOpen = true } = $$props;
  let { toggle = void 0 } = $$props;
  let { fade: fade2 = true } = $$props;
  let { transition = { duration: fade2 ? 400 : 0 } } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(11, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("color" in $$new_props)
      $$invalidate(12, color = $$new_props.color);
    if ("closeClassName" in $$new_props)
      $$invalidate(13, closeClassName = $$new_props.closeClassName);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("dismissible" in $$new_props)
      $$invalidate(14, dismissible = $$new_props.dismissible);
    if ("heading" in $$new_props)
      $$invalidate(3, heading = $$new_props.heading);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$new_props)
      $$invalidate(15, toggle = $$new_props.toggle);
    if ("fade" in $$new_props)
      $$invalidate(16, fade2 = $$new_props.fade);
    if ("transition" in $$new_props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fadeTransition: fade,
    classnames,
    className,
    children: children2,
    color,
    closeClassName,
    closeAriaLabel,
    dismissible,
    heading,
    isOpen,
    toggle,
    fade: fade2,
    transition,
    closeClassNames,
    showClose,
    classes,
    handleToggle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(11, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("color" in $$props)
      $$invalidate(12, color = $$new_props.color);
    if ("closeClassName" in $$props)
      $$invalidate(13, closeClassName = $$new_props.closeClassName);
    if ("closeAriaLabel" in $$props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("dismissible" in $$props)
      $$invalidate(14, dismissible = $$new_props.dismissible);
    if ("heading" in $$props)
      $$invalidate(3, heading = $$new_props.heading);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$props)
      $$invalidate(15, toggle = $$new_props.toggle);
    if ("fade" in $$props)
      $$invalidate(16, fade2 = $$new_props.fade);
    if ("transition" in $$props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("closeClassNames" in $$props)
      $$invalidate(6, closeClassNames = $$new_props.closeClassNames);
    if ("showClose" in $$props)
      $$invalidate(5, showClose = $$new_props.showClose);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
    if ("handleToggle" in $$props)
      $$invalidate(8, handleToggle = $$new_props.handleToggle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dismissible, toggle*/
    49152) {
      $:
        $$invalidate(5, showClose = dismissible || toggle);
    }
    if ($$self.$$.dirty & /*toggle*/
    32768) {
      $:
        $$invalidate(8, handleToggle = toggle || (() => $$invalidate(0, isOpen = false)));
    }
    if ($$self.$$.dirty & /*className, color, showClose*/
    6176) {
      $:
        $$invalidate(7, classes = classnames(className, "alert", `alert-${color}`, { "alert-dismissible": showClose }));
    }
    if ($$self.$$.dirty & /*closeClassName*/
    8192) {
      $:
        $$invalidate(6, closeClassNames = classnames("btn-close", closeClassName));
    }
  };
  return [
    isOpen,
    children2,
    closeAriaLabel,
    heading,
    transition,
    showClose,
    closeClassNames,
    classes,
    handleToggle,
    $$restProps,
    $$slots,
    className,
    color,
    closeClassName,
    dismissible,
    toggle,
    fade2,
    $$scope,
    slots
  ];
}
var Alert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      class: 11,
      children: 1,
      color: 12,
      closeClassName: 13,
      closeAriaLabel: 2,
      dismissible: 14,
      heading: 3,
      isOpen: 0,
      toggle: 15,
      fade: 16,
      transition: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Alert",
      options,
      id: create_fragment5.name
    });
  }
  get class() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeClassName() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeClassName(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dismissible() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dismissible(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get heading() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set heading(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Alert_default = Alert;

// node_modules/sveltestrap/src/Badge.svelte
var file6 = "node_modules/sveltestrap/src/Badge.svelte";
function create_else_block_1(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_22, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*children*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let span_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file6, 27, 2, 505);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(27:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_12, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*children*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    /*$$restProps*/
    ctx[3],
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      if_block.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file6, 19, 2, 371);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(19:0) {#if href}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(31:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      1)
        set_data_dev(
          t,
          /*children*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(29:4) {#if children}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(23:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      1)
        set_data_dev(
          t,
          /*children*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(21:4) {#if children}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "children", "color", "href", "pill"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Badge", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { children: children2 = void 0 } = $$props;
  let { color = "secondary" } = $$props;
  let { href = void 0 } = $$props;
  let { pill = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(0, children2 = $$new_props.children);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("pill" in $$new_props)
      $$invalidate(6, pill = $$new_props.pill);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    children: children2,
    color,
    href,
    pill,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(0, children2 = $$new_props.children);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("href" in $$props)
      $$invalidate(1, href = $$new_props.href);
    if ("pill" in $$props)
      $$invalidate(6, pill = $$new_props.pill);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, color, pill*/
    112) {
      $:
        $$invalidate(2, classes = classnames(className, "badge", `text-bg-${color}`, pill ? "rounded-pill" : false));
    }
  };
  return [children2, href, classes, $$restProps, className, color, pill, $$scope, slots];
}
var Badge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      class: 4,
      children: 0,
      color: 5,
      href: 1,
      pill: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Badge",
      options,
      id: create_fragment6.name
    });
  }
  get class() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pill() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pill(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Badge_default = Badge;

// node_modules/sveltestrap/src/Breadcrumb.svelte
var file7 = "node_modules/sveltestrap/src/Breadcrumb.svelte";
function create_else_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(21:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(19:4) {#if children}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let nav;
  let ol;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block4, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let nav_levels = [
    { style: (
      /*styles*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[4],
    { class: (
      /*className*/
      ctx[0]
    ) }
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ol = element("ol");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { style: true, class: true });
      var nav_nodes = children(nav);
      ol = claim_element(nav_nodes, "OL", { class: true });
      var ol_nodes = children(ol);
      if_block.l(ol_nodes);
      ol_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        ol,
        "class",
        /*listClasses*/
        ctx[3]
      );
      add_location(ol, file7, 17, 2, 462);
      set_attributes(nav, nav_data);
      add_location(nav, file7, 16, 0, 404);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ol);
      if_blocks[current_block_type_index].m(ol, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(ol, null);
      }
      if (!current || dirty & /*listClasses*/
      8) {
        attr_dev(
          ol,
          "class",
          /*listClasses*/
          ctx2[3]
        );
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        (!current || dirty & /*styles*/
        4) && { style: (
          /*styles*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*className*/
        1) && { class: (
          /*className*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let listClasses;
  let styles;
  const omit_props_names = ["class", "children", "divider", "listClassName", "style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumb", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { children: children2 = void 0 } = $$props;
  let { divider = void 0 } = $$props;
  let { listClassName = "" } = $$props;
  let { style = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("divider" in $$new_props)
      $$invalidate(5, divider = $$new_props.divider);
    if ("listClassName" in $$new_props)
      $$invalidate(6, listClassName = $$new_props.listClassName);
    if ("style" in $$new_props)
      $$invalidate(7, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    children: children2,
    divider,
    listClassName,
    style,
    styles,
    listClasses
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("divider" in $$props)
      $$invalidate(5, divider = $$new_props.divider);
    if ("listClassName" in $$props)
      $$invalidate(6, listClassName = $$new_props.listClassName);
    if ("style" in $$props)
      $$invalidate(7, style = $$new_props.style);
    if ("styles" in $$props)
      $$invalidate(2, styles = $$new_props.styles);
    if ("listClasses" in $$props)
      $$invalidate(3, listClasses = $$new_props.listClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*listClassName*/
    64) {
      $:
        $$invalidate(3, listClasses = classnames("breadcrumb", listClassName));
    }
    if ($$self.$$.dirty & /*divider, style*/
    160) {
      $:
        $$invalidate(2, styles = divider ? `--bs-breadcrumb-divider: '${divider}'; ${style || ""}` : style);
    }
  };
  return [
    className,
    children2,
    styles,
    listClasses,
    $$restProps,
    divider,
    listClassName,
    style,
    $$scope,
    slots
  ];
}
var Breadcrumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      class: 0,
      children: 1,
      divider: 5,
      listClassName: 6,
      style: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumb",
      options,
      id: create_fragment7.name
    });
  }
  get class() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get divider() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set divider(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listClassName() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listClassName(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumb_default = Breadcrumb;

// node_modules/sveltestrap/src/BreadcrumbItem.svelte
var file8 = "node_modules/sveltestrap/src/BreadcrumbItem.svelte";
function create_else_block4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(19:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(17:2) {#if children}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let li_aria_current_value;
  let current;
  const if_block_creators = [create_if_block5, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) },
    {
      "aria-current": li_aria_current_value = /*active*/
      ctx[0] ? "page" : void 0
    }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true, "aria-current": true });
      var li_nodes = children(li);
      if_block.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      add_location(li, file8, 15, 0, 277);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        (!current || dirty & /*active*/
        1 && li_aria_current_value !== (li_aria_current_value = /*active*/
        ctx2[0] ? "page" : void 0)) && { "aria-current": li_aria_current_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "children"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { children: children2 = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("children" in $$new_props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    children: children2,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("children" in $$props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, active*/
    17) {
      $:
        $$invalidate(2, classes = classnames(className, active ? "active" : false, "breadcrumb-item"));
    }
  };
  return [active, children2, classes, $$restProps, className, $$scope, slots];
}
var BreadcrumbItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { class: 4, active: 0, children: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbItem",
      options,
      id: create_fragment8.name
    });
  }
  get class() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbItem_default = BreadcrumbItem;

// node_modules/sveltestrap/src/Button.svelte
var file9 = "node_modules/sveltestrap/src/Button.svelte";
function create_else_block_12(ctx) {
  let button;
  let button_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let button_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[6]
    ) },
    { disabled: (
      /*disabled*/
      ctx[2]
    ) },
    { value: (
      /*value*/
      ctx[4]
    ) },
    {
      "aria-label": button_aria_label_value = /*ariaLabel*/
      ctx[7] || /*defaultAriaLabel*/
      ctx[5]
    }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block_1 = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
      var button_nodes = children(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file9, 50, 2, 1017);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[21](button);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*children, $$scope*/
        65538)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        (!current || dirty & /*disabled*/
        4) && { disabled: (
          /*disabled*/
          ctx2[2]
        ) },
        (!current || dirty & /*value*/
        16) && { value: (
          /*value*/
          ctx2[4]
        ) },
        (!current || dirty & /*ariaLabel, defaultAriaLabel*/
        160 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/
        ctx2[7] || /*defaultAriaLabel*/
        ctx2[5])) && { "aria-label": button_aria_label_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[21](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block_12.name,
    type: "else",
    source: "(50:0) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block6(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let a_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_13, create_else_block5];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[6]
    ) },
    { disabled: (
      /*disabled*/
      ctx[2]
    ) },
    { href: (
      /*href*/
      ctx[3]
    ) },
    {
      "aria-label": a_aria_label_value = /*ariaLabel*/
      ctx[7] || /*defaultAriaLabel*/
      ctx[5]
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block_1 = {
    c: function create() {
      a = element("a");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        class: true,
        disabled: true,
        href: true,
        "aria-label": true
      });
      var a_nodes = children(a);
      if_block.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file9, 34, 2, 771);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      ctx[20](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[18],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        (!current || dirty & /*disabled*/
        4) && { disabled: (
          /*disabled*/
          ctx2[2]
        ) },
        (!current || dirty & /*href*/
        8) && { href: (
          /*href*/
          ctx2[3]
        ) },
        (!current || dirty & /*ariaLabel, defaultAriaLabel*/
        160 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/
        ctx2[7] || /*defaultAriaLabel*/
        ctx2[5])) && { "aria-label": a_aria_label_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if_blocks[current_block_type_index].d();
      ctx[20](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block6.name,
    type: "if",
    source: "(34:0) {#if href}",
    ctx
  });
  return block_1;
}
function create_else_block_22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block_1 = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block_22.name,
    type: "else",
    source: "(63:6) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_23(ctx) {
  let t;
  const block_1 = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_23.name,
    type: "if",
    source: "(61:6) {#if children}",
    ctx
  });
  return block_1;
}
function fallback_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_23, create_else_block_22];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block.name,
    type: "fallback",
    source: "(60:10)        ",
    ctx
  });
  return block_1;
}
function create_else_block5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block_1 = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block5.name,
    type: "else",
    source: "(46:4) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_13(ctx) {
  let t;
  const block_1 = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_13.name,
    type: "if",
    source: "(44:4) {#if children}",
    ctx
  });
  return block_1;
}
function create_fragment9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance9($$self, $$props, $$invalidate) {
  let ariaLabel;
  let classes;
  let defaultAriaLabel;
  const omit_props_names = [
    "class",
    "active",
    "block",
    "children",
    "close",
    "color",
    "disabled",
    "href",
    "inner",
    "outline",
    "size",
    "value"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { block = false } = $$props;
  let { children: children2 = void 0 } = $$props;
  let { close = false } = $$props;
  let { color = "secondary" } = $$props;
  let { disabled = false } = $$props;
  let { href = "" } = $$props;
  let { inner = void 0 } = $$props;
  let { outline = false } = $$props;
  let { size = null } = $$props;
  let { value = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(10, active = $$new_props.active);
    if ("block" in $$new_props)
      $$invalidate(11, block = $$new_props.block);
    if ("children" in $$new_props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("close" in $$new_props)
      $$invalidate(12, close = $$new_props.close);
    if ("color" in $$new_props)
      $$invalidate(13, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$new_props)
      $$invalidate(3, href = $$new_props.href);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("outline" in $$new_props)
      $$invalidate(14, outline = $$new_props.outline);
    if ("size" in $$new_props)
      $$invalidate(15, size = $$new_props.size);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    block,
    children: children2,
    close,
    color,
    disabled,
    href,
    inner,
    outline,
    size,
    value,
    defaultAriaLabel,
    classes,
    ariaLabel
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(10, active = $$new_props.active);
    if ("block" in $$props)
      $$invalidate(11, block = $$new_props.block);
    if ("children" in $$props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("close" in $$props)
      $$invalidate(12, close = $$new_props.close);
    if ("color" in $$props)
      $$invalidate(13, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$props)
      $$invalidate(3, href = $$new_props.href);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("outline" in $$props)
      $$invalidate(14, outline = $$new_props.outline);
    if ("size" in $$props)
      $$invalidate(15, size = $$new_props.size);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("defaultAriaLabel" in $$props)
      $$invalidate(5, defaultAriaLabel = $$new_props.defaultAriaLabel);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("ariaLabel" in $$props)
      $$invalidate(7, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, ariaLabel = $$props["aria-label"]);
    if ($$self.$$.dirty & /*className, close, outline, color, size, block, active*/
    65024) {
      $:
        $$invalidate(6, classes = classnames(className, close ? "btn-close" : "btn", close || `btn${outline ? "-outline" : ""}-${color}`, size ? `btn-${size}` : false, block ? "d-block w-100" : false, { active }));
    }
    if ($$self.$$.dirty & /*close*/
    4096) {
      $:
        $$invalidate(5, defaultAriaLabel = close ? "Close" : null);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    inner,
    children2,
    disabled,
    href,
    value,
    defaultAriaLabel,
    classes,
    ariaLabel,
    $$restProps,
    className,
    active,
    block,
    close,
    color,
    outline,
    size,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    a_binding,
    button_binding
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      class: 9,
      active: 10,
      block: 11,
      children: 1,
      close: 12,
      color: 13,
      disabled: 2,
      href: 3,
      inner: 0,
      outline: 14,
      size: 15,
      value: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment9.name
    });
  }
  get class() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get block() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set close(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/sveltestrap/src/popper.js
function createPopperActions(initOptions) {
  let contentNode;
  let options = initOptions;
  let popperInstance = null;
  let referenceNode;
  const initPopper = () => {
    if (referenceNode && contentNode) {
      popperInstance = createPopper(referenceNode, contentNode, options);
    }
  };
  const deinitPopper = () => {
    if (popperInstance) {
      popperInstance.destroy();
      popperInstance = null;
    }
  };
  const referenceAction = (node) => {
    referenceNode = node;
    initPopper();
    return {
      destroy() {
        deinitPopper();
      }
    };
  };
  const contentAction = (node, contentOptions) => {
    contentNode = node;
    options = Object.assign(Object.assign({}, initOptions), contentOptions);
    initPopper();
    return {
      update(newContentOptions) {
        options = Object.assign(
          Object.assign({}, initOptions),
          newContentOptions
        );
        if (popperInstance && options) {
          popperInstance.setOptions(options);
        }
      },
      destroy() {
        deinitPopper();
      }
    };
  };
  return [referenceAction, contentAction, () => popperInstance];
}

// node_modules/sveltestrap/src/DropdownContext.js
var createContext = () => writable({});

// node_modules/sveltestrap/src/Dropdown.svelte
var { Error: Error_1 } = globals;
var file10 = "node_modules/sveltestrap/src/Dropdown.svelte";
function create_else_block6(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file10, 127, 2, 3323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[21](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(127:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      if (default_slot)
        default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      add_location(li, file10, 123, 2, 3232);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[20](li);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[20](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(123:0) {#if nav}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block7, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*nav*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let subItemIsActive;
  let classes;
  let handleToggle;
  const omit_props_names = [
    "class",
    "active",
    "autoClose",
    "direction",
    "dropup",
    "group",
    "inNavbar",
    "isOpen",
    "nav",
    "setActiveFromChild",
    "size",
    "toggle"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown", slots, ["default"]);
  const noop2 = () => void 0;
  let context = createContext();
  setContext("dropdownContext", context);
  const navbarContext = getContext("navbar");
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { autoClose = true } = $$props;
  let { direction = "down" } = $$props;
  let { dropup = false } = $$props;
  let { group = false } = $$props;
  let { inNavbar = navbarContext ? navbarContext.inNavbar : false } = $$props;
  let { isOpen = false } = $$props;
  let { nav = false } = $$props;
  let { setActiveFromChild = false } = $$props;
  let { size = "" } = $$props;
  let { toggle = void 0 } = $$props;
  const [popperRef, popperContent] = createPopperActions();
  const validDirections = ["up", "down", "left", "right", "start", "end"];
  if (validDirections.indexOf(direction) === -1) {
    throw new Error(`Invalid direction sent: '${direction}' is not one of 'up', 'down', 'left', 'right', 'start', 'end'`);
  }
  let component;
  let dropdownDirection;
  function handleDocumentClick(e) {
    if (e && (e.which === 3 || e.type === "keyup" && e.which !== 9))
      return;
    if (component.contains(e.target) && component !== e.target && (e.type !== "keyup" || e.which === 9)) {
      return;
    }
    if (autoClose === true || autoClose === "inside") {
      handleToggle(e);
    }
  }
  onDestroy(() => {
    if (typeof document !== "undefined") {
      ["click", "touchstart", "keyup"].forEach((event) => document.removeEventListener(event, handleDocumentClick, true));
    }
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(1, component);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(1, component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(6, active = $$new_props.active);
    if ("autoClose" in $$new_props)
      $$invalidate(7, autoClose = $$new_props.autoClose);
    if ("direction" in $$new_props)
      $$invalidate(8, direction = $$new_props.direction);
    if ("dropup" in $$new_props)
      $$invalidate(9, dropup = $$new_props.dropup);
    if ("group" in $$new_props)
      $$invalidate(10, group = $$new_props.group);
    if ("inNavbar" in $$new_props)
      $$invalidate(11, inNavbar = $$new_props.inNavbar);
    if ("isOpen" in $$new_props)
      $$invalidate(4, isOpen = $$new_props.isOpen);
    if ("nav" in $$new_props)
      $$invalidate(0, nav = $$new_props.nav);
    if ("setActiveFromChild" in $$new_props)
      $$invalidate(12, setActiveFromChild = $$new_props.setActiveFromChild);
    if ("size" in $$new_props)
      $$invalidate(13, size = $$new_props.size);
    if ("toggle" in $$new_props)
      $$invalidate(14, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    onDestroy,
    createPopperActions,
    classnames,
    createContext,
    noop: noop2,
    context,
    navbarContext,
    className,
    active,
    autoClose,
    direction,
    dropup,
    group,
    inNavbar,
    isOpen,
    nav,
    setActiveFromChild,
    size,
    toggle,
    popperRef,
    popperContent,
    validDirections,
    component,
    dropdownDirection,
    handleDocumentClick,
    handleToggle,
    subItemIsActive,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("context" in $$props)
      $$invalidate(23, context = $$new_props.context);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(6, active = $$new_props.active);
    if ("autoClose" in $$props)
      $$invalidate(7, autoClose = $$new_props.autoClose);
    if ("direction" in $$props)
      $$invalidate(8, direction = $$new_props.direction);
    if ("dropup" in $$props)
      $$invalidate(9, dropup = $$new_props.dropup);
    if ("group" in $$props)
      $$invalidate(10, group = $$new_props.group);
    if ("inNavbar" in $$props)
      $$invalidate(11, inNavbar = $$new_props.inNavbar);
    if ("isOpen" in $$props)
      $$invalidate(4, isOpen = $$new_props.isOpen);
    if ("nav" in $$props)
      $$invalidate(0, nav = $$new_props.nav);
    if ("setActiveFromChild" in $$props)
      $$invalidate(12, setActiveFromChild = $$new_props.setActiveFromChild);
    if ("size" in $$props)
      $$invalidate(13, size = $$new_props.size);
    if ("toggle" in $$props)
      $$invalidate(14, toggle = $$new_props.toggle);
    if ("component" in $$props)
      $$invalidate(1, component = $$new_props.component);
    if ("dropdownDirection" in $$props)
      $$invalidate(15, dropdownDirection = $$new_props.dropdownDirection);
    if ("handleToggle" in $$props)
      $$invalidate(16, handleToggle = $$new_props.handleToggle);
    if ("subItemIsActive" in $$props)
      $$invalidate(17, subItemIsActive = $$new_props.subItemIsActive);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*setActiveFromChild, component*/
    4098) {
      $:
        $$invalidate(17, subItemIsActive = !!(setActiveFromChild && component && typeof component.querySelector === "function" && component.querySelector(".active")));
    }
    if ($$self.$$.dirty & /*direction*/
    256) {
      $: {
        if (direction === "left")
          $$invalidate(15, dropdownDirection = "start");
        else if (direction === "right")
          $$invalidate(15, dropdownDirection = "end");
        else
          $$invalidate(15, dropdownDirection = direction);
      }
    }
    if ($$self.$$.dirty & /*toggle, isOpen*/
    16400) {
      $:
        $$invalidate(16, handleToggle = toggle || (() => $$invalidate(4, isOpen = !isOpen)));
    }
    if ($$self.$$.dirty & /*className, direction, dropdownDirection, nav, active, setActiveFromChild, subItemIsActive, group, size, isOpen*/
    177521) {
      $:
        $$invalidate(2, classes = classnames(className, direction !== "down" && `drop${dropdownDirection}`, nav && active ? "active" : false, setActiveFromChild && subItemIsActive ? "active" : false, {
          "btn-group": group,
          [`btn-group-${size}`]: !!size,
          dropdown: !group,
          show: isOpen,
          "nav-item": nav
        }));
    }
    if ($$self.$$.dirty & /*isOpen*/
    16) {
      $: {
        if (typeof document !== "undefined") {
          if (isOpen) {
            ["click", "touchstart", "keyup"].forEach((event) => document.addEventListener(event, handleDocumentClick, true));
          } else {
            ["click", "touchstart", "keyup"].forEach((event) => document.removeEventListener(event, handleDocumentClick, true));
          }
        }
      }
    }
    if ($$self.$$.dirty & /*handleToggle, isOpen, autoClose, direction, dropup, nav, inNavbar*/
    68497) {
      $: {
        context.update(() => {
          return {
            toggle: handleToggle,
            isOpen,
            autoClose,
            direction: direction === "down" && dropup ? "up" : direction,
            inNavbar: nav || inNavbar,
            popperRef: nav ? noop2 : popperRef,
            popperContent: nav ? noop2 : popperContent
          };
        });
      }
    }
  };
  return [
    nav,
    component,
    classes,
    $$restProps,
    isOpen,
    className,
    active,
    autoClose,
    direction,
    dropup,
    group,
    inNavbar,
    setActiveFromChild,
    size,
    toggle,
    dropdownDirection,
    handleToggle,
    subItemIsActive,
    $$scope,
    slots,
    li_binding,
    div_binding
  ];
}
var Dropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      class: 5,
      active: 6,
      autoClose: 7,
      direction: 8,
      dropup: 9,
      group: 10,
      inNavbar: 11,
      isOpen: 4,
      nav: 0,
      setActiveFromChild: 12,
      size: 13,
      toggle: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown",
      options,
      id: create_fragment10.name
    });
  }
  get class() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoClose() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoClose(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropup() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropup(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inNavbar() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inNavbar(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nav() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nav(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setActiveFromChild() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set setActiveFromChild(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dropdown_default = Dropdown;

// node_modules/sveltestrap/src/ButtonDropdown.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(5:0) <Dropdown {...$$restProps} group on:click>",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let dropdown;
  let current;
  const dropdown_spread_levels = [
    /*$$restProps*/
    ctx[0],
    { group: true }
  ];
  let dropdown_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dropdown_spread_levels.length; i += 1) {
    dropdown_props = assign(dropdown_props, dropdown_spread_levels[i]);
  }
  dropdown = new Dropdown_default({ props: dropdown_props, $$inline: true });
  dropdown.$on(
    "click",
    /*click_handler*/
    ctx[2]
  );
  const block = {
    c: function create() {
      create_component(dropdown.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dropdown.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dropdown, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dropdown_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(dropdown_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      ), dropdown_spread_levels[1]]) : {};
      if (dirty & /*$$scope*/
      8) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown.$set(dropdown_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dropdown, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonDropdown", slots, ["default"]);
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dropdown: Dropdown_default });
  return [$$restProps, slots, click_handler, $$scope];
}
var ButtonDropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonDropdown",
      options,
      id: create_fragment11.name
    });
  }
};
var ButtonDropdown_default = ButtonDropdown;

// node_modules/sveltestrap/src/ButtonGroup.svelte
var file11 = "node_modules/sveltestrap/src/ButtonGroup.svelte";
function create_fragment12(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file11, 15, 0, 305);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "size", "vertical"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { size = "" } = $$props;
  let { vertical = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("vertical" in $$new_props)
      $$invalidate(4, vertical = $$new_props.vertical);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    size,
    vertical,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(3, size = $$new_props.size);
    if ("vertical" in $$props)
      $$invalidate(4, vertical = $$new_props.vertical);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, size, vertical*/
    28) {
      $:
        $$invalidate(0, classes = classnames(className, size ? `btn-group-${size}` : false, vertical ? "btn-group-vertical" : "btn-group"));
    }
  };
  return [classes, $$restProps, className, size, vertical, $$scope, slots];
}
var ButtonGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { class: 2, size: 3, vertical: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonGroup",
      options,
      id: create_fragment12.name
    });
  }
  get class() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonGroup_default = ButtonGroup;

// node_modules/sveltestrap/src/ButtonToolbar.svelte
var file12 = "node_modules/sveltestrap/src/ButtonToolbar.svelte";
function create_fragment13(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { role: "toolbar" },
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true, class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file12, 9, 0, 166);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        { role: "toolbar" },
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonToolbar", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "btn-toolbar"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ButtonToolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonToolbar",
      options,
      id: create_fragment13.name
    });
  }
  get class() {
    throw new Error("<ButtonToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ButtonToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonToolbar_default = ButtonToolbar;

// node_modules/sveltestrap/src/Card.svelte
var file13 = "node_modules/sveltestrap/src/Card.svelte";
function create_fragment14(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file13, 20, 0, 471);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[9],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "body", "color", "inverse", "outline"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { body = false } = $$props;
  let { color = "" } = $$props;
  let { inverse = false } = $$props;
  let { outline = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("body" in $$new_props)
      $$invalidate(3, body = $$new_props.body);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("inverse" in $$new_props)
      $$invalidate(5, inverse = $$new_props.inverse);
    if ("outline" in $$new_props)
      $$invalidate(6, outline = $$new_props.outline);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    body,
    color,
    inverse,
    outline,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("body" in $$props)
      $$invalidate(3, body = $$new_props.body);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("inverse" in $$props)
      $$invalidate(5, inverse = $$new_props.inverse);
    if ("outline" in $$props)
      $$invalidate(6, outline = $$new_props.outline);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, inverse, body, color, outline*/
    124) {
      $:
        $$invalidate(0, classes = classnames(className, "card", inverse ? "text-white" : false, body ? "card-body" : false, color ? `${outline ? "border" : "bg"}-${color}` : false));
    }
  };
  return [
    classes,
    $$restProps,
    className,
    body,
    color,
    inverse,
    outline,
    $$scope,
    slots,
    click_handler
  ];
}
var Card = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      class: 2,
      body: 3,
      color: 4,
      inverse: 5,
      outline: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card",
      options,
      id: create_fragment14.name
    });
  }
  get class() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverse() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverse(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Card_default = Card;

// node_modules/sveltestrap/src/CardBody.svelte
var file14 = "node_modules/sveltestrap/src/CardBody.svelte";
function create_fragment15(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file14, 9, 0, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardBody",
      options,
      id: create_fragment15.name
    });
  }
  get class() {
    throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardBody_default = CardBody;

// node_modules/sveltestrap/src/CardColumns.svelte
var file15 = "node_modules/sveltestrap/src/CardColumns.svelte";
function create_fragment16(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file15, 9, 0, 167);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardColumns", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-columns"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardColumns = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardColumns",
      options,
      id: create_fragment16.name
    });
  }
  get class() {
    throw new Error("<CardColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardColumns_default = CardColumns;

// node_modules/sveltestrap/src/CardDeck.svelte
var file16 = "node_modules/sveltestrap/src/CardDeck.svelte";
function create_fragment17(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file16, 9, 0, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardDeck", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-deck"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardDeck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardDeck",
      options,
      id: create_fragment17.name
    });
  }
  get class() {
    throw new Error("<CardDeck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardDeck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardDeck_default = CardDeck;

// node_modules/sveltestrap/src/CardFooter.svelte
var file17 = "node_modules/sveltestrap/src/CardFooter.svelte";
function create_fragment18(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file17, 9, 0, 166);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardFooter", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-footer"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardFooter",
      options,
      id: create_fragment18.name
    });
  }
  get class() {
    throw new Error("<CardFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardFooter_default = CardFooter;

// node_modules/sveltestrap/src/CardGroup.svelte
var file18 = "node_modules/sveltestrap/src/CardGroup.svelte";
function create_fragment19(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file18, 9, 0, 165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-group"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardGroup",
      options,
      id: create_fragment19.name
    });
  }
  get class() {
    throw new Error("<CardGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardGroup_default = CardGroup;

// node_modules/sveltestrap/src/CardHeader.svelte
var file19 = "node_modules/sveltestrap/src/CardHeader.svelte";
function create_else_block7(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file19, 17, 2, 421);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler_1*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let h3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let h3_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let h3_data = {};
  for (let i = 0; i < h3_levels.length; i += 1) {
    h3_data = assign(h3_data, h3_levels[i]);
  }
  const block = {
    c: function create() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h3 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      if (default_slot)
        default_slot.l(h3_nodes);
      h3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(h3, h3_data);
      add_location(h3, file19, 12, 2, 282);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          h3,
          "click",
          /*click_handler*/
          ctx[6],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h3, h3_data = get_spread_update(h3_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h3);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(11:0) {#if tag === 'h3'}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block8, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[0] === "h3"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardHeader", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { tag = "div" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, tag, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    8) {
      $:
        $$invalidate(1, classes = classnames(className, "card-header"));
    }
  };
  return [
    tag,
    classes,
    $$restProps,
    className,
    $$scope,
    slots,
    click_handler,
    click_handler_1
  ];
}
var CardHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { class: 3, tag: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardHeader",
      options,
      id: create_fragment20.name
    });
  }
  get class() {
    throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardHeader_default = CardHeader;

// node_modules/sveltestrap/src/CardImg.svelte
var file20 = "node_modules/sveltestrap/src/CardImg.svelte";
function create_fragment21(ctx) {
  let img;
  let img_src_value;
  let img_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) },
    { src: img_src_value = /*src*/
    ctx[0] },
    { alt: (
      /*alt*/
      ctx[1]
    ) }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file20, 23, 0, 464);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        dirty & /*classes*/
        4 && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*src*/
        1 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx2[0]) && { src: img_src_value },
        dirty & /*alt*/
        2 && { alt: (
          /*alt*/
          ctx2[1]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "top", "bottom", "src", "alt"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardImg", slots, []);
  let { class: className = "" } = $$props;
  let { top = false } = $$props;
  let { bottom = false } = $$props;
  let { src } = $$props;
  let { alt = "" } = $$props;
  let classes = "";
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<CardImg> was created without expected prop 'src'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("top" in $$new_props)
      $$invalidate(5, top = $$new_props.top);
    if ("bottom" in $$new_props)
      $$invalidate(6, bottom = $$new_props.bottom);
    if ("src" in $$new_props)
      $$invalidate(0, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(1, alt = $$new_props.alt);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    top,
    bottom,
    src,
    alt,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("top" in $$props)
      $$invalidate(5, top = $$new_props.top);
    if ("bottom" in $$props)
      $$invalidate(6, bottom = $$new_props.bottom);
    if ("src" in $$props)
      $$invalidate(0, src = $$new_props.src);
    if ("alt" in $$props)
      $$invalidate(1, alt = $$new_props.alt);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*top, bottom, className*/
    112) {
      $: {
        let cardImgClassName = "card-img";
        if (top) {
          cardImgClassName = "card-img-top";
        }
        if (bottom) {
          cardImgClassName = "card-img-bottom";
        }
        $$invalidate(2, classes = classnames(className, cardImgClassName));
      }
    }
  };
  return [src, alt, classes, $$restProps, className, top, bottom];
}
var CardImg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      class: 4,
      top: 5,
      bottom: 6,
      src: 0,
      alt: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardImg",
      options,
      id: create_fragment21.name
    });
  }
  get class() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottom() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottom(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardImg_default = CardImg;

// node_modules/sveltestrap/src/CardImgOverlay.svelte
var file21 = "node_modules/sveltestrap/src/CardImgOverlay.svelte";
function create_fragment22(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file21, 9, 0, 171);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardImgOverlay", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-img-overlay"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardImgOverlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardImgOverlay",
      options,
      id: create_fragment22.name
    });
  }
  get class() {
    throw new Error("<CardImgOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardImgOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardImgOverlay_default = CardImgOverlay;

// node_modules/sveltestrap/src/CardLink.svelte
var file22 = "node_modules/sveltestrap/src/CardLink.svelte";
function create_fragment23(ctx) {
  let a;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { href: (
      /*href*/
      ctx[0]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file22, 10, 0, 188);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardLink", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { href = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, href, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    8) {
      $:
        $$invalidate(1, classes = classnames(className, "card-link"));
    }
  };
  return [href, classes, $$restProps, className, $$scope, slots];
}
var CardLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { class: 3, href: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardLink",
      options,
      id: create_fragment23.name
    });
  }
  get class() {
    throw new Error("<CardLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<CardLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<CardLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardLink_default = CardLink;

// node_modules/sveltestrap/src/CardSubtitle.svelte
var file23 = "node_modules/sveltestrap/src/CardSubtitle.svelte";
function create_fragment24(ctx) {
  let h6;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let h6_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let h6_data = {};
  for (let i = 0; i < h6_levels.length; i += 1) {
    h6_data = assign(h6_data, h6_levels[i]);
  }
  const block = {
    c: function create() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h6 = claim_element(nodes, "H6", { class: true });
      var h6_nodes = children(h6);
      if (default_slot)
        default_slot.l(h6_nodes);
      h6_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(h6, h6_data);
      add_location(h6, file23, 9, 0, 168);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h6, h6_data = get_spread_update(h6_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h6);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardSubtitle", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-subtitle"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardSubtitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardSubtitle",
      options,
      id: create_fragment24.name
    });
  }
  get class() {
    throw new Error("<CardSubtitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardSubtitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardSubtitle_default = CardSubtitle;

// node_modules/sveltestrap/src/CardText.svelte
var file24 = "node_modules/sveltestrap/src/CardText.svelte";
function create_fragment25(ctx) {
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let p_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(p, p_data);
      add_location(p, file24, 9, 0, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardText", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-text"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardText",
      options,
      id: create_fragment25.name
    });
  }
  get class() {
    throw new Error("<CardText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardText_default = CardText;

// node_modules/sveltestrap/src/CardTitle.svelte
var file25 = "node_modules/sveltestrap/src/CardTitle.svelte";
function create_fragment26(ctx) {
  let h5;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let h5_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let h5_data = {};
  for (let i = 0; i < h5_levels.length; i += 1) {
    h5_data = assign(h5_data, h5_levels[i]);
  }
  const block = {
    c: function create() {
      h5 = element("h5");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h5 = claim_element(nodes, "H5", { class: true });
      var h5_nodes = children(h5);
      if (default_slot)
        default_slot.l(h5_nodes);
      h5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(h5, h5_data);
      add_location(h5, file25, 9, 0, 165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h5, anchor);
      if (default_slot) {
        default_slot.m(h5, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h5, h5_data = get_spread_update(h5_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h5);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardTitle", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-title"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardTitle",
      options,
      id: create_fragment26.name
    });
  }
  get class() {
    throw new Error("<CardTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardTitle_default = CardTitle;

// node_modules/sveltestrap/src/Carousel.svelte
var file26 = "node_modules/sveltestrap/src/Carousel.svelte";
function create_fragment27(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let div_levels = [
    { role: "presentation" },
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true, class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file26, 84, 0, 1788);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "keydown",
            /*handleKeydown*/
            ctx[2],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "presentation" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "items", "activeIndex", "ride", "interval", "pause", "keyboard"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Carousel", slots, ["default"]);
  let classes = "";
  let { class: className = "" } = $$props;
  let { items = [] } = $$props;
  let { activeIndex = 0 } = $$props;
  let { ride = true } = $$props;
  let { interval = 5e3 } = $$props;
  let { pause = true } = $$props;
  let { keyboard = true } = $$props;
  let _rideTimeoutId = false;
  let _removeVisibilityChangeListener = false;
  onMount(() => {
    setRideTimeout();
    _removeVisibilityChangeListener = browserEvent(document, "visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        clearRideTimeout();
      } else {
        setRideTimeout();
      }
    });
  });
  onDestroy(() => {
    if (_rideTimeoutId) {
      clearTimeout(_rideTimeoutId);
    }
    if (_removeVisibilityChangeListener) {
      _removeVisibilityChangeListener();
    }
  });
  function handleKeydown(event) {
    if (!keyboard) {
      return;
    }
    let direction = "";
    if (event.key === "ArrowLeft") {
      direction = "prev";
    } else if (event.key === "ArrowRight") {
      direction = "next";
    } else {
      return;
    }
    $$invalidate(6, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
  }
  function setRideTimeout() {
    clearRideTimeout();
    if (ride) {
      _rideTimeoutId = setTimeout(autoNext, interval);
    }
  }
  function clearRideTimeout() {
    if (_rideTimeoutId) {
      clearTimeout(_rideTimeoutId);
    }
  }
  function autoNext() {
    $$invalidate(6, activeIndex = getNewCarouselActiveIndex("next", items, activeIndex));
  }
  const mouseenter_handler = () => pause ? clearRideTimeout() : void 0;
  const mouseleave_handler = () => pause ? setRideTimeout() : void 0;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("items" in $$new_props)
      $$invalidate(8, items = $$new_props.items);
    if ("activeIndex" in $$new_props)
      $$invalidate(6, activeIndex = $$new_props.activeIndex);
    if ("ride" in $$new_props)
      $$invalidate(9, ride = $$new_props.ride);
    if ("interval" in $$new_props)
      $$invalidate(10, interval = $$new_props.interval);
    if ("pause" in $$new_props)
      $$invalidate(0, pause = $$new_props.pause);
    if ("keyboard" in $$new_props)
      $$invalidate(11, keyboard = $$new_props.keyboard);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    classnames,
    getNewCarouselActiveIndex,
    browserEvent,
    classes,
    className,
    items,
    activeIndex,
    ride,
    interval,
    pause,
    keyboard,
    _rideTimeoutId,
    _removeVisibilityChangeListener,
    handleKeydown,
    setRideTimeout,
    clearRideTimeout,
    autoNext
  });
  $$self.$inject_state = ($$new_props) => {
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("items" in $$props)
      $$invalidate(8, items = $$new_props.items);
    if ("activeIndex" in $$props)
      $$invalidate(6, activeIndex = $$new_props.activeIndex);
    if ("ride" in $$props)
      $$invalidate(9, ride = $$new_props.ride);
    if ("interval" in $$props)
      $$invalidate(10, interval = $$new_props.interval);
    if ("pause" in $$props)
      $$invalidate(0, pause = $$new_props.pause);
    if ("keyboard" in $$props)
      $$invalidate(11, keyboard = $$new_props.keyboard);
    if ("_rideTimeoutId" in $$props)
      _rideTimeoutId = $$new_props._rideTimeoutId;
    if ("_removeVisibilityChangeListener" in $$props)
      _removeVisibilityChangeListener = $$new_props._removeVisibilityChangeListener;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    128) {
      $:
        $$invalidate(1, classes = classnames(className, "carousel", "slide"));
    }
  };
  return [
    pause,
    classes,
    handleKeydown,
    setRideTimeout,
    clearRideTimeout,
    $$restProps,
    activeIndex,
    className,
    items,
    ride,
    interval,
    keyboard,
    $$scope,
    slots,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Carousel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      class: 7,
      items: 8,
      activeIndex: 6,
      ride: 9,
      interval: 10,
      pause: 0,
      keyboard: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Carousel",
      options,
      id: create_fragment27.name
    });
  }
  get class() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ride() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ride(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interval() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interval(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pause(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyboard() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyboard(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Carousel_default = Carousel;

// node_modules/sveltestrap/src/CarouselCaption.svelte
var file27 = "node_modules/sveltestrap/src/CarouselCaption.svelte";
function create_if_block_14(ctx) {
  let h5;
  let t;
  const block = {
    c: function create() {
      h5 = element("h5");
      t = text(
        /*captionHeader*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      h5 = claim_element(nodes, "H5", {});
      var h5_nodes = children(h5);
      t = claim_text(
        h5_nodes,
        /*captionHeader*/
        ctx[0]
      );
      h5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h5, file27, 18, 21, 359);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h5, anchor);
      append_hydration_dev(h5, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*captionHeader*/
      1)
        set_data_dev(
          t,
          /*captionHeader*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h5);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(19:2) {#if captionHeader}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(
        /*captionText*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(
        p_nodes,
        /*captionText*/
        ctx[1]
      );
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file27, 19, 19, 408);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*captionText*/
      2)
        set_data_dev(
          t,
          /*captionText*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(20:2) {#if captionText}",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*captionHeader*/
    ctx[0] && create_if_block_14(ctx)
  );
  let if_block1 = (
    /*captionText*/
    ctx[1] && create_if_block9(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file27, 17, 0, 299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*captionHeader*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*captionText*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block9(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "captionHeader", "captionText"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselCaption", slots, ["default"]);
  let classes = "";
  let { class: className = "" } = $$props;
  let { captionHeader = "" } = $$props;
  let { captionText = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("captionHeader" in $$new_props)
      $$invalidate(0, captionHeader = $$new_props.captionHeader);
    if ("captionText" in $$new_props)
      $$invalidate(1, captionText = $$new_props.captionText);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    classes,
    className,
    captionHeader,
    captionText
  });
  $$self.$inject_state = ($$new_props) => {
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("captionHeader" in $$props)
      $$invalidate(0, captionHeader = $$new_props.captionHeader);
    if ("captionText" in $$props)
      $$invalidate(1, captionText = $$new_props.captionText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    16) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel-caption", "d-none", "d-md-block"));
    }
  };
  return [captionHeader, captionText, classes, $$restProps, className, $$scope, slots];
}
var CarouselCaption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      class: 4,
      captionHeader: 0,
      captionText: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselCaption",
      options,
      id: create_fragment28.name
    });
  }
  get class() {
    throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get captionHeader() {
    throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set captionHeader(value) {
    throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get captionText() {
    throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set captionText(value) {
    throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselCaption_default = CarouselCaption;

// node_modules/sveltestrap/src/CarouselControl.svelte
var file28 = "node_modules/sveltestrap/src/CarouselControl.svelte";
function create_fragment29(ctx) {
  let a;
  let span0;
  let span0_class_value;
  let t0;
  let span1;
  let t1;
  let a_href_value;
  let mounted;
  let dispose;
  let a_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { role: "button" },
    {
      href: a_href_value = "#" + /*direction*/
      ctx[0]
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(
        /*srText*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { class: true, role: true, href: true });
      var a_nodes = children(a);
      span0 = claim_element(a_nodes, "SPAN", { class: true, "aria-hidden": true });
      children(span0).forEach(detach_dev);
      t0 = claim_space(a_nodes);
      span1 = claim_element(a_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(
        span1_nodes,
        /*srText*/
        ctx[2]
      );
      span1_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = "carousel-control-" + /*direction*/
      ctx[0] + "-icon");
      attr_dev(span0, "aria-hidden", "true");
      add_location(span0, file28, 46, 2, 1099);
      attr_dev(span1, "class", "visually-hidden");
      add_location(span1, file28, 47, 2, 1171);
      set_attributes(a, a_data);
      add_location(a, file28, 39, 0, 976);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, span0);
      append_hydration_dev(a, t0);
      append_hydration_dev(a, span1);
      append_hydration_dev(span1, t1);
      if (!mounted) {
        dispose = listen_dev(a, "click", prevent_default(
          /*clickHandler*/
          ctx[3]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*direction*/
      1 && span0_class_value !== (span0_class_value = "carousel-control-" + /*direction*/
      ctx2[0] + "-icon")) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (dirty & /*srText*/
      4)
        set_data_dev(
          t1,
          /*srText*/
          ctx2[2]
        );
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        dirty & /*classes*/
        2 && { class: (
          /*classes*/
          ctx2[1]
        ) },
        { role: "button" },
        dirty & /*direction*/
        1 && a_href_value !== (a_href_value = "#" + /*direction*/
        ctx2[0]) && { href: a_href_value }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "direction", "directionText", "activeIndex", "items", "wrap"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselControl", slots, []);
  let classes = "";
  let { class: className = "" } = $$props;
  let srText = "";
  let { direction = "" } = $$props;
  let { directionText = "" } = $$props;
  let { activeIndex = 0 } = $$props;
  let { items = [] } = $$props;
  let { wrap = true } = $$props;
  const getSrText = (direction2) => {
    if (direction2 === "next") {
      return "Next";
    } else if (direction2 === "prev") {
      return "Previous";
    }
  };
  function clickHandler() {
    const endOrBeginning = direction === "next" && activeIndex + 1 > items.length - 1 || direction === "previous" && activeIndex - 1 < 0;
    if (!wrap && endOrBeginning) {
      return;
    }
    $$invalidate(5, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("direction" in $$new_props)
      $$invalidate(0, direction = $$new_props.direction);
    if ("directionText" in $$new_props)
      $$invalidate(7, directionText = $$new_props.directionText);
    if ("activeIndex" in $$new_props)
      $$invalidate(5, activeIndex = $$new_props.activeIndex);
    if ("items" in $$new_props)
      $$invalidate(8, items = $$new_props.items);
    if ("wrap" in $$new_props)
      $$invalidate(9, wrap = $$new_props.wrap);
  };
  $$self.$capture_state = () => ({
    classnames,
    getNewCarouselActiveIndex,
    classes,
    className,
    srText,
    direction,
    directionText,
    activeIndex,
    items,
    wrap,
    getSrText,
    clickHandler
  });
  $$self.$inject_state = ($$new_props) => {
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("srText" in $$props)
      $$invalidate(2, srText = $$new_props.srText);
    if ("direction" in $$props)
      $$invalidate(0, direction = $$new_props.direction);
    if ("directionText" in $$props)
      $$invalidate(7, directionText = $$new_props.directionText);
    if ("activeIndex" in $$props)
      $$invalidate(5, activeIndex = $$new_props.activeIndex);
    if ("items" in $$props)
      $$invalidate(8, items = $$new_props.items);
    if ("wrap" in $$props)
      $$invalidate(9, wrap = $$new_props.wrap);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*direction, className*/
    65) {
      $:
        $$invalidate(1, classes = classnames(`carousel-control-${direction}`, className));
    }
    if ($$self.$$.dirty & /*directionText, direction*/
    129) {
      $:
        $$invalidate(2, srText = directionText ? directionText : getSrText(direction));
    }
  };
  return [
    direction,
    classes,
    srText,
    clickHandler,
    $$restProps,
    activeIndex,
    className,
    directionText,
    items,
    wrap
  ];
}
var CarouselControl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      class: 6,
      direction: 0,
      directionText: 7,
      activeIndex: 5,
      items: 8,
      wrap: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselControl",
      options,
      id: create_fragment29.name
    });
  }
  get class() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get directionText() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set directionText(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrap() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrap(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselControl_default = CarouselControl;

// node_modules/sveltestrap/src/CarouselIndicators.svelte
var file29 = "node_modules/sveltestrap/src/CarouselIndicators.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_each_block(ctx) {
  let button;
  let t0_value = (
    /*item*/
    (ctx[6].title ? (
      /*item*/
      ctx[6].title
    ) : "") + ""
  );
  let t0;
  let t1;
  let button_aria_current_value;
  let button_aria_label_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[5](
        /*index*/
        ctx[8]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "data-bs-target": true,
        "aria-current": true,
        "aria-label": true
      });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      t1 = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "data-bs-target", "");
      attr_dev(button, "aria-current", button_aria_current_value = /*activeIndex*/
      ctx[0] === /*index*/
      ctx[8]);
      attr_dev(button, "aria-label", button_aria_label_value = /*item*/
      ctx[6].title);
      toggle_class(
        button,
        "active",
        /*activeIndex*/
        ctx[0] === /*index*/
        ctx[8]
      );
      add_location(button, file29, 14, 4, 323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*items*/
      2 && t0_value !== (t0_value = /*item*/
      (ctx[6].title ? (
        /*item*/
        ctx[6].title
      ) : "") + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*activeIndex*/
      1 && button_aria_current_value !== (button_aria_current_value = /*activeIndex*/
      ctx[0] === /*index*/
      ctx[8])) {
        attr_dev(button, "aria-current", button_aria_current_value);
      }
      if (dirty & /*items*/
      2 && button_aria_label_value !== (button_aria_label_value = /*item*/
      ctx[6].title)) {
        attr_dev(button, "aria-label", button_aria_label_value);
      }
      if (dirty & /*activeIndex*/
      1) {
        toggle_class(
          button,
          "active",
          /*activeIndex*/
          ctx[0] === /*index*/
          ctx[8]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(14:2) {#each items as item, index}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let div;
  let each_value = (
    /*items*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file29, 12, 0, 249);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*activeIndex, items*/
      3) {
        each_value = /*items*/
        ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        dirty & /*classes*/
        4 && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "items", "activeIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselIndicators", slots, []);
  let { class: className = "" } = $$props;
  let classes = "";
  let { items = [] } = $$props;
  let { activeIndex = 0 } = $$props;
  const click_handler = (index) => $$invalidate(0, activeIndex = index);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("items" in $$new_props)
      $$invalidate(1, items = $$new_props.items);
    if ("activeIndex" in $$new_props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    classes,
    items,
    activeIndex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
    if ("items" in $$props)
      $$invalidate(1, items = $$new_props.items);
    if ("activeIndex" in $$props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    16) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel-indicators"));
    }
  };
  return [activeIndex, items, classes, $$restProps, className, click_handler];
}
var CarouselIndicators = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { class: 4, items: 1, activeIndex: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselIndicators",
      options,
      id: create_fragment30.name
    });
  }
  get class() {
    throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselIndicators_default = CarouselIndicators;

// node_modules/sveltestrap/src/CarouselItem.svelte
var file30 = "node_modules/sveltestrap/src/CarouselItem.svelte";
function create_fragment31(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    {
      class: div_class_value = /*classes*/
      ctx[2] + " active"
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(
        div,
        "active",
        /*itemIndex*/
        ctx[0] === /*activeIndex*/
        ctx[1]
      );
      add_location(div, file30, 12, 0, 246);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4 && div_class_value !== (div_class_value = /*classes*/
        ctx2[2] + " active")) && { class: div_class_value }
      ]));
      toggle_class(
        div,
        "active",
        /*itemIndex*/
        ctx2[0] === /*activeIndex*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "itemIndex", "activeIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselItem", slots, ["default"]);
  let classes = "";
  let { class: className = "" } = $$props;
  let { itemIndex = 0 } = $$props;
  let { activeIndex = 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("itemIndex" in $$new_props)
      $$invalidate(0, itemIndex = $$new_props.itemIndex);
    if ("activeIndex" in $$new_props)
      $$invalidate(1, activeIndex = $$new_props.activeIndex);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    classes,
    className,
    itemIndex,
    activeIndex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("itemIndex" in $$props)
      $$invalidate(0, itemIndex = $$new_props.itemIndex);
    if ("activeIndex" in $$props)
      $$invalidate(1, activeIndex = $$new_props.activeIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    16) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel-item"));
    }
  };
  return [itemIndex, activeIndex, classes, $$restProps, className, $$scope, slots];
}
var CarouselItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, { class: 4, itemIndex: 0, activeIndex: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselItem",
      options,
      id: create_fragment31.name
    });
  }
  get class() {
    throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemIndex() {
    throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemIndex(value) {
    throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselItem_default = CarouselItem;

// node_modules/sveltestrap/src/Col.svelte
var file31 = "node_modules/sveltestrap/src/Col.svelte";
function create_fragment32(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    {
      class: div_class_value = /*colClasses*/
      ctx[0].join(" ")
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file31, 63, 0, 1536);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        { class: div_class_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "xs", "sm", "md", "lg", "xl", "xxl"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Col", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { xs = void 0 } = $$props;
  let { sm = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { lg = void 0 } = $$props;
  let { xl = void 0 } = $$props;
  let { xxl = void 0 } = $$props;
  const colClasses = [];
  const lookup = { xs, sm, md, lg, xl, xxl };
  Object.keys(lookup).forEach((colWidth) => {
    const columnProp = lookup[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    const isXs = colWidth === "xs";
    if (isObject(columnProp)) {
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      const colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      if (columnProp.size || columnProp.size === "") {
        colClasses.push(colClass);
      }
      if (columnProp.push) {
        colClasses.push(`push${colSizeInterfix}${columnProp.push}`);
      }
      if (columnProp.pull) {
        colClasses.push(`pull${colSizeInterfix}${columnProp.pull}`);
      }
      if (columnProp.offset) {
        colClasses.push(`offset${colSizeInterfix}${columnProp.offset}`);
      }
      if (columnProp.order) {
        colClasses.push(`order${colSizeInterfix}${columnProp.order}`);
      }
    } else {
      colClasses.push(getColumnSizeClass(isXs, colWidth, columnProp));
    }
  });
  if (!colClasses.length) {
    colClasses.push("col");
  }
  if (className) {
    colClasses.push(className);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("xs" in $$new_props)
      $$invalidate(3, xs = $$new_props.xs);
    if ("sm" in $$new_props)
      $$invalidate(4, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(5, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(6, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(7, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(8, xxl = $$new_props.xxl);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getColumnSizeClass,
    isObject,
    className,
    xs,
    sm,
    md,
    lg,
    xl,
    xxl,
    colClasses,
    lookup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("xs" in $$props)
      $$invalidate(3, xs = $$new_props.xs);
    if ("sm" in $$props)
      $$invalidate(4, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(5, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(6, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(7, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(8, xxl = $$new_props.xxl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [colClasses, $$restProps, className, xs, sm, md, lg, xl, xxl, $$scope, slots];
}
var Col = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {
      class: 2,
      xs: 3,
      sm: 4,
      md: 5,
      lg: 6,
      xl: 7,
      xxl: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Col",
      options,
      id: create_fragment32.name
    });
  }
  get class() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xs() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xs(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Col_default = Col;

// node_modules/sveltestrap/src/Column.svelte
var file32 = "node_modules/sveltestrap/src/Column.svelte";
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
function create_else_block8(ctx) {
  let td;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let td_levels = [
    { class: (
      /*className*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let td_data = {};
  for (let i = 0; i < td_levels.length; i += 1) {
    td_data = assign(td_data, td_levels[i]);
  }
  const block = {
    c: function create() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      if (default_slot)
        default_slot.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(td, td_data);
      add_location(td, file32, 27, 2, 600);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(td, td_data = get_spread_update(td_levels, [
        (!current || dirty & /*className*/
        1) && { class: (
          /*className*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(27:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let th;
  let t;
  let current;
  let if_block = (
    /*header*/
    ctx[2] && create_if_block_4(ctx)
  );
  const header_slot_template = (
    /*#slots*/
    ctx[9].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_header_slot_context2
  );
  let th_levels = [
    /*$$restProps*/
    ctx[7]
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      if (if_block)
        if_block.c();
      t = space();
      if (header_slot)
        header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {});
      var th_nodes = children(th);
      if (if_block)
        if_block.l(th_nodes);
      t = claim_space(th_nodes);
      if (header_slot)
        header_slot.l(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(th, th_data);
      add_location(th, file32, 22, 2, 503);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      if (if_block)
        if_block.m(th, null);
      append_hydration_dev(th, t);
      if (header_slot) {
        header_slot.m(th, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*header*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(th, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_header_slot_changes2
            ),
            get_header_slot_context2
          );
        }
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [dirty & /*$$restProps*/
      128 && /*$$restProps*/
      ctx2[7]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (if_block)
        if_block.d();
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(22:15) ",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let th;
  let t;
  let current;
  let if_block = (
    /*footer*/
    ctx[1] && create_if_block_24(ctx)
  );
  const footer_slot_template = (
    /*#slots*/
    ctx[9].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_footer_slot_context
  );
  let th_levels = [
    /*$$restProps*/
    ctx[7]
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      if (if_block)
        if_block.c();
      t = space();
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {});
      var th_nodes = children(th);
      if (if_block)
        if_block.l(th_nodes);
      t = claim_space(th_nodes);
      if (footer_slot)
        footer_slot.l(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(th, th_data);
      add_location(th, file32, 17, 2, 398);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      if (if_block)
        if_block.m(th, null);
      append_hydration_dev(th, t);
      if (footer_slot) {
        footer_slot.m(th, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*footer*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_24(ctx2);
          if_block.c();
          if_block.m(th, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [dirty & /*$$restProps*/
      128 && /*$$restProps*/
      ctx2[7]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (if_block)
        if_block.d();
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(17:15) ",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let col;
  const block = {
    c: function create() {
      col = element("col");
      this.h();
    },
    l: function claim(nodes) {
      col = claim_element(nodes, "COL", { style: true });
      this.h();
    },
    h: function hydrate() {
      set_style(
        col,
        "width",
        /*width*/
        ctx[3]
      );
      add_location(col, file32, 15, 2, 348);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, col, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*width*/
      8) {
        set_style(
          col,
          "width",
          /*width*/
          ctx2[3]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(col);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(15:0) {#if colgroup}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*header*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*header*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*header*/
      4)
        set_data_dev(
          t,
          /*header*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(24:4) {#if header}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*footer*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*footer*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*footer*/
      2)
        set_data_dev(
          t,
          /*footer*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(19:4) {#if footer}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block10, create_if_block_15, create_if_block_32, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*colgroup*/
      ctx2[4]
    )
      return 0;
    if (
      /*foot*/
      ctx2[6]
    )
      return 1;
    if (
      /*head*/
      ctx2[5]
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "footer", "header", "width"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Column", slots, ["footer", "header", "default"]);
  let { class: className = "" } = $$props;
  let { footer = void 0 } = $$props;
  let { header = void 0 } = $$props;
  let { width = void 0 } = $$props;
  const colgroup = getContext("colgroup");
  const head = getContext("header");
  const foot = getContext("footer");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("footer" in $$new_props)
      $$invalidate(1, footer = $$new_props.footer);
    if ("header" in $$new_props)
      $$invalidate(2, header = $$new_props.header);
    if ("width" in $$new_props)
      $$invalidate(3, width = $$new_props.width);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    className,
    footer,
    header,
    width,
    colgroup,
    head,
    foot
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("footer" in $$props)
      $$invalidate(1, footer = $$new_props.footer);
    if ("header" in $$props)
      $$invalidate(2, header = $$new_props.header);
    if ("width" in $$props)
      $$invalidate(3, width = $$new_props.width);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    footer,
    header,
    width,
    colgroup,
    head,
    foot,
    $$restProps,
    $$scope,
    slots
  ];
}
var Column = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { class: 0, footer: 1, header: 2, width: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Column",
      options,
      id: create_fragment33.name
    });
  }
  get class() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footer() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footer(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Column_default = Column;

// node_modules/sveltestrap/src/Container.svelte
var file33 = "node_modules/sveltestrap/src/Container.svelte";
function create_fragment34(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file33, 23, 0, 542);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "sm", "md", "lg", "xl", "xxl", "fluid"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Container", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { sm = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { lg = void 0 } = $$props;
  let { xl = void 0 } = $$props;
  let { xxl = void 0 } = $$props;
  let { fluid = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("sm" in $$new_props)
      $$invalidate(3, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(4, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(5, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(6, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(7, xxl = $$new_props.xxl);
    if ("fluid" in $$new_props)
      $$invalidate(8, fluid = $$new_props.fluid);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    sm,
    md,
    lg,
    xl,
    xxl,
    fluid,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("sm" in $$props)
      $$invalidate(3, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(4, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(5, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(6, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(7, xxl = $$new_props.xxl);
    if ("fluid" in $$props)
      $$invalidate(8, fluid = $$new_props.fluid);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, sm, md, lg, xl, xxl, fluid*/
    508) {
      $:
        $$invalidate(0, classes = classnames(className, {
          "container-sm": sm,
          "container-md": md,
          "container-lg": lg,
          "container-xl": xl,
          "container-xxl": xxl,
          "container-fluid": fluid,
          container: !sm && !md && !lg && !xl && !xxl && !fluid
        }));
    }
  };
  return [classes, $$restProps, className, sm, md, lg, xl, xxl, fluid, $$scope, slots];
}
var Container = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {
      class: 2,
      sm: 3,
      md: 4,
      lg: 5,
      xl: 6,
      xxl: 7,
      fluid: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Container",
      options,
      id: create_fragment34.name
    });
  }
  get class() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fluid() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fluid(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Container_default = Container;

// node_modules/sveltestrap/src/DropdownItem.svelte
var file34 = "node_modules/sveltestrap/src/DropdownItem.svelte";
function create_else_block9(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let button_levels = [
    { type: "button" },
    /*$$restProps*/
    ctx[6],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file34, 53, 2, 1198);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*handleItemClick*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(53:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[6],
    { click: "" },
    { href: (
      /*href*/
      ctx[2]
    ) },
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { click: true, href: true, class: true });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file34, 49, 2, 1091);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*handleItemClick*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        { click: "" },
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(49:15) ",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[6],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file34, 45, 2, 976);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*handleItemClick*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(44:18) ",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let h6;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let h6_levels = [
    /*$$restProps*/
    ctx[6],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let h6_data = {};
  for (let i = 0; i < h6_levels.length; i += 1) {
    h6_data = assign(h6_data, h6_levels[i]);
  }
  const block = {
    c: function create() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h6 = claim_element(nodes, "H6", { class: true });
      var h6_nodes = children(h6);
      if (default_slot)
        default_slot.l(h6_nodes);
      h6_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(h6, h6_data);
      add_location(h6, file34, 40, 2, 835);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h6, h6_data = get_spread_update(h6_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h6);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(40:0) {#if header}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block11, create_if_block_16, create_if_block_25, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*header*/
      ctx2[1]
    )
      return 0;
    if (
      /*divider*/
      ctx2[0]
    )
      return 1;
    if (
      /*href*/
      ctx2[2]
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled", "divider", "header", "toggle", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownItem", slots, ["default"]);
  const context = getContext("dropdownContext");
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(15, $context = value));
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { divider = false } = $$props;
  let { header = false } = $$props;
  let { toggle = true } = $$props;
  let { href = "" } = $$props;
  function handleItemClick(e) {
    if (disabled || header || divider) {
      e.preventDefault();
      return;
    }
    if (toggle && ($context.autoClose === true || $context.autoClose === "outside")) {
      $context.toggle(e);
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(8, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("divider" in $$new_props)
      $$invalidate(0, divider = $$new_props.divider);
    if ("header" in $$new_props)
      $$invalidate(1, header = $$new_props.header);
    if ("toggle" in $$new_props)
      $$invalidate(10, toggle = $$new_props.toggle);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    context,
    className,
    active,
    disabled,
    divider,
    header,
    toggle,
    href,
    handleItemClick,
    classes,
    $context
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(8, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("divider" in $$props)
      $$invalidate(0, divider = $$new_props.divider);
    if ("header" in $$props)
      $$invalidate(1, header = $$new_props.header);
    if ("toggle" in $$props)
      $$invalidate(10, toggle = $$new_props.toggle);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, disabled, divider, header, active*/
    899) {
      $:
        $$invalidate(3, classes = classnames(className, {
          disabled,
          "dropdown-item": !divider && !header,
          active,
          "dropdown-header": header,
          "dropdown-divider": divider
        }));
    }
  };
  return [
    divider,
    header,
    href,
    classes,
    context,
    handleItemClick,
    $$restProps,
    className,
    active,
    disabled,
    toggle,
    $$scope,
    slots,
    click_handler,
    click_handler_1
  ];
}
var DropdownItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      class: 7,
      active: 8,
      disabled: 9,
      divider: 0,
      header: 1,
      toggle: 10,
      href: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownItem",
      options,
      id: create_fragment35.name
    });
  }
  get class() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get divider() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set divider(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownItem_default = DropdownItem;

// node_modules/sveltestrap/src/DropdownMenu.svelte
var file35 = "node_modules/sveltestrap/src/DropdownMenu.svelte";
function create_fragment36(ctx) {
  let div;
  let div_data_bs_popper_value;
  let $context_popperContent_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    {
      "data-bs-popper": div_data_bs_popper_value = /*$context*/
      ctx[0].inNavbar ? "static" : void 0
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-bs-popper": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file35, 39, 0, 874);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer($context_popperContent_action = /*$context*/
        ctx[0].popperContent(
          div,
          /*popperOptions*/
          ctx[2]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*$context*/
        1 && div_data_bs_popper_value !== (div_data_bs_popper_value = /*$context*/
        ctx2[0].inNavbar ? "static" : void 0)) && {
          "data-bs-popper": div_data_bs_popper_value
        }
      ]));
      if ($context_popperContent_action && is_function($context_popperContent_action.update) && dirty & /*popperOptions*/
      4)
        $context_popperContent_action.update.call(
          null,
          /*popperOptions*/
          ctx2[2]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let popperOptions;
  let classes;
  const omit_props_names = ["class", "end", "right"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenu", slots, ["default"]);
  const context = getContext("dropdownContext");
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let { class: className = "" } = $$props;
  let { end = false } = $$props;
  let { right = false } = $$props;
  const popperPlacement = (direction, end2) => {
    let prefix = direction;
    if (direction === "up")
      prefix = "top";
    else if (direction === "down")
      prefix = "bottom";
    let suffix = end2 ? "end" : "start";
    return `${prefix}-${suffix}`;
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("end" in $$new_props)
      $$invalidate(6, end = $$new_props.end);
    if ("right" in $$new_props)
      $$invalidate(7, right = $$new_props.right);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    context,
    className,
    end,
    right,
    popperPlacement,
    classes,
    popperOptions,
    $context
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("end" in $$props)
      $$invalidate(6, end = $$new_props.end);
    if ("right" in $$props)
      $$invalidate(7, right = $$new_props.right);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("popperOptions" in $$props)
      $$invalidate(2, popperOptions = $$new_props.popperOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, end, right*/
    193) {
      $:
        $$invalidate(2, popperOptions = {
          modifiers: [
            { name: "flip" },
            {
              name: "offset",
              options: { offset: [0, 2] }
            }
          ],
          placement: popperPlacement($context.direction, end || right)
        });
    }
    if ($$self.$$.dirty & /*className, end, right, $context*/
    225) {
      $:
        $$invalidate(1, classes = classnames(className, "dropdown-menu", {
          "dropdown-menu-end": end || right,
          show: $context.isOpen
        }));
    }
  };
  return [
    $context,
    classes,
    popperOptions,
    context,
    $$restProps,
    className,
    end,
    right,
    $$scope,
    slots
  ];
}
var DropdownMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { class: 5, end: 6, right: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenu",
      options,
      id: create_fragment36.name
    });
  }
  get class() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get end() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set end(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get right() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set right(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenu_default = DropdownMenu;

// node_modules/sveltestrap/src/DropdownToggle.svelte
var file36 = "node_modules/sveltestrap/src/DropdownToggle.svelte";
function create_else_block10(ctx) {
  let button;
  let button_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_3(ctx);
  let button_levels = [
    /*$$restProps*/
    ctx[9],
    { type: "button" },
    {
      "aria-expanded": button_aria_expanded_value = /*$context*/
      ctx[6].isOpen
    },
    { class: (
      /*btnClasses*/
      ctx[5]
    ) }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block_1 = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-expanded": true,
        class: true
      });
      var button_nodes = children(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file36, 96, 2, 2070);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[28](button);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = /*$context*/
          ctx[6].popperRef(button)),
          listen_dev(
            button,
            "click",
            /*click_handler_3*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*toggleButton*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9],
        { type: "button" },
        (!current || dirty & /*$context*/
        64 && button_aria_expanded_value !== (button_aria_expanded_value = /*$context*/
        ctx2[6].isOpen)) && {
          "aria-expanded": button_aria_expanded_value
        },
        (!current || dirty & /*btnClasses*/
        32) && { class: (
          /*btnClasses*/
          ctx2[5]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[28](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block10.name,
    type: "else",
    source: "(96:0) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_26(ctx) {
  let span;
  let span_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_2(ctx);
  let span_levels = [
    /*$$restProps*/
    ctx[9],
    {
      "aria-expanded": span_aria_expanded_value = /*$context*/
      ctx[6].isOpen
    },
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block_1 = {
    c: function create() {
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { "aria-expanded": true, class: true });
      var span_nodes = children(span);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file36, 82, 2, 1795);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[27](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = /*$context*/
          ctx[6].popperRef(span)),
          listen_dev(
            span,
            "click",
            /*click_handler_2*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "click",
            /*toggleButton*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9],
        (!current || dirty & /*$context*/
        64 && span_aria_expanded_value !== (span_aria_expanded_value = /*$context*/
        ctx2[6].isOpen)) && {
          "aria-expanded": span_aria_expanded_value
        },
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_26.name,
    type: "if",
    source: "(81:25) ",
    ctx
  });
  return block_1;
}
function create_if_block_17(ctx) {
  let div;
  let div_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_1(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[9],
    {
      "aria-expanded": div_aria_expanded_value = /*$context*/
      ctx[6].isOpen
    },
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block_1 = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "aria-expanded": true, class: true });
      var div_nodes = children(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file36, 67, 2, 1443);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      ctx[26](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = /*$context*/
          ctx[6].popperRef(div)),
          listen_dev(
            div,
            "click",
            /*click_handler_1*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*toggleButton*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9],
        (!current || dirty & /*$context*/
        64 && div_aria_expanded_value !== (div_aria_expanded_value = /*$context*/
        ctx2[6].isOpen)) && { "aria-expanded": div_aria_expanded_value },
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_17.name,
    type: "if",
    source: "(66:24) ",
    ctx
  });
  return block_1;
}
function create_if_block12(ctx) {
  let a;
  let a_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block2(ctx);
  let a_levels = [
    /*$$restProps*/
    ctx[9],
    { href: "#nav" },
    {
      "aria-expanded": a_aria_expanded_value = /*$context*/
      ctx[6].isOpen
    },
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block_1 = {
    c: function create() {
      a = element("a");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        href: true,
        "aria-expanded": true,
        class: true
      });
      var a_nodes = children(a);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file36, 51, 2, 1080);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      ctx[25](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = /*$context*/
          ctx[6].popperRef(a)),
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "click",
            /*toggleButton*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9],
        { href: "#nav" },
        (!current || dirty & /*$context*/
        64 && a_aria_expanded_value !== (a_aria_expanded_value = /*$context*/
        ctx2[6].isOpen)) && { "aria-expanded": a_aria_expanded_value },
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block12.name,
    type: "if",
    source: "(51:0) {#if nav}",
    ctx
  });
  return block_1;
}
function fallback_block_3(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*ariaLabel*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 107, 6, 2287);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      2)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(107:10)        ",
    ctx
  });
  return block_1;
}
function fallback_block_2(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*ariaLabel*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 92, 6, 1989);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      2)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(92:10)        ",
    ctx
  });
  return block_1;
}
function fallback_block_1(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*ariaLabel*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 77, 6, 1636);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      2)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(77:10)        ",
    ctx
  });
  return block_1;
}
function fallback_block2(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*ariaLabel*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 62, 6, 1287);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      2)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block2.name,
    type: "fallback",
    source: "(62:10)        ",
    ctx
  });
  return block_1;
}
function create_fragment37(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block12, create_if_block_17, create_if_block_26, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*nav*/
      ctx2[2]
    )
      return 0;
    if (
      /*tag*/
      ctx2[3] === "div"
    )
      return 1;
    if (
      /*tag*/
      ctx2[3] === "span"
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance37($$self, $$props, $$invalidate) {
  let classes;
  let btnClasses;
  const omit_props_names = [
    "class",
    "ariaLabel",
    "active",
    "block",
    "caret",
    "color",
    "disabled",
    "inner",
    "nav",
    "outline",
    "size",
    "split",
    "tag"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownToggle", slots, ["default"]);
  const context = getContext("dropdownContext");
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(6, $context = value));
  let { class: className = "" } = $$props;
  let { ariaLabel = "Toggle Dropdown" } = $$props;
  let { active = false } = $$props;
  let { block = false } = $$props;
  let { caret = false } = $$props;
  let { color = "secondary" } = $$props;
  let { disabled = false } = $$props;
  let { inner = void 0 } = $$props;
  let { nav = false } = $$props;
  let { outline = false } = $$props;
  let { size = "" } = $$props;
  let { split = false } = $$props;
  let { tag = null } = $$props;
  function toggleButton(e) {
    if (disabled) {
      e.preventDefault();
      return;
    }
    if (nav) {
      e.preventDefault();
    }
    $context.toggle(e);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("ariaLabel" in $$new_props)
      $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
    if ("active" in $$new_props)
      $$invalidate(11, active = $$new_props.active);
    if ("block" in $$new_props)
      $$invalidate(12, block = $$new_props.block);
    if ("caret" in $$new_props)
      $$invalidate(13, caret = $$new_props.caret);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("nav" in $$new_props)
      $$invalidate(2, nav = $$new_props.nav);
    if ("outline" in $$new_props)
      $$invalidate(16, outline = $$new_props.outline);
    if ("size" in $$new_props)
      $$invalidate(17, size = $$new_props.size);
    if ("split" in $$new_props)
      $$invalidate(18, split = $$new_props.split);
    if ("tag" in $$new_props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    context,
    className,
    ariaLabel,
    active,
    block,
    caret,
    color,
    disabled,
    inner,
    nav,
    outline,
    size,
    split,
    tag,
    toggleButton,
    classes,
    btnClasses,
    $context
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("ariaLabel" in $$props)
      $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
    if ("active" in $$props)
      $$invalidate(11, active = $$new_props.active);
    if ("block" in $$props)
      $$invalidate(12, block = $$new_props.block);
    if ("caret" in $$props)
      $$invalidate(13, caret = $$new_props.caret);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("nav" in $$props)
      $$invalidate(2, nav = $$new_props.nav);
    if ("outline" in $$props)
      $$invalidate(16, outline = $$new_props.outline);
    if ("size" in $$props)
      $$invalidate(17, size = $$new_props.size);
    if ("split" in $$props)
      $$invalidate(18, split = $$new_props.split);
    if ("tag" in $$props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("btnClasses" in $$props)
      $$invalidate(5, btnClasses = $$new_props.btnClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, caret, split, nav*/
    271364) {
      $:
        $$invalidate(4, classes = classnames(className, {
          "dropdown-toggle": caret || split,
          "dropdown-toggle-split": split,
          "nav-link": nav
        }));
    }
    if ($$self.$$.dirty & /*classes, outline, color, size, block, active*/
    219152) {
      $:
        $$invalidate(5, btnClasses = classnames(classes, "btn", `btn${outline ? "-outline" : ""}-${color}`, size ? `btn-${size}` : false, block ? "d-block w-100" : false, { active }));
    }
  };
  return [
    inner,
    ariaLabel,
    nav,
    tag,
    classes,
    btnClasses,
    $context,
    context,
    toggleButton,
    $$restProps,
    className,
    active,
    block,
    caret,
    color,
    disabled,
    outline,
    size,
    split,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    a_binding,
    div_binding,
    span_binding,
    button_binding
  ];
}
var DropdownToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {
      class: 10,
      ariaLabel: 1,
      active: 11,
      block: 12,
      caret: 13,
      color: 14,
      disabled: 15,
      inner: 0,
      nav: 2,
      outline: 16,
      size: 17,
      split: 18,
      tag: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownToggle",
      options,
      id: create_fragment37.name
    });
  }
  get class() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get block() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caret() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caret(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nav() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nav(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get split() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set split(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownToggle_default = DropdownToggle;

// node_modules/sveltestrap/src/Fade.svelte
var file37 = "node_modules/sveltestrap/src/Fade.svelte";
function create_if_block13(ctx) {
  let div;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[6],
    { class: (
      /*className*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file37, 25, 2, 641);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "introstart",
            /*introstart_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            /*introend_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            /*outrostart_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            /*outroend_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introstart",
            function() {
              if (is_function(
                /*onEntering*/
                ctx[2]
              ))
                ctx[2].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            function() {
              if (is_function(
                /*onEntered*/
                ctx[3]
              ))
                ctx[3].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            function() {
              if (is_function(
                /*onExiting*/
                ctx[4]
              ))
                ctx[4].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            function() {
              if (is_function(
                /*onExited*/
                ctx[5]
              ))
                ctx[5].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx[6],
        (!current || dirty & /*className*/
        2) && { class: (
          /*className*/
          ctx[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(25:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block13(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  const omit_props_names = ["isOpen", "class", "onEntering", "onEntered", "onExiting", "onExited", "toggler"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fade", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { isOpen = false } = $$props;
  let { class: className = "" } = $$props;
  let { onEntering = () => dispatch("opening") } = $$props;
  let { onEntered = () => dispatch("open") } = $$props;
  let { onExiting = () => dispatch("closing") } = $$props;
  let { onExited = () => dispatch("close") } = $$props;
  let { toggler = null } = $$props;
  onMount(() => toggle_default(toggler, (e) => {
    $$invalidate(0, isOpen = !isOpen);
    e.preventDefault();
  }));
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("onEntering" in $$new_props)
      $$invalidate(2, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$new_props)
      $$invalidate(3, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$new_props)
      $$invalidate(4, onExiting = $$new_props.onExiting);
    if ("onExited" in $$new_props)
      $$invalidate(5, onExited = $$new_props.onExited);
    if ("toggler" in $$new_props)
      $$invalidate(7, toggler = $$new_props.toggler);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    fade,
    toggle: toggle_default,
    dispatch,
    isOpen,
    className,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    toggler
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("onEntering" in $$props)
      $$invalidate(2, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$props)
      $$invalidate(3, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$props)
      $$invalidate(4, onExiting = $$new_props.onExiting);
    if ("onExited" in $$props)
      $$invalidate(5, onExited = $$new_props.onExited);
    if ("toggler" in $$props)
      $$invalidate(7, toggler = $$new_props.toggler);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    className,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    $$restProps,
    toggler,
    $$scope,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler
  ];
}
var Fade = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      isOpen: 0,
      class: 1,
      onEntering: 2,
      onEntered: 3,
      onExiting: 4,
      onExited: 5,
      toggler: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fade",
      options,
      id: create_fragment38.name
    });
  }
  get isOpen() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntering() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntering(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntered() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntered(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExiting() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExiting(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExited() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExited(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggler() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggler(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Fade_default = Fade;

// node_modules/sveltestrap/src/Figure.svelte
var file38 = "node_modules/sveltestrap/src/Figure.svelte";
var get_caption_slot_changes = (dirty) => ({});
var get_caption_slot_context = (ctx) => ({});
function create_if_block14(ctx) {
  let figcaption;
  let t;
  let current;
  const caption_slot_template = (
    /*#slots*/
    ctx[7].caption
  );
  const caption_slot = create_slot(
    caption_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_caption_slot_context
  );
  const block = {
    c: function create() {
      figcaption = element("figcaption");
      t = text(
        /*caption*/
        ctx[1]
      );
      if (caption_slot)
        caption_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      figcaption = claim_element(nodes, "FIGCAPTION", { class: true });
      var figcaption_nodes = children(figcaption);
      t = claim_text(
        figcaption_nodes,
        /*caption*/
        ctx[1]
      );
      if (caption_slot)
        caption_slot.l(figcaption_nodes);
      figcaption_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figcaption, "class", "figure-caption");
      add_location(figcaption, file38, 19, 4, 435);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figcaption, anchor);
      append_hydration_dev(figcaption, t);
      if (caption_slot) {
        caption_slot.m(figcaption, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*caption*/
      2)
        set_data_dev(
          t,
          /*caption*/
          ctx2[1]
        );
      if (caption_slot) {
        if (caption_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            caption_slot,
            caption_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              caption_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_caption_slot_changes
            ),
            get_caption_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(caption_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(caption_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figcaption);
      if (caption_slot)
        caption_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(19:2) {#if caption || $$slots.caption}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let img;
  let t0;
  let figure;
  let t1;
  let current;
  let img_levels = [
    { alt: (
      /*alt*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let if_block = (
    /*caption*/
    (ctx[1] || /*$$slots*/
    ctx[4].caption) && create_if_block14(ctx)
  );
  let figure_levels = [
    { class: (
      /*classes*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let figure_data = {};
  for (let i = 0; i < figure_levels.length; i += 1) {
    figure_data = assign(figure_data, figure_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      t0 = space();
      figure = element("figure");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { alt: true, class: true });
      t0 = claim_space(nodes);
      figure = claim_element(nodes, "FIGURE", { class: true });
      var figure_nodes = children(figure);
      if (default_slot)
        default_slot.l(figure_nodes);
      t1 = claim_space(figure_nodes);
      if (if_block)
        if_block.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file38, 14, 0, 295);
      set_attributes(figure, figure_data);
      add_location(figure, file38, 16, 0, 343);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, figure, anchor);
      if (default_slot) {
        default_slot.m(figure, null);
      }
      append_hydration_dev(figure, t1);
      if (if_block)
        if_block.m(figure, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        (!current || dirty & /*alt*/
        1) && { alt: (
          /*alt*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*caption*/
        ctx2[1] || /*$$slots*/
        ctx2[4].caption
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*caption, $$slots*/
          18) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(figure, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(figure, figure_data = get_spread_update(figure_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(figure);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "alt", "caption"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Figure", slots, ["default", "caption"]);
  const $$slots = compute_slots(slots);
  setContext("figure", true);
  let { class: className = "" } = $$props;
  let { alt = void 0 } = $$props;
  let { caption = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("alt" in $$new_props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("caption" in $$new_props)
      $$invalidate(1, caption = $$new_props.caption);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    classnames,
    className,
    alt,
    caption,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("alt" in $$props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("caption" in $$props)
      $$invalidate(1, caption = $$new_props.caption);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    32) {
      $:
        $$invalidate(2, classes = classnames("figure", className));
    }
  };
  return [alt, caption, classes, $$restProps, $$slots, className, $$scope, slots];
}
var Figure = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, { class: 5, alt: 0, caption: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Figure",
      options,
      id: create_fragment39.name
    });
  }
  get class() {
    throw new Error("<Figure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Figure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Figure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Figure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caption() {
    throw new Error("<Figure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caption(value) {
    throw new Error("<Figure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Figure_default = Figure;

// node_modules/sveltestrap/src/Form.svelte
var file39 = "node_modules/sveltestrap/src/Form.svelte";
function create_fragment40(ctx) {
  let form;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let form_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let form_data = {};
  for (let i = 0; i < form_levels.length; i += 1) {
    form_data = assign(form_data, form_levels[i]);
  }
  const block = {
    c: function create() {
      form = element("form");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { class: true });
      var form_nodes = children(form);
      if (default_slot)
        default_slot.l(form_nodes);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(form, form_data);
      add_location(form, file39, 14, 0, 277);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      if (default_slot) {
        default_slot.m(form, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          form,
          "submit",
          /*submit_handler*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(form, form_data = get_spread_update(form_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "inline", "validated"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Form", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { inline = false } = $$props;
  let { validated = false } = $$props;
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("inline" in $$new_props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("validated" in $$new_props)
      $$invalidate(4, validated = $$new_props.validated);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    inline,
    validated,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("inline" in $$props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("validated" in $$props)
      $$invalidate(4, validated = $$new_props.validated);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, inline, validated*/
    28) {
      $:
        $$invalidate(0, classes = classnames(className, {
          "form-inline": inline,
          "was-validated": validated
        }));
    }
  };
  return [
    classes,
    $$restProps,
    className,
    inline,
    validated,
    $$scope,
    slots,
    submit_handler
  ];
}
var Form = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, { class: 2, inline: 3, validated: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Form",
      options,
      id: create_fragment40.name
    });
  }
  get class() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validated() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validated(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Form_default = Form;

// node_modules/sveltestrap/src/FormCheck.svelte
var file40 = "node_modules/sveltestrap/src/FormCheck.svelte";
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_else_block11(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[11],
    { class: (
      /*inputClasses*/
      ctx[9]
    ) },
    { id: (
      /*idFor*/
      ctx[8]
    ) },
    { type: "checkbox" },
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    { name: (
      /*name*/
      ctx[5]
    ) },
    { __value: (
      /*value*/
      ctx[7]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        id: true,
        type: true,
        name: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file40, 68, 4, 1451);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[0];
      ctx[39](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_2*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_2*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_2*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_2*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*input_change_handler_2*/
            ctx[38]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11],
        dirty[0] & /*inputClasses*/
        512 && { class: (
          /*inputClasses*/
          ctx2[9]
        ) },
        dirty[0] & /*idFor*/
        256 && { id: (
          /*idFor*/
          ctx2[8]
        ) },
        { type: "checkbox" },
        dirty[0] & /*disabled*/
        8 && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        dirty[0] & /*name*/
        32 && { name: (
          /*name*/
          ctx2[5]
        ) },
        dirty[0] & /*value*/
        128 && { __value: (
          /*value*/
          ctx2[7]
        ) }
      ]));
      if (dirty[0] & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[39](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(68:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[11],
    { class: (
      /*inputClasses*/
      ctx[9]
    ) },
    { id: (
      /*idFor*/
      ctx[8]
    ) },
    { type: "checkbox" },
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    { name: (
      /*name*/
      ctx[5]
    ) },
    { __value: (
      /*value*/
      ctx[7]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        id: true,
        type: true,
        name: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file40, 52, 4, 1187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[0];
      ctx[37](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_1*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_1*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_1*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[36]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11],
        dirty[0] & /*inputClasses*/
        512 && { class: (
          /*inputClasses*/
          ctx2[9]
        ) },
        dirty[0] & /*idFor*/
        256 && { id: (
          /*idFor*/
          ctx2[8]
        ) },
        { type: "checkbox" },
        dirty[0] & /*disabled*/
        8 && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        dirty[0] & /*name*/
        32 && { name: (
          /*name*/
          ctx2[5]
        ) },
        dirty[0] & /*value*/
        128 && { __value: (
          /*value*/
          ctx2[7]
        ) }
      ]));
      if (dirty[0] & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[37](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(52:30) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let input;
  let binding_group;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[11],
    { class: (
      /*inputClasses*/
      ctx[9]
    ) },
    { id: (
      /*idFor*/
      ctx[8]
    ) },
    { type: "radio" },
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    { name: (
      /*name*/
      ctx[5]
    ) },
    { __value: (
      /*value*/
      ctx[7]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[34][0]
  );
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        id: true,
        type: true,
        name: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file40, 36, 4, 907);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = input.__value === /*group*/
      ctx[1];
      ctx[35](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[33]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11],
        dirty[0] & /*inputClasses*/
        512 && { class: (
          /*inputClasses*/
          ctx2[9]
        ) },
        dirty[0] & /*idFor*/
        256 && { id: (
          /*idFor*/
          ctx2[8]
        ) },
        { type: "radio" },
        dirty[0] & /*disabled*/
        8 && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        dirty[0] & /*name*/
        32 && { name: (
          /*name*/
          ctx2[5]
        ) },
        dirty[0] & /*value*/
        128 && { __value: (
          /*value*/
          ctx2[7]
        ) }
      ]));
      if (dirty[0] & /*group*/
      2) {
        input.checked = input.__value === /*group*/
        ctx2[1];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[35](null);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(36:2) {#if type === 'radio'}",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let label_1;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[20].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_label_slot_context
  );
  const label_slot_or_fallback = label_slot || fallback_block3(ctx);
  const block = {
    c: function create() {
      label_1 = element("label");
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_1_nodes = children(label_1);
      if (label_slot_or_fallback)
        label_slot_or_fallback.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "class", "form-check-label");
      attr_dev(
        label_1,
        "for",
        /*idFor*/
        ctx[8]
      );
      add_location(label_1, file40, 85, 4, 1727);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[0] & /*$$scope*/
        524288)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_label_slot_changes
            ),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & /*label*/
        16)) {
          label_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*idFor*/
      256) {
        attr_dev(
          label_1,
          "for",
          /*idFor*/
          ctx2[8]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(85:2) {#if label}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*label*/
      16)
        set_data_dev(
          t,
          /*label*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(87:25) {label}",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let div;
  let t;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[6] === "radio"
    )
      return create_if_block_18;
    if (
      /*type*/
      ctx2[6] === "switch"
    )
      return create_if_block_27;
    return create_else_block11;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*label*/
    ctx[4] && create_if_block15(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[10]
      );
      add_location(div, file40, 34, 0, 856);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_block0.m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div, t);
        }
      }
      if (
        /*label*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*label*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block15(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classes*/
      1024) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[10]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let classes;
  let inputClasses;
  let idFor;
  const omit_props_names = [
    "class",
    "checked",
    "disabled",
    "group",
    "id",
    "inline",
    "inner",
    "invalid",
    "label",
    "name",
    "reverse",
    "size",
    "type",
    "valid",
    "value"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormCheck", slots, ["label"]);
  let { class: className = "" } = $$props;
  let { checked = false } = $$props;
  let { disabled = false } = $$props;
  let { group = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { inline = false } = $$props;
  let { inner = void 0 } = $$props;
  let { invalid = false } = $$props;
  let { label = "" } = $$props;
  let { name = "" } = $$props;
  let { reverse = false } = $$props;
  let { size = "" } = $$props;
  let { type = "checkbox" } = $$props;
  let { valid = false } = $$props;
  let { value = void 0 } = $$props;
  const $$binding_groups = [[]];
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(1, group);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(2, inner);
    });
  }
  function input_change_handler_1() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(2, inner);
    });
  }
  function input_change_handler_2() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  function input_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(2, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("group" in $$new_props)
      $$invalidate(1, group = $$new_props.group);
    if ("id" in $$new_props)
      $$invalidate(13, id = $$new_props.id);
    if ("inline" in $$new_props)
      $$invalidate(14, inline = $$new_props.inline);
    if ("inner" in $$new_props)
      $$invalidate(2, inner = $$new_props.inner);
    if ("invalid" in $$new_props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("label" in $$new_props)
      $$invalidate(4, label = $$new_props.label);
    if ("name" in $$new_props)
      $$invalidate(5, name = $$new_props.name);
    if ("reverse" in $$new_props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$new_props)
      $$invalidate(17, size = $$new_props.size);
    if ("type" in $$new_props)
      $$invalidate(6, type = $$new_props.type);
    if ("valid" in $$new_props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$new_props)
      $$invalidate(7, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    checked,
    disabled,
    group,
    id,
    inline,
    inner,
    invalid,
    label,
    name,
    reverse,
    size,
    type,
    valid,
    value,
    idFor,
    inputClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("group" in $$props)
      $$invalidate(1, group = $$new_props.group);
    if ("id" in $$props)
      $$invalidate(13, id = $$new_props.id);
    if ("inline" in $$props)
      $$invalidate(14, inline = $$new_props.inline);
    if ("inner" in $$props)
      $$invalidate(2, inner = $$new_props.inner);
    if ("invalid" in $$props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("label" in $$props)
      $$invalidate(4, label = $$new_props.label);
    if ("name" in $$props)
      $$invalidate(5, name = $$new_props.name);
    if ("reverse" in $$props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$props)
      $$invalidate(17, size = $$new_props.size);
    if ("type" in $$props)
      $$invalidate(6, type = $$new_props.type);
    if ("valid" in $$props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$props)
      $$invalidate(7, value = $$new_props.value);
    if ("idFor" in $$props)
      $$invalidate(8, idFor = $$new_props.idFor);
    if ("inputClasses" in $$props)
      $$invalidate(9, inputClasses = $$new_props.inputClasses);
    if ("classes" in $$props)
      $$invalidate(10, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*className, reverse, type, inline, size*/
    217152) {
      $:
        $$invalidate(10, classes = classnames(className, "form-check", {
          "form-check-reverse": reverse,
          "form-switch": type === "switch",
          "form-check-inline": inline,
          [`form-control-${size}`]: size
        }));
    }
    if ($$self.$$.dirty[0] & /*invalid, valid*/
    294912) {
      $:
        $$invalidate(9, inputClasses = classnames("form-check-input", { "is-invalid": invalid, "is-valid": valid }));
    }
    if ($$self.$$.dirty[0] & /*id, label*/
    8208) {
      $:
        $$invalidate(8, idFor = id || label);
    }
  };
  return [
    checked,
    group,
    inner,
    disabled,
    label,
    name,
    type,
    value,
    idFor,
    inputClasses,
    classes,
    $$restProps,
    className,
    id,
    inline,
    invalid,
    reverse,
    size,
    valid,
    $$scope,
    slots,
    blur_handler,
    change_handler,
    focus_handler,
    input_handler,
    blur_handler_1,
    change_handler_1,
    focus_handler_1,
    input_handler_1,
    blur_handler_2,
    change_handler_2,
    focus_handler_2,
    input_handler_2,
    input_change_handler,
    $$binding_groups,
    input_binding,
    input_change_handler_1,
    input_binding_1,
    input_change_handler_2,
    input_binding_2
  ];
}
var FormCheck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance41,
      create_fragment41,
      safe_not_equal,
      {
        class: 12,
        checked: 0,
        disabled: 3,
        group: 1,
        id: 13,
        inline: 14,
        inner: 2,
        invalid: 15,
        label: 4,
        name: 5,
        reverse: 16,
        size: 17,
        type: 6,
        valid: 18,
        value: 7
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormCheck",
      options,
      id: create_fragment41.name
    });
  }
  get class() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reverse() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverse(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormCheck_default = FormCheck;

// node_modules/sveltestrap/src/FormFeedback.svelte
var file41 = "node_modules/sveltestrap/src/FormFeedback.svelte";
function create_fragment42(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file41, 19, 0, 368);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "valid", "tooltip"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormFeedback", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { valid = void 0 } = $$props;
  let { tooltip = false } = $$props;
  let classes;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("valid" in $$new_props)
      $$invalidate(3, valid = $$new_props.valid);
    if ("tooltip" in $$new_props)
      $$invalidate(4, tooltip = $$new_props.tooltip);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    valid,
    tooltip,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("valid" in $$props)
      $$invalidate(3, valid = $$new_props.valid);
    if ("tooltip" in $$props)
      $$invalidate(4, tooltip = $$new_props.tooltip);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tooltip, className, valid*/
    28) {
      $: {
        const validMode = tooltip ? "tooltip" : "feedback";
        $$invalidate(0, classes = classnames(className, valid ? `valid-${validMode}` : `invalid-${validMode}`));
      }
    }
  };
  return [classes, $$restProps, className, valid, tooltip, $$scope, slots];
}
var FormFeedback = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, { class: 2, valid: 3, tooltip: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormFeedback",
      options,
      id: create_fragment42.name
    });
  }
  get class() {
    throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormFeedback_default = FormFeedback;

// node_modules/sveltestrap/src/FormGroup.svelte
var file42 = "node_modules/sveltestrap/src/FormGroup.svelte";
var get_label_slot_changes_1 = (dirty) => ({});
var get_label_slot_context_1 = (ctx) => ({});
var get_label_slot_changes2 = (dirty) => ({});
var get_label_slot_context2 = (ctx) => ({});
function create_else_block12(ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let if_block = (
    /*label*/
    (ctx[0] || /*$$slots*/
    ctx[4].label) && create_if_block_28(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file42, 34, 2, 796);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*label*/
        ctx2[0] || /*$$slots*/
        ctx2[4].label
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*label, $$slots*/
          17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(34:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block16(ctx) {
  let fieldset;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let if_block = (
    /*label*/
    (ctx[0] || /*$$slots*/
    ctx[4].label) && create_if_block_19(ctx)
  );
  let fieldset_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let fieldset_data = {};
  for (let i = 0; i < fieldset_levels.length; i += 1) {
    fieldset_data = assign(fieldset_data, fieldset_levels[i]);
  }
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      fieldset = claim_element(nodes, "FIELDSET", { class: true });
      var fieldset_nodes = children(fieldset);
      if (default_slot)
        default_slot.l(fieldset_nodes);
      t = claim_space(fieldset_nodes);
      if (if_block)
        if_block.l(fieldset_nodes);
      fieldset_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(fieldset, fieldset_data);
      add_location(fieldset, file42, 23, 2, 534);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, fieldset, anchor);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      append_hydration_dev(fieldset, t);
      if (if_block)
        if_block.m(fieldset, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*label*/
        ctx2[0] || /*$$slots*/
        ctx2[4].label
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*label, $$slots*/
          17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(fieldset, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(fieldset);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(23:0) {#if tag === 'fieldset'}",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let label_1;
  let t0;
  let t1;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[12].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_label_slot_context_1
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      if (label_slot)
        label_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", {});
      var label_1_nodes = children(label_1);
      t0 = claim_text(
        label_1_nodes,
        /*label*/
        ctx[0]
      );
      t1 = claim_space(label_1_nodes);
      if (label_slot)
        label_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(label_1, file42, 38, 6, 950);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, t0);
      append_hydration_dev(label_1, t1);
      if (label_slot) {
        label_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*label*/
      1)
        set_data_dev(
          t0,
          /*label*/
          ctx2[0]
        );
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_label_slot_changes_1
            ),
            get_label_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(37:4) {#if label || $$slots.label}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let label_1;
  let t0;
  let t1;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[12].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_label_slot_context2
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      if (label_slot)
        label_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", {});
      var label_1_nodes = children(label_1);
      t0 = claim_text(
        label_1_nodes,
        /*label*/
        ctx[0]
      );
      t1 = claim_space(label_1_nodes);
      if (label_slot)
        label_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(label_1, file42, 27, 6, 693);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, t0);
      append_hydration_dev(label_1, t1);
      if (label_slot) {
        label_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*label*/
      1)
        set_data_dev(
          t0,
          /*label*/
          ctx2[0]
        );
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_label_slot_changes2
            ),
            get_label_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(26:4) {#if label || $$slots.label}",
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block16, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[1] === "fieldset"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "check", "disabled", "floating", "inline", "label", "row", "tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormGroup", slots, ["default", "label"]);
  const $$slots = compute_slots(slots);
  let { class: className = "" } = $$props;
  let { check = false } = $$props;
  let { disabled = false } = $$props;
  let { floating = false } = $$props;
  let { inline = false } = $$props;
  let { label = "" } = $$props;
  let { row = false } = $$props;
  let { tag = null } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("check" in $$new_props)
      $$invalidate(6, check = $$new_props.check);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("floating" in $$new_props)
      $$invalidate(8, floating = $$new_props.floating);
    if ("inline" in $$new_props)
      $$invalidate(9, inline = $$new_props.inline);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("row" in $$new_props)
      $$invalidate(10, row = $$new_props.row);
    if ("tag" in $$new_props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    check,
    disabled,
    floating,
    inline,
    label,
    row,
    tag,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("check" in $$props)
      $$invalidate(6, check = $$new_props.check);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("floating" in $$props)
      $$invalidate(8, floating = $$new_props.floating);
    if ("inline" in $$props)
      $$invalidate(9, inline = $$new_props.inline);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("row" in $$props)
      $$invalidate(10, row = $$new_props.row);
    if ("tag" in $$props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, row, check, inline, floating, disabled*/
    2016) {
      $:
        $$invalidate(2, classes = classnames(className, "mb-3", {
          row,
          "form-check": check,
          "form-check-inline": check && inline,
          "form-floating": floating,
          disabled: check && disabled
        }));
    }
  };
  return [
    label,
    tag,
    classes,
    $$restProps,
    $$slots,
    className,
    check,
    disabled,
    floating,
    inline,
    row,
    $$scope,
    slots
  ];
}
var FormGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {
      class: 5,
      check: 6,
      disabled: 7,
      floating: 8,
      inline: 9,
      label: 0,
      row: 10,
      tag: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormGroup",
      options,
      id: create_fragment43.name
    });
  }
  get class() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get check() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set check(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floating() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floating(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get row() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set row(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormGroup_default = FormGroup;

// node_modules/sveltestrap/src/FormText.svelte
var file43 = "node_modules/sveltestrap/src/FormText.svelte";
function create_fragment44(ctx) {
  let small;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let small_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let small_data = {};
  for (let i = 0; i < small_levels.length; i += 1) {
    small_data = assign(small_data, small_levels[i]);
  }
  const block = {
    c: function create() {
      small = element("small");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      small = claim_element(nodes, "SMALL", { class: true });
      var small_nodes = children(small);
      if (default_slot)
        default_slot.l(small_nodes);
      small_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(small, small_data);
      add_location(small, file43, 15, 0, 292);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, small, anchor);
      if (default_slot) {
        default_slot.m(small, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(small, small_data = get_spread_update(small_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(small);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "inline", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormText", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { inline = false } = $$props;
  let { color = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("inline" in $$new_props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    inline,
    color,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("inline" in $$props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, inline, color*/
    28) {
      $:
        $$invalidate(0, classes = classnames(className, !inline ? "form-text" : false, color ? `text-${color}` : false));
    }
  };
  return [classes, $$restProps, className, inline, color, $$scope, slots];
}
var FormText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { class: 2, inline: 3, color: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormText",
      options,
      id: create_fragment44.name
    });
  }
  get class() {
    throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormText_default = FormText;

// node_modules/sveltestrap/src/Icon.svelte
var file44 = "node_modules/sveltestrap/src/Icon.svelte";
function create_fragment45(ctx) {
  let i;
  let i_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(i, i_data);
      add_location(i, file44, 10, 0, 189);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(i, i_data = get_spread_update(i_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        dirty & /*classes*/
        1 && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, []);
  let { class: className = "" } = $$props;
  let { name = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("name" in $$new_props)
      $$invalidate(3, name = $$new_props.name);
  };
  $$self.$capture_state = () => ({ classnames, className, name, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("name" in $$props)
      $$invalidate(3, name = $$new_props.name);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, name*/
    12) {
      $:
        $$invalidate(0, classes = classnames(className, `bi-${name}`));
    }
  };
  return [classes, $$restProps, className, name];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, { class: 2, name: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment45.name
    });
  }
  get class() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;

// node_modules/sveltestrap/src/Image.svelte
var file45 = "node_modules/sveltestrap/src/Image.svelte";
function create_fragment46(ctx) {
  let img;
  let img_levels = [
    { alt: (
      /*alt*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { alt: true, class: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file45, 18, 0, 412);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*alt*/
        1 && { alt: (
          /*alt*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        dirty & /*classes*/
        2 && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "alt", "figure", "fluid", "thumbnail"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { class: className = "" } = $$props;
  let { alt = void 0 } = $$props;
  let { figure = getContext("figure") } = $$props;
  let { fluid = false } = $$props;
  let { thumbnail = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("alt" in $$new_props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("figure" in $$new_props)
      $$invalidate(4, figure = $$new_props.figure);
    if ("fluid" in $$new_props)
      $$invalidate(5, fluid = $$new_props.fluid);
    if ("thumbnail" in $$new_props)
      $$invalidate(6, thumbnail = $$new_props.thumbnail);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    className,
    alt,
    figure,
    fluid,
    thumbnail,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("alt" in $$props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("figure" in $$props)
      $$invalidate(4, figure = $$new_props.figure);
    if ("fluid" in $$props)
      $$invalidate(5, fluid = $$new_props.fluid);
    if ("thumbnail" in $$props)
      $$invalidate(6, thumbnail = $$new_props.thumbnail);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, figure, fluid, thumbnail*/
    120) {
      $:
        $$invalidate(1, classes = classnames(className, {
          "figure-img": figure,
          "img-fluid": fluid,
          "img-thumbnail": thumbnail
        }));
    }
  };
  return [alt, classes, $$restProps, className, figure, fluid, thumbnail];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      class: 3,
      alt: 0,
      figure: 4,
      fluid: 5,
      thumbnail: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment46.name
    });
  }
  get class() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get figure() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set figure(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fluid() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fluid(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thumbnail() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thumbnail(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/sveltestrap/src/InlineContainer.svelte
var file46 = "node_modules/sveltestrap/src/InlineContainer.svelte";
function create_fragment47(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file46, 4, 0, 68);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineContainer", slots, ["default"]);
  let x = "wtf svelte?";
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InlineContainer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ x });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      x = $$props2.x;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [$$scope, slots];
}
var InlineContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineContainer",
      options,
      id: create_fragment47.name
    });
  }
};
var InlineContainer_default = InlineContainer;

// node_modules/sveltestrap/src/Input.svelte
var file47 = "node_modules/sveltestrap/src/Input.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[211] = list[i];
  return child_ctx;
}
function create_if_block_222(ctx) {
  let select;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[210],
    null
  );
  let select_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { readonly: (
      /*readonly*/
      ctx[15]
    ) }
  ];
  let select_data = {};
  for (let i = 0; i < select_levels.length; i += 1) {
    select_data = assign(select_data, select_levels[i]);
  }
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      select = claim_element(nodes, "SELECT", { class: true, name: true, readonly: true });
      var select_nodes = children(select);
      if (default_slot)
        default_slot.l(select_nodes);
      select_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(select, select_data);
      if (
        /*value*/
        ctx[6] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[208].call(select)
        ));
      add_location(select, file47, 492, 2, 9236);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      "value" in select_data && (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus)
        select.focus();
      select_option(
        select,
        /*value*/
        ctx[6],
        true
      );
      ctx[209](select);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "blur",
            /*blur_handler_20*/
            ctx[157],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*change_handler_19*/
            ctx[158],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "focus",
            /*focus_handler_20*/
            ctx[159],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*input_handler_19*/
            ctx[160],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[208]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[6] & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[210],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[210]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[210],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        (!current || dirty[0] & /*classes*/
        524288) && { class: (
          /*classes*/
          ctx2[19]
        ) },
        (!current || dirty[0] & /*name*/
        8192) && { name: (
          /*name*/
          ctx2[13]
        ) },
        (!current || dirty[0] & /*disabled*/
        256) && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*readonly*/
        32768) && { readonly: (
          /*readonly*/
          ctx2[15]
        ) }
      ]));
      if (dirty[0] & /*$$restProps, classes, name, disabled, readonly*/
      4759808 && "value" in select_data)
        (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (dirty[0] & /*value*/
      64) {
        select_option(
          select,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      if (default_slot)
        default_slot.d(detaching);
      ctx[209](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_222.name,
    type: "if",
    source: "(492:40) ",
    ctx
  });
  return block;
}
function create_if_block_21(ctx) {
  let textarea;
  let mounted;
  let dispose;
  let textarea_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) }
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  const block = {
    c: function create() {
      textarea = element("textarea");
      this.h();
    },
    l: function claim(nodes) {
      textarea = claim_element(nodes, "TEXTAREA", {
        class: true,
        name: true,
        placeholder: true
      });
      children(textarea).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(textarea, textarea_data);
      add_location(textarea, file47, 474, 2, 8945);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      set_input_value(
        textarea,
        /*value*/
        ctx[6]
      );
      ctx[207](textarea);
      if (!mounted) {
        dispose = [
          listen_dev(
            textarea,
            "blur",
            /*blur_handler_19*/
            ctx[150],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "change",
            /*change_handler_18*/
            ctx[151],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "focus",
            /*focus_handler_19*/
            ctx[152],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "input",
            /*input_handler_18*/
            ctx[153],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "keydown",
            /*keydown_handler_19*/
            ctx[154],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "keypress",
            /*keypress_handler_19*/
            ctx[155],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "keyup",
            /*keyup_handler_19*/
            ctx[156],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[206]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      ctx[207](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_21.name,
    type: "if",
    source: "(474:29) ",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_33,
    create_if_block_42,
    create_if_block_5,
    create_if_block_6,
    create_if_block_7,
    create_if_block_8,
    create_if_block_9,
    create_if_block_10,
    create_if_block_11,
    create_if_block_122,
    create_if_block_132,
    create_if_block_142,
    create_if_block_152,
    create_if_block_162,
    create_if_block_172,
    create_if_block_182,
    create_if_block_192,
    create_if_block_20,
    create_else_block_13
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[17] === "text"
    )
      return 0;
    if (
      /*type*/
      ctx2[17] === "password"
    )
      return 1;
    if (
      /*type*/
      ctx2[17] === "color"
    )
      return 2;
    if (
      /*type*/
      ctx2[17] === "email"
    )
      return 3;
    if (
      /*type*/
      ctx2[17] === "file"
    )
      return 4;
    if (
      /*type*/
      ctx2[17] === "checkbox" || /*type*/
      ctx2[17] === "radio" || /*type*/
      ctx2[17] === "switch"
    )
      return 5;
    if (
      /*type*/
      ctx2[17] === "url"
    )
      return 6;
    if (
      /*type*/
      ctx2[17] === "number"
    )
      return 7;
    if (
      /*type*/
      ctx2[17] === "date"
    )
      return 8;
    if (
      /*type*/
      ctx2[17] === "time"
    )
      return 9;
    if (
      /*type*/
      ctx2[17] === "datetime"
    )
      return 10;
    if (
      /*type*/
      ctx2[17] === "datetime-local"
    )
      return 11;
    if (
      /*type*/
      ctx2[17] === "month"
    )
      return 12;
    if (
      /*type*/
      ctx2[17] === "color"
    )
      return 13;
    if (
      /*type*/
      ctx2[17] === "range"
    )
      return 14;
    if (
      /*type*/
      ctx2[17] === "search"
    )
      return 15;
    if (
      /*type*/
      ctx2[17] === "tel"
    )
      return 16;
    if (
      /*type*/
      ctx2[17] === "week"
    )
      return 17;
    return 18;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(94:0) {#if tag === 'input'}",
    ctx
  });
  return block;
}
function create_else_block_13(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { type: (
      /*type*/
      ctx[17]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { value: (
      /*value*/
      ctx[6]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        class: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 455, 4, 8614);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_18*/
            ctx[145],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*handleInput*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_18*/
            ctx[146],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*handleInput*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_18*/
            ctx[147],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_18*/
            ctx[148],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_18*/
            ctx[149],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*type*/
        131072 && { type: (
          /*type*/
          ctx2[17]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*value*/
        64 && input.value !== /*value*/
        ctx2[6] && { value: (
          /*value*/
          ctx2[6]
        ) }
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(455:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_20(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "week" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 436, 4, 8305);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[205](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_17*/
            ctx[138],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_17*/
            ctx[139],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_17*/
            ctx[140],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_17*/
            ctx[141],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_17*/
            ctx[142],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_17*/
            ctx[143],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_17*/
            ctx[144],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_14*/
            ctx[204]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "week" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[205](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_20.name,
    type: "if",
    source: "(436:28) ",
    ctx
  });
  return block;
}
function create_if_block_192(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "tel" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true,
        size: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 416, 4, 7965);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[203](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_16*/
            ctx[131],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_16*/
            ctx[132],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_16*/
            ctx[133],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_16*/
            ctx[134],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_16*/
            ctx[135],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_16*/
            ctx[136],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_16*/
            ctx[137],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_13*/
            ctx[202]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "tel" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[203](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_192.name,
    type: "if",
    source: "(416:27) ",
    ctx
  });
  return block;
}
function create_if_block_182(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "search" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true,
        size: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 396, 4, 7623);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[201](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_15*/
            ctx[124],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_15*/
            ctx[125],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_15*/
            ctx[126],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_15*/
            ctx[127],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_15*/
            ctx[128],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_15*/
            ctx[129],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_15*/
            ctx[130],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_12*/
            ctx[200]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "search" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64 && input.value !== /*value*/
      ctx2[6]) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[201](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_182.name,
    type: "if",
    source: "(396:30) ",
    ctx
  });
  return block;
}
function create_if_block_172(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { type: "range" },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        class: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 377, 4, 7292);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[199](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_14*/
            ctx[117],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_14*/
            ctx[118],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_14*/
            ctx[119],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_14*/
            ctx[120],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_14*/
            ctx[121],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_14*/
            ctx[122],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_14*/
            ctx[123],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[198]
          ),
          listen_dev(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[198]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        { type: "range" },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[199](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_172.name,
    type: "if",
    source: "(377:29) ",
    ctx
  });
  return block;
}
function create_if_block_162(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { type: "color" },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        class: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 358, 4, 6962);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[197](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_13*/
            ctx[110],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_13*/
            ctx[111],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_13*/
            ctx[112],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_13*/
            ctx[113],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_13*/
            ctx[114],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_13*/
            ctx[115],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_13*/
            ctx[116],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_11*/
            ctx[196]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        { type: "color" },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[197](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_162.name,
    type: "if",
    source: "(358:29) ",
    ctx
  });
  return block;
}
function create_if_block_152(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "month" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 339, 4, 6632);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[195](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_12*/
            ctx[103],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_12*/
            ctx[104],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_12*/
            ctx[105],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_12*/
            ctx[106],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_12*/
            ctx[107],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_12*/
            ctx[108],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_12*/
            ctx[109],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_10*/
            ctx[194]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "month" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[195](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(339:29) ",
    ctx
  });
  return block;
}
function create_if_block_142(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "datetime-local" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 320, 4, 6293);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[193](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_11*/
            ctx[96],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_11*/
            ctx[97],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_11*/
            ctx[98],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_11*/
            ctx[99],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_11*/
            ctx[100],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_11*/
            ctx[101],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_11*/
            ctx[102],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_9*/
            ctx[192]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "datetime-local" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[193](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(320:38) ",
    ctx
  });
  return block;
}
function create_if_block_132(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { type: "datetime" },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        class: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 301, 4, 5951);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[191](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_10*/
            ctx[89],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_10*/
            ctx[90],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_10*/
            ctx[91],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_10*/
            ctx[92],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_10*/
            ctx[93],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_10*/
            ctx[94],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_10*/
            ctx[95],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_8*/
            ctx[190]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        { type: "datetime" },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[191](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(301:32) ",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "time" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 282, 4, 5619);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[189](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_9*/
            ctx[82],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_9*/
            ctx[83],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_9*/
            ctx[84],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_9*/
            ctx[85],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_9*/
            ctx[86],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_9*/
            ctx[87],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_9*/
            ctx[88],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_7*/
            ctx[188]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "time" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[189](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(282:28) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "date" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 263, 4, 5291);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[187](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_8*/
            ctx[75],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_8*/
            ctx[76],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_8*/
            ctx[77],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_8*/
            ctx[78],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_8*/
            ctx[79],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_8*/
            ctx[80],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_8*/
            ctx[81],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_6*/
            ctx[186]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "date" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[187](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(263:28) ",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "number" },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 244, 4, 4961);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[185](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_7*/
            ctx[68],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_7*/
            ctx[69],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_7*/
            ctx[70],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_7*/
            ctx[71],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_7*/
            ctx[72],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_7*/
            ctx[73],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_7*/
            ctx[74],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_5*/
            ctx[184]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "number" },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64 && to_number(input.value) !== /*value*/
      ctx2[6]) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[185](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(244:30) ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "url" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true,
        size: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 224, 4, 4619);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[183](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_6*/
            ctx[61],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_6*/
            ctx[62],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_6*/
            ctx[63],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_6*/
            ctx[64],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_6*/
            ctx[65],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_6*/
            ctx[66],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_6*/
            ctx[67],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_4*/
            ctx[182]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "url" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64 && input.value !== /*value*/
      ctx2[6]) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[183](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(224:27) ",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let formcheck;
  let updating_checked;
  let updating_inner;
  let updating_group;
  let updating_value;
  let current;
  const formcheck_spread_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*className*/
      ctx[7]
    ) },
    { size: (
      /*bsSize*/
      ctx[0]
    ) },
    { type: (
      /*type*/
      ctx[17]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { invalid: (
      /*invalid*/
      ctx[10]
    ) },
    { label: (
      /*label*/
      ctx[11]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { reverse: (
      /*reverse*/
      ctx[16]
    ) },
    { readonly: (
      /*readonly*/
      ctx[15]
    ) },
    { valid: (
      /*valid*/
      ctx[18]
    ) }
  ];
  function formcheck_checked_binding(value) {
    ctx[171](value);
  }
  function formcheck_inner_binding(value) {
    ctx[172](value);
  }
  function formcheck_group_binding(value) {
    ctx[173](value);
  }
  function formcheck_value_binding(value) {
    ctx[174](value);
  }
  let formcheck_props = {};
  for (let i = 0; i < formcheck_spread_levels.length; i += 1) {
    formcheck_props = assign(formcheck_props, formcheck_spread_levels[i]);
  }
  if (
    /*checked*/
    ctx[2] !== void 0
  ) {
    formcheck_props.checked = /*checked*/
    ctx[2];
  }
  if (
    /*inner*/
    ctx[5] !== void 0
  ) {
    formcheck_props.inner = /*inner*/
    ctx[5];
  }
  if (
    /*group*/
    ctx[4] !== void 0
  ) {
    formcheck_props.group = /*group*/
    ctx[4];
  }
  if (
    /*value*/
    ctx[6] !== void 0
  ) {
    formcheck_props.value = /*value*/
    ctx[6];
  }
  formcheck = new FormCheck_default({ props: formcheck_props, $$inline: true });
  binding_callbacks.push(() => bind(formcheck, "checked", formcheck_checked_binding));
  binding_callbacks.push(() => bind(formcheck, "inner", formcheck_inner_binding));
  binding_callbacks.push(() => bind(formcheck, "group", formcheck_group_binding));
  binding_callbacks.push(() => bind(formcheck, "value", formcheck_value_binding));
  formcheck.$on(
    "blur",
    /*blur_handler_5*/
    ctx[175]
  );
  formcheck.$on(
    "change",
    /*change_handler_5*/
    ctx[176]
  );
  formcheck.$on(
    "focus",
    /*focus_handler_5*/
    ctx[177]
  );
  formcheck.$on(
    "input",
    /*input_handler_5*/
    ctx[178]
  );
  formcheck.$on(
    "keydown",
    /*keydown_handler_5*/
    ctx[179]
  );
  formcheck.$on(
    "keypress",
    /*keypress_handler_5*/
    ctx[180]
  );
  formcheck.$on(
    "keyup",
    /*keyup_handler_5*/
    ctx[181]
  );
  const block = {
    c: function create() {
      create_component(formcheck.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(formcheck.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(formcheck, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const formcheck_changes = dirty[0] & /*$$restProps, className, bsSize, type, disabled, invalid, label, name, placeholder, reverse, readonly, valid*/
      4713857 ? get_spread_update(formcheck_spread_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && get_spread_object(
          /*$$restProps*/
          ctx2[22]
        ),
        dirty[0] & /*className*/
        128 && { class: (
          /*className*/
          ctx2[7]
        ) },
        dirty[0] & /*bsSize*/
        1 && { size: (
          /*bsSize*/
          ctx2[0]
        ) },
        dirty[0] & /*type*/
        131072 && { type: (
          /*type*/
          ctx2[17]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*invalid*/
        1024 && { invalid: (
          /*invalid*/
          ctx2[10]
        ) },
        dirty[0] & /*label*/
        2048 && { label: (
          /*label*/
          ctx2[11]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*reverse*/
        65536 && { reverse: (
          /*reverse*/
          ctx2[16]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readonly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*valid*/
        262144 && { valid: (
          /*valid*/
          ctx2[18]
        ) }
      ]) : {};
      if (!updating_checked && dirty[0] & /*checked*/
      4) {
        updating_checked = true;
        formcheck_changes.checked = /*checked*/
        ctx2[2];
        add_flush_callback(() => updating_checked = false);
      }
      if (!updating_inner && dirty[0] & /*inner*/
      32) {
        updating_inner = true;
        formcheck_changes.inner = /*inner*/
        ctx2[5];
        add_flush_callback(() => updating_inner = false);
      }
      if (!updating_group && dirty[0] & /*group*/
      16) {
        updating_group = true;
        formcheck_changes.group = /*group*/
        ctx2[4];
        add_flush_callback(() => updating_group = false);
      }
      if (!updating_value && dirty[0] & /*value*/
      64) {
        updating_value = true;
        formcheck_changes.value = /*value*/
        ctx2[6];
        add_flush_callback(() => updating_value = false);
      }
      formcheck.$set(formcheck_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(formcheck.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(formcheck.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(formcheck, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(198:73) ",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "file" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { invalid: (
      /*invalid*/
      ctx[10]
    ) },
    { multiple: (
      /*multiple*/
      ctx[12]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { valid: (
      /*valid*/
      ctx[18]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        invalid: true,
        name: true,
        placeholder: true,
        valid: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 175, 4, 3745);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[170](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_4*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_4*/
            ctx[55],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_4*/
            ctx[56],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_4*/
            ctx[57],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_4*/
            ctx[58],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_4*/
            ctx[59],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_4*/
            ctx[60],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[169]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "file" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*invalid*/
        1024 && { invalid: (
          /*invalid*/
          ctx2[10]
        ) },
        dirty[0] & /*multiple*/
        4096 && { multiple: (
          /*multiple*/
          ctx2[12]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*valid*/
        262144 && { valid: (
          /*valid*/
          ctx2[18]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[170](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(175:28) ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "email" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { multiple: (
      /*multiple*/
      ctx[12]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true,
        size: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 154, 4, 3386);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[168](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_3*/
            ctx[47],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_3*/
            ctx[48],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_3*/
            ctx[49],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_3*/
            ctx[50],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_3*/
            ctx[51],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_3*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_3*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_3*/
            ctx[167]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "email" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*multiple*/
        4096 && { multiple: (
          /*multiple*/
          ctx2[12]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64 && input.value !== /*value*/
      ctx2[6]) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[168](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(154:29) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "color" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 135, 4, 3056);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[166](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_2*/
            ctx[40],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_2*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_2*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_2*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_2*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_2*/
            ctx[45],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_2*/
            ctx[46],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_2*/
            ctx[165]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "color" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[166](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(135:29) ",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "password" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true,
        size: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 115, 4, 2710);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[164](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_1*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_1*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_1*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_1*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_1*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_1*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler_1*/
            ctx[163]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "password" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64 && input.value !== /*value*/
      ctx2[6]) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[164](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(115:32) ",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[22],
    { class: (
      /*classes*/
      ctx[19]
    ) },
    { type: "text" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[14]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[15]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        placeholder: true,
        size: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file47, 95, 4, 2365);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[162](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[161]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        4194304 && /*$$restProps*/
        ctx2[22],
        dirty[0] & /*classes*/
        524288 && { class: (
          /*classes*/
          ctx2[19]
        ) },
        { type: "text" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        8192 && { name: (
          /*name*/
          ctx2[13]
        ) },
        dirty[0] & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx2[14]
        ) },
        dirty[0] & /*readonly*/
        32768 && { readOnly: (
          /*readonly*/
          ctx2[15]
        ) },
        dirty[0] & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64 && input.value !== /*value*/
      ctx2[6]) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[162](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(95:2) {#if type === 'text'}",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_110, create_else_block13];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (dirty[0] & /*feedback*/
    512)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(
        /*feedback*/
        ctx2[9]
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(525:0) {#if feedback}",
    ctx
  });
  return block;
}
function create_else_block13(ctx) {
  let formfeedback;
  let current;
  formfeedback = new FormFeedback_default({
    props: {
      valid: (
        /*valid*/
        ctx[18]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(formfeedback.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(formfeedback.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(formfeedback, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const formfeedback_changes = {};
      if (dirty[0] & /*valid*/
      262144)
        formfeedback_changes.valid = /*valid*/
        ctx2[18];
      if (dirty[0] & /*feedback*/
      512 | dirty[6] & /*$$scope*/
      16777216) {
        formfeedback_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formfeedback.$set(formfeedback_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(formfeedback.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(formfeedback.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(formfeedback, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(530:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*feedback*/
    ctx[9]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*valid, feedback*/
      262656) {
        each_value = /*feedback*/
        ctx2[9];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(526:2) {#if Array.isArray(feedback)}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*feedback*/
        ctx[9]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*feedback*/
        ctx[9]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*feedback*/
      512)
        set_data_dev(
          t,
          /*feedback*/
          ctx2[9]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(531:4) <FormFeedback {valid}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let t_value = (
    /*msg*/
    ctx[211] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*feedback*/
      512 && t_value !== (t_value = /*msg*/
      ctx2[211] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(528:6) <FormFeedback {valid}>",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let formfeedback;
  let current;
  formfeedback = new FormFeedback_default({
    props: {
      valid: (
        /*valid*/
        ctx[18]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(formfeedback.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(formfeedback.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(formfeedback, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const formfeedback_changes = {};
      if (dirty[0] & /*valid*/
      262144)
        formfeedback_changes.valid = /*valid*/
        ctx2[18];
      if (dirty[0] & /*feedback*/
      512 | dirty[6] & /*$$scope*/
      16777216) {
        formfeedback_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formfeedback.$set(formfeedback_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(formfeedback.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(formfeedback.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(formfeedback, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(527:4) {#each feedback as msg}",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_29, create_if_block_21, create_if_block_222];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[20] === "input"
    )
      return 0;
    if (
      /*tag*/
      ctx2[20] === "textarea"
    )
      return 1;
    if (
      /*tag*/
      ctx2[20] === "select" && !/*multiple*/
      ctx2[12]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1, -1, -1]))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*feedback*/
    ctx[9] && create_if_block17(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*feedback*/
        ctx2[9]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*feedback*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block17(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "class",
    "bsSize",
    "checked",
    "color",
    "disabled",
    "feedback",
    "files",
    "group",
    "inner",
    "invalid",
    "label",
    "multiple",
    "name",
    "placeholder",
    "plaintext",
    "readonly",
    "reverse",
    "size",
    "type",
    "valid",
    "value"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { bsSize = void 0 } = $$props;
  let { checked = false } = $$props;
  let { color = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { feedback = void 0 } = $$props;
  let { files = void 0 } = $$props;
  let { group = void 0 } = $$props;
  let { inner = void 0 } = $$props;
  let { invalid = false } = $$props;
  let { label = void 0 } = $$props;
  let { multiple = void 0 } = $$props;
  let { name = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { plaintext = false } = $$props;
  let { readonly = void 0 } = $$props;
  let { reverse = false } = $$props;
  let { size = void 0 } = $$props;
  let { type = "text" } = $$props;
  let { valid = false } = $$props;
  let { value = "" } = $$props;
  let classes;
  let tag;
  const handleInput = (event) => {
    $$invalidate(6, value = event.target.value);
  };
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_20(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_20(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_1() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_2() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_3() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_3($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_change_handler() {
    files = this.files;
    value = this.value;
    $$invalidate(3, files);
    $$invalidate(6, value);
  }
  function input_binding_4($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function formcheck_checked_binding(value2) {
    checked = value2;
    $$invalidate(2, checked);
  }
  function formcheck_inner_binding(value2) {
    inner = value2;
    $$invalidate(5, inner);
  }
  function formcheck_group_binding(value2) {
    group = value2;
    $$invalidate(4, group);
  }
  function formcheck_value_binding(value$1) {
    value = value$1;
    $$invalidate(6, value);
  }
  function blur_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler_4() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_5($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_5() {
    value = to_number(this.value);
    $$invalidate(6, value);
  }
  function input_binding_6($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_6() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_7($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_7() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_8($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_8() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_9($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_9() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_10($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_10() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_11($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_11() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_12($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(6, value);
  }
  function input_binding_13($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_12() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_14($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_13() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_15($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_14() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_16($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(6, value);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(6, value);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("bsSize" in $$new_props)
      $$invalidate(0, bsSize = $$new_props.bsSize);
    if ("checked" in $$new_props)
      $$invalidate(2, checked = $$new_props.checked);
    if ("color" in $$new_props)
      $$invalidate(23, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("feedback" in $$new_props)
      $$invalidate(9, feedback = $$new_props.feedback);
    if ("files" in $$new_props)
      $$invalidate(3, files = $$new_props.files);
    if ("group" in $$new_props)
      $$invalidate(4, group = $$new_props.group);
    if ("inner" in $$new_props)
      $$invalidate(5, inner = $$new_props.inner);
    if ("invalid" in $$new_props)
      $$invalidate(10, invalid = $$new_props.invalid);
    if ("label" in $$new_props)
      $$invalidate(11, label = $$new_props.label);
    if ("multiple" in $$new_props)
      $$invalidate(12, multiple = $$new_props.multiple);
    if ("name" in $$new_props)
      $$invalidate(13, name = $$new_props.name);
    if ("placeholder" in $$new_props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("plaintext" in $$new_props)
      $$invalidate(24, plaintext = $$new_props.plaintext);
    if ("readonly" in $$new_props)
      $$invalidate(15, readonly = $$new_props.readonly);
    if ("reverse" in $$new_props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("type" in $$new_props)
      $$invalidate(17, type = $$new_props.type);
    if ("valid" in $$new_props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$new_props)
      $$invalidate(6, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(210, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    FormCheck: FormCheck_default,
    FormFeedback: FormFeedback_default,
    classnames,
    className,
    bsSize,
    checked,
    color,
    disabled,
    feedback,
    files,
    group,
    inner,
    invalid,
    label,
    multiple,
    name,
    placeholder,
    plaintext,
    readonly,
    reverse,
    size,
    type,
    valid,
    value,
    classes,
    tag,
    handleInput
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("bsSize" in $$props)
      $$invalidate(0, bsSize = $$new_props.bsSize);
    if ("checked" in $$props)
      $$invalidate(2, checked = $$new_props.checked);
    if ("color" in $$props)
      $$invalidate(23, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("feedback" in $$props)
      $$invalidate(9, feedback = $$new_props.feedback);
    if ("files" in $$props)
      $$invalidate(3, files = $$new_props.files);
    if ("group" in $$props)
      $$invalidate(4, group = $$new_props.group);
    if ("inner" in $$props)
      $$invalidate(5, inner = $$new_props.inner);
    if ("invalid" in $$props)
      $$invalidate(10, invalid = $$new_props.invalid);
    if ("label" in $$props)
      $$invalidate(11, label = $$new_props.label);
    if ("multiple" in $$props)
      $$invalidate(12, multiple = $$new_props.multiple);
    if ("name" in $$props)
      $$invalidate(13, name = $$new_props.name);
    if ("placeholder" in $$props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("plaintext" in $$props)
      $$invalidate(24, plaintext = $$new_props.plaintext);
    if ("readonly" in $$props)
      $$invalidate(15, readonly = $$new_props.readonly);
    if ("reverse" in $$props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("type" in $$props)
      $$invalidate(17, type = $$new_props.type);
    if ("valid" in $$props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$props)
      $$invalidate(6, value = $$new_props.value);
    if ("classes" in $$props)
      $$invalidate(19, classes = $$new_props.classes);
    if ("tag" in $$props)
      $$invalidate(20, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*type, color, plaintext, size, className, invalid, valid, bsSize*/
    25560195) {
      $: {
        const isNotaNumber = new RegExp("\\D", "g");
        let isBtn = false;
        let formControlClass = "form-control";
        $$invalidate(20, tag = "input");
        switch (type) {
          case "color":
            formControlClass = `form-control form-control-color`;
            break;
          case "range":
            formControlClass = "form-range";
            break;
          case "select":
            formControlClass = `form-select`;
            $$invalidate(20, tag = "select");
            break;
          case "textarea":
            $$invalidate(20, tag = "textarea");
            break;
          case "button":
          case "reset":
          case "submit":
            formControlClass = `btn btn-${color || "secondary"}`;
            isBtn = true;
            break;
          case "hidden":
          case "image":
            formControlClass = void 0;
            break;
          default:
            formControlClass = "form-control";
            $$invalidate(20, tag = "input");
        }
        if (plaintext) {
          formControlClass = `${formControlClass}-plaintext`;
          $$invalidate(20, tag = "input");
        }
        if (size && isNotaNumber.test(size)) {
          console.warn(`Please use the prop "bsSize" instead of the "size" to bootstrap's input sizing.`);
          $$invalidate(0, bsSize = size);
          $$invalidate(1, size = void 0);
        }
        $$invalidate(19, classes = classnames(className, formControlClass, {
          "is-invalid": invalid,
          "is-valid": valid,
          [`form-control-${bsSize}`]: bsSize && !isBtn,
          [`btn-${bsSize}`]: bsSize && isBtn
        }));
      }
    }
  };
  return [
    bsSize,
    size,
    checked,
    files,
    group,
    inner,
    value,
    className,
    disabled,
    feedback,
    invalid,
    label,
    multiple,
    name,
    placeholder,
    readonly,
    reverse,
    type,
    valid,
    classes,
    tag,
    handleInput,
    $$restProps,
    color,
    plaintext,
    slots,
    blur_handler,
    change_handler,
    focus_handler,
    input_handler,
    keydown_handler,
    keypress_handler,
    keyup_handler,
    blur_handler_1,
    change_handler_1,
    focus_handler_1,
    input_handler_1,
    keydown_handler_1,
    keypress_handler_1,
    keyup_handler_1,
    blur_handler_2,
    change_handler_2,
    focus_handler_2,
    input_handler_2,
    keydown_handler_2,
    keypress_handler_2,
    keyup_handler_2,
    blur_handler_3,
    change_handler_3,
    focus_handler_3,
    input_handler_3,
    keydown_handler_3,
    keypress_handler_3,
    keyup_handler_3,
    blur_handler_4,
    change_handler_4,
    focus_handler_4,
    input_handler_4,
    keydown_handler_4,
    keypress_handler_4,
    keyup_handler_4,
    blur_handler_6,
    change_handler_6,
    focus_handler_6,
    input_handler_6,
    keydown_handler_6,
    keypress_handler_6,
    keyup_handler_6,
    blur_handler_7,
    change_handler_7,
    focus_handler_7,
    input_handler_7,
    keydown_handler_7,
    keypress_handler_7,
    keyup_handler_7,
    blur_handler_8,
    change_handler_8,
    focus_handler_8,
    input_handler_8,
    keydown_handler_8,
    keypress_handler_8,
    keyup_handler_8,
    blur_handler_9,
    change_handler_9,
    focus_handler_9,
    input_handler_9,
    keydown_handler_9,
    keypress_handler_9,
    keyup_handler_9,
    blur_handler_10,
    change_handler_10,
    focus_handler_10,
    input_handler_10,
    keydown_handler_10,
    keypress_handler_10,
    keyup_handler_10,
    blur_handler_11,
    change_handler_11,
    focus_handler_11,
    input_handler_11,
    keydown_handler_11,
    keypress_handler_11,
    keyup_handler_11,
    blur_handler_12,
    change_handler_12,
    focus_handler_12,
    input_handler_12,
    keydown_handler_12,
    keypress_handler_12,
    keyup_handler_12,
    blur_handler_13,
    change_handler_13,
    focus_handler_13,
    input_handler_13,
    keydown_handler_13,
    keypress_handler_13,
    keyup_handler_13,
    blur_handler_14,
    change_handler_14,
    focus_handler_14,
    input_handler_14,
    keydown_handler_14,
    keypress_handler_14,
    keyup_handler_14,
    blur_handler_15,
    change_handler_15,
    focus_handler_15,
    input_handler_15,
    keydown_handler_15,
    keypress_handler_15,
    keyup_handler_15,
    blur_handler_16,
    change_handler_16,
    focus_handler_16,
    input_handler_16,
    keydown_handler_16,
    keypress_handler_16,
    keyup_handler_16,
    blur_handler_17,
    change_handler_17,
    focus_handler_17,
    input_handler_17,
    keydown_handler_17,
    keypress_handler_17,
    keyup_handler_17,
    blur_handler_18,
    focus_handler_18,
    keydown_handler_18,
    keypress_handler_18,
    keyup_handler_18,
    blur_handler_19,
    change_handler_18,
    focus_handler_19,
    input_handler_18,
    keydown_handler_19,
    keypress_handler_19,
    keyup_handler_19,
    blur_handler_20,
    change_handler_19,
    focus_handler_20,
    input_handler_19,
    input_input_handler,
    input_binding,
    input_input_handler_1,
    input_binding_1,
    input_input_handler_2,
    input_binding_2,
    input_input_handler_3,
    input_binding_3,
    input_change_handler,
    input_binding_4,
    formcheck_checked_binding,
    formcheck_inner_binding,
    formcheck_group_binding,
    formcheck_value_binding,
    blur_handler_5,
    change_handler_5,
    focus_handler_5,
    input_handler_5,
    keydown_handler_5,
    keypress_handler_5,
    keyup_handler_5,
    input_input_handler_4,
    input_binding_5,
    input_input_handler_5,
    input_binding_6,
    input_input_handler_6,
    input_binding_7,
    input_input_handler_7,
    input_binding_8,
    input_input_handler_8,
    input_binding_9,
    input_input_handler_9,
    input_binding_10,
    input_input_handler_10,
    input_binding_11,
    input_input_handler_11,
    input_binding_12,
    input_change_input_handler,
    input_binding_13,
    input_input_handler_12,
    input_binding_14,
    input_input_handler_13,
    input_binding_15,
    input_input_handler_14,
    input_binding_16,
    textarea_input_handler,
    textarea_binding,
    select_change_handler,
    select_binding,
    $$scope
  ];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance48,
      create_fragment48,
      safe_not_equal,
      {
        class: 7,
        bsSize: 0,
        checked: 2,
        color: 23,
        disabled: 8,
        feedback: 9,
        files: 3,
        group: 4,
        inner: 5,
        invalid: 10,
        label: 11,
        multiple: 12,
        name: 13,
        placeholder: 14,
        plaintext: 24,
        readonly: 15,
        reverse: 16,
        size: 1,
        type: 17,
        valid: 18,
        value: 6
      },
      null,
      [-1, -1, -1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment48.name
    });
  }
  get class() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bsSize() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bsSize(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get feedback() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedback(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plaintext() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plaintext(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reverse() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverse(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/sveltestrap/src/InputGroup.svelte
var file48 = "node_modules/sveltestrap/src/InputGroup.svelte";
function create_fragment49(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file48, 14, 0, 243);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { size = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, size, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(3, size = $$new_props.size);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, size*/
    12) {
      $:
        $$invalidate(0, classes = classnames(className, "input-group", size ? `input-group-${size}` : null));
    }
  };
  return [classes, $$restProps, className, size, $$scope, slots];
}
var InputGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, { class: 2, size: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputGroup",
      options,
      id: create_fragment49.name
    });
  }
  get class() {
    throw new Error("<InputGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InputGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<InputGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InputGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputGroup_default = InputGroup;

// node_modules/sveltestrap/src/InputGroupText.svelte
var file49 = "node_modules/sveltestrap/src/InputGroupText.svelte";
function create_fragment50(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let span_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file49, 9, 0, 171);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputGroupText", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "input-group-text"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var InputGroupText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputGroupText",
      options,
      id: create_fragment50.name
    });
  }
  get class() {
    throw new Error("<InputGroupText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InputGroupText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputGroupText_default = InputGroupText;

// node_modules/sveltestrap/src/Jumbotron.svelte
var file50 = "node_modules/sveltestrap/src/Jumbotron.svelte";
function create_fragment51(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[0]
      );
      add_location(div, file50, 9, 0, 182);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      1) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Jumbotron", slots, ["default"]);
  let { class: className = "" } = $$props;
  const writable_props = ["class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Jumbotron> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(1, className = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(1, className = $$props2.className);
    if ("classes" in $$props2)
      $$invalidate(0, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    2) {
      $:
        $$invalidate(0, classes = classnames(className, "p-5 mb-4 bg-light rounded-3"));
    }
  };
  return [classes, className, $$scope, slots];
}
var Jumbotron = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, { class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Jumbotron",
      options,
      id: create_fragment51.name
    });
  }
  get class() {
    throw new Error("<Jumbotron>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Jumbotron>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Jumbotron_default = Jumbotron;

// node_modules/sveltestrap/src/Label.svelte
var file51 = "node_modules/sveltestrap/src/Label.svelte";
function create_fragment52(ctx) {
  let label;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let label_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { for: (
      /*fore*/
      ctx[0]
    ) }
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      add_location(label, file51, 71, 0, 1672);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*fore*/
        1) && { for: (
          /*fore*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "hidden", "check", "size", "for", "xs", "sm", "md", "lg", "xl", "xxl", "widths"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { hidden = false } = $$props;
  let { check = false } = $$props;
  let { size = "" } = $$props;
  let { for: fore = null } = $$props;
  let { xs = "" } = $$props;
  let { sm = "" } = $$props;
  let { md = "" } = $$props;
  let { lg = "" } = $$props;
  let { xl = "" } = $$props;
  let { xxl = "" } = $$props;
  const colWidths = { xs, sm, md, lg, xl, xxl };
  let { widths = Object.keys(colWidths) } = $$props;
  const colClasses = [];
  widths.forEach((colWidth) => {
    let columnProp = $$props[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    const isXs = colWidth === "xs";
    let colClass;
    if (isObject(columnProp)) {
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      colClasses.push(classnames({
        [colClass]: columnProp.size || columnProp.size === "",
        [`order${colSizeInterfix}${columnProp.order}`]: columnProp.order || columnProp.order === 0,
        [`offset${colSizeInterfix}${columnProp.offset}`]: columnProp.offset || columnProp.offset === 0
      }));
    } else {
      colClass = getColumnSizeClass(isXs, colWidth, columnProp);
      colClasses.push(colClass);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("hidden" in $$new_props)
      $$invalidate(4, hidden = $$new_props.hidden);
    if ("check" in $$new_props)
      $$invalidate(5, check = $$new_props.check);
    if ("size" in $$new_props)
      $$invalidate(6, size = $$new_props.size);
    if ("for" in $$new_props)
      $$invalidate(0, fore = $$new_props.for);
    if ("xs" in $$new_props)
      $$invalidate(7, xs = $$new_props.xs);
    if ("sm" in $$new_props)
      $$invalidate(8, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(9, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(10, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(11, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(12, xxl = $$new_props.xxl);
    if ("widths" in $$new_props)
      $$invalidate(13, widths = $$new_props.widths);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    getColumnSizeClass,
    isObject,
    className,
    hidden,
    check,
    size,
    fore,
    xs,
    sm,
    md,
    lg,
    xl,
    xxl,
    colWidths,
    widths,
    colClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("hidden" in $$props)
      $$invalidate(4, hidden = $$new_props.hidden);
    if ("check" in $$props)
      $$invalidate(5, check = $$new_props.check);
    if ("size" in $$props)
      $$invalidate(6, size = $$new_props.size);
    if ("fore" in $$props)
      $$invalidate(0, fore = $$new_props.fore);
    if ("xs" in $$props)
      $$invalidate(7, xs = $$new_props.xs);
    if ("sm" in $$props)
      $$invalidate(8, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(9, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(10, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(11, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(12, xxl = $$new_props.xxl);
    if ("widths" in $$props)
      $$invalidate(13, widths = $$new_props.widths);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, hidden, check, size*/
    120) {
      $:
        $$invalidate(1, classes = classnames(className, hidden ? "visually-hidden" : false, check ? "form-check-label" : false, size ? `col-form-label-${size}` : false, colClasses, colClasses.length ? "col-form-label" : "form-label"));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    fore,
    classes,
    $$restProps,
    className,
    hidden,
    check,
    size,
    xs,
    sm,
    md,
    lg,
    xl,
    xxl,
    widths,
    $$scope,
    slots
  ];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, {
      class: 3,
      hidden: 4,
      check: 5,
      size: 6,
      for: 0,
      xs: 7,
      sm: 8,
      md: 9,
      lg: 10,
      xl: 11,
      xxl: 12,
      widths: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment52.name
    });
  }
  get class() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get check() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set check(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get for() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set for(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xs() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xs(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get widths() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set widths(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/sveltestrap/src/ListGroup.svelte
var file52 = "node_modules/sveltestrap/src/ListGroup.svelte";
function create_else_block14(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let ul_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      add_location(ul, file52, 21, 2, 458);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block18(ctx) {
  let ol;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let ol_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let ol_data = {};
  for (let i = 0; i < ol_levels.length; i += 1) {
    ol_data = assign(ol_data, ol_levels[i]);
  }
  const block = {
    c: function create() {
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ol = claim_element(nodes, "OL", { class: true });
      var ol_nodes = children(ol);
      if (default_slot)
        default_slot.l(ol_nodes);
      ol_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ol, ol_data);
      add_location(ol, file52, 17, 2, 389);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ol, ol_data = get_spread_update(ol_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ol);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(17:0) {#if numbered}",
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block18, create_else_block14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*numbered*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "flush", "horizontal", "numbered"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { flush = false } = $$props;
  let { horizontal = false } = $$props;
  let { numbered = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("flush" in $$new_props)
      $$invalidate(4, flush = $$new_props.flush);
    if ("horizontal" in $$new_props)
      $$invalidate(5, horizontal = $$new_props.horizontal);
    if ("numbered" in $$new_props)
      $$invalidate(0, numbered = $$new_props.numbered);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    flush,
    horizontal,
    numbered,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("flush" in $$props)
      $$invalidate(4, flush = $$new_props.flush);
    if ("horizontal" in $$props)
      $$invalidate(5, horizontal = $$new_props.horizontal);
    if ("numbered" in $$props)
      $$invalidate(0, numbered = $$new_props.numbered);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, flush, horizontal, numbered*/
    57) {
      $:
        $$invalidate(1, classes = classnames(className, "list-group", {
          "list-group-flush": flush,
          "list-group-horizontal": horizontal,
          "list-group-numbered": numbered
        }));
    }
  };
  return [numbered, classes, $$restProps, className, flush, horizontal, $$scope, slots];
}
var ListGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, {
      class: 3,
      flush: 4,
      horizontal: 5,
      numbered: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListGroup",
      options,
      id: create_fragment53.name
    });
  }
  get class() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flush() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flush(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get numbered() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set numbered(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListGroup_default = ListGroup;

// node_modules/sveltestrap/src/ListGroupItem.svelte
var file53 = "node_modules/sveltestrap/src/ListGroupItem.svelte";
function create_else_block15(ctx) {
  let li;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    { active: (
      /*active*/
      ctx[0]
    ) }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        disabled: true,
        active: true
      });
      var li_nodes = children(li);
      if (default_slot)
        default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      add_location(li, file53, 38, 2, 877);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          li,
          "click",
          /*click_handler_2*/
          ctx[13],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*active*/
        1) && { active: (
          /*active*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(36:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let button_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { type: "button" },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    { active: (
      /*active*/
      ctx[0]
    ) }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, type: true, active: true });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file53, 25, 2, 602);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[12],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        { type: "button" },
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*active*/
        1) && { active: (
          /*active*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(25:27) ",
    ctx
  });
  return block;
}
function create_if_block19(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { href: (
      /*href*/
      ctx[2]
    ) },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    { active: (
      /*active*/
      ctx[0]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        class: true,
        href: true,
        disabled: true,
        active: true
      });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file53, 21, 2, 479);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[11],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*active*/
        1) && { active: (
          /*active*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(21:0) {#if href}",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block19, create_if_block_111, create_else_block15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[2]
    )
      return 0;
    if (
      /*tag*/
      ctx2[3] === "button"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled", "color", "action", "href", "tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListGroupItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { color = "" } = $$props;
  let { action = false } = $$props;
  let { href = null } = $$props;
  let { tag = null } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("color" in $$new_props)
      $$invalidate(7, color = $$new_props.color);
    if ("action" in $$new_props)
      $$invalidate(8, action = $$new_props.action);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("tag" in $$new_props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    disabled,
    color,
    action,
    href,
    tag,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("color" in $$props)
      $$invalidate(7, color = $$new_props.color);
    if ("action" in $$props)
      $$invalidate(8, action = $$new_props.action);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("tag" in $$props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, active, disabled, action, tag, color*/
    459) {
      $:
        $$invalidate(4, classes = classnames(className, "list-group-item", {
          active,
          disabled,
          "list-group-item-action": action || tag === "button",
          [`list-group-item-${color}`]: color
        }));
    }
  };
  return [
    active,
    disabled,
    href,
    tag,
    classes,
    $$restProps,
    className,
    color,
    action,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var ListGroupItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, {
      class: 6,
      active: 0,
      disabled: 1,
      color: 7,
      action: 8,
      href: 2,
      tag: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListGroupItem",
      options,
      id: create_fragment54.name
    });
  }
  get class() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set action(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListGroupItem_default = ListGroupItem;

// node_modules/sveltestrap/src/ModalBackdrop.svelte
var file54 = "node_modules/sveltestrap/src/ModalBackdrop.svelte";
function create_if_block20(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    { role: "presentation" },
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true, class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(
        div,
        "fade",
        /*fade*/
        ctx[1]
      );
      add_location(div, file54, 20, 2, 464);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[6],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "presentation" },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
      toggle_class(
        div,
        "fade",
        /*fade*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, backdropIn, {});
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(div, backdropOut, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(20:0) {#if isOpen && loaded}",
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && /*loaded*/
    ctx[2] && create_if_block20(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0] && /*loaded*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen, loaded*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "isOpen", "fade"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalBackdrop", slots, []);
  let { class: className = "" } = $$props;
  let { isOpen = false } = $$props;
  let { fade: fade2 = true } = $$props;
  let loaded = false;
  onMount(() => {
    $$invalidate(2, loaded = true);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$new_props)
      $$invalidate(1, fade2 = $$new_props.fade);
  };
  $$self.$capture_state = () => ({
    onMount,
    classnames,
    backdropIn,
    backdropOut,
    className,
    isOpen,
    fade: fade2,
    loaded,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$props)
      $$invalidate(1, fade2 = $$new_props.fade);
    if ("loaded" in $$props)
      $$invalidate(2, loaded = $$new_props.loaded);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    32) {
      $:
        $$invalidate(3, classes = classnames(className, "modal-backdrop"));
    }
  };
  return [isOpen, fade2, loaded, classes, $$restProps, className, click_handler];
}
var ModalBackdrop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, { class: 5, isOpen: 0, fade: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalBackdrop",
      options,
      id: create_fragment55.name
    });
  }
  get class() {
    throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalBackdrop_default = ModalBackdrop;

// node_modules/sveltestrap/src/ModalBody.svelte
var file55 = "node_modules/sveltestrap/src/ModalBody.svelte";
function create_fragment56(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file55, 9, 0, 165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "modal-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ModalBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalBody",
      options,
      id: create_fragment56.name
    });
  }
  get class() {
    throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalBody_default = ModalBody;

// node_modules/sveltestrap/src/ModalHeader.svelte
var file56 = "node_modules/sveltestrap/src/ModalHeader.svelte";
var get_close_slot_changes = (dirty) => ({});
var get_close_slot_context = (ctx) => ({});
function create_else_block16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(18:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      4)
        set_data_dev(
          t,
          /*children*/
          ctx2[2]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(16:4) {#if children}",
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        "aria-label": true
      });
      children(button).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "btn-close");
      attr_dev(
        button,
        "aria-label",
        /*closeAriaLabel*/
        ctx[1]
      );
      add_location(button, file56, 23, 6, 522);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*toggle*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*closeAriaLabel*/
      2) {
        attr_dev(
          button,
          "aria-label",
          /*closeAriaLabel*/
          ctx[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(23:4) {#if typeof toggle === 'function'}",
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let if_block_anchor;
  let if_block = typeof /*toggle*/
  ctx[0] === "function" && create_if_block21(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (typeof /*toggle*/
      ctx2[0] === "function") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(22:21)      ",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let div;
  let h5;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_112, create_else_block16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const close_slot_template = (
    /*#slots*/
    ctx[8].close
  );
  const close_slot = create_slot(
    close_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_close_slot_context
  );
  const close_slot_or_fallback = close_slot || fallback_block4(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      h5 = element("h5");
      if_block.c();
      t = space();
      if (close_slot_or_fallback)
        close_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      h5 = claim_element(div_nodes, "H5", { class: true, id: true });
      var h5_nodes = children(h5);
      if_block.l(h5_nodes);
      h5_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      if (close_slot_or_fallback)
        close_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h5, "class", "modal-title");
      attr_dev(
        h5,
        "id",
        /*id*/
        ctx[3]
      );
      add_location(h5, file56, 14, 2, 344);
      set_attributes(div, div_data);
      add_location(div, file56, 13, 0, 303);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h5);
      if_blocks[current_block_type_index].m(h5, null);
      append_hydration_dev(div, t);
      if (close_slot_or_fallback) {
        close_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(h5, null);
      }
      if (!current || dirty & /*id*/
      8) {
        attr_dev(
          h5,
          "id",
          /*id*/
          ctx2[3]
        );
      }
      if (close_slot) {
        if (close_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              close_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_close_slot_changes
            ),
            get_close_slot_context
          );
        }
      } else {
        if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/
        3)) {
          close_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(close_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(close_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (close_slot_or_fallback)
        close_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "toggle", "closeAriaLabel", "children", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalHeader", slots, ["default", "close"]);
  let { class: className = "" } = $$props;
  let { toggle = void 0 } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  let { children: children2 = void 0 } = $$props;
  let { id = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("toggle" in $$new_props)
      $$invalidate(0, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("children" in $$new_props)
      $$invalidate(2, children2 = $$new_props.children);
    if ("id" in $$new_props)
      $$invalidate(3, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    toggle,
    closeAriaLabel,
    children: children2,
    id,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("toggle" in $$props)
      $$invalidate(0, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("children" in $$props)
      $$invalidate(2, children2 = $$new_props.children);
    if ("id" in $$props)
      $$invalidate(3, id = $$new_props.id);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    64) {
      $:
        $$invalidate(4, classes = classnames(className, "modal-header"));
    }
  };
  return [
    toggle,
    closeAriaLabel,
    children2,
    id,
    classes,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var ModalHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {
      class: 6,
      toggle: 0,
      closeAriaLabel: 1,
      children: 2,
      id: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalHeader",
      options,
      id: create_fragment57.name
    });
  }
  get class() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalHeader_default = ModalHeader;

// node_modules/sveltestrap/src/Portal.svelte
var file57 = "node_modules/sveltestrap/src/Portal.svelte";
function create_fragment58(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file57, 18, 0, 346);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[4](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[4](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let ref;
  let portal;
  onMount(() => {
    portal = document.createElement("div");
    document.body.appendChild(portal);
    portal.appendChild(ref);
  });
  onDestroy(() => {
    if (typeof document !== "undefined") {
      document.body.removeChild(portal);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ onMount, onDestroy, ref, portal });
  $$self.$inject_state = ($$new_props) => {
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("portal" in $$props)
      portal = $$new_props.portal;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, $$restProps, $$scope, slots, div_binding];
}
var Portal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment58.name
    });
  }
};
var Portal_default = Portal;

// node_modules/sveltestrap/src/Modal.svelte
var file58 = "node_modules/sveltestrap/src/Modal.svelte";
function add_css(target) {
  append_styles(target, "svelte-d87gpn", ".modal-open{overflow:hidden;padding-right:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWlSVSxXQUFhLENBQ25CLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGFBQWEsQ0FBRSxDQUNqQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNb2RhbC5zdmVsdGUiXX0= */");
}
var get_external_slot_changes = (dirty) => ({});
var get_external_slot_context = (ctx) => ({});
function create_if_block_113(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*outer*/
    ctx[13]
  );
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot_13] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & /*wrapClassName, $$restProps, labelledBy, modalClassName, fade, staticModal, classes, _dialog, contentClassName, body, toggle, header, isOpen*/
      2119615 | dirty[1] & /*$$scope*/
      8) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty[0] & /*outer*/
      8192 && switch_value !== (switch_value = /*outer*/
      ctx2[13])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(223:0) {#if _isMounted}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let div2;
  let t0;
  let div1;
  let div0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let div0_class_value;
  let div2_class_value;
  let div2_intro;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  const external_slot_template = (
    /*#slots*/
    ctx[31].external
  );
  const external_slot = create_slot(
    external_slot_template,
    ctx,
    /*$$scope*/
    ctx[34],
    get_external_slot_context
  );
  let if_block0 = (
    /*header*/
    ctx[3] && create_if_block_43(ctx)
  );
  const if_block_creators = [create_if_block_34, create_else_block17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*body*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      if (external_slot)
        external_slot.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        "aria-labelledby": true,
        class: true,
        role: true
      });
      var div2_nodes = children(div2);
      if (external_slot)
        external_slot.l(div2_nodes);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true, role: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = classnames(
        "modal-content",
        /*contentClassName*/
        ctx[9]
      ));
      add_location(div0, file58, 246, 12, 5868);
      attr_dev(
        div1,
        "class",
        /*classes*/
        ctx[14]
      );
      attr_dev(div1, "role", "document");
      add_location(div1, file58, 245, 10, 5798);
      attr_dev(
        div2,
        "aria-labelledby",
        /*labelledBy*/
        ctx[5]
      );
      attr_dev(div2, "class", div2_class_value = classnames(
        "modal",
        /*modalClassName*/
        ctx[8],
        {
          fade: (
            /*fade*/
            ctx[10]
          ),
          "position-static": (
            /*staticModal*/
            ctx[0]
          )
        }
      ));
      attr_dev(div2, "role", "dialog");
      add_location(div2, file58, 228, 8, 5242);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (external_slot) {
        external_slot.m(div2, null);
      }
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t1);
      if_blocks[current_block_type_index].m(div0, null);
      ctx[32](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div2,
            "introstart",
            /*introstart_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "introend",
            /*onModalOpened*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "outrostart",
            /*onModalClosing*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "outroend",
            /*onModalClosed*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "click",
            /*handleBackdropClick*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mousedown",
            /*handleBackdropMouseDown*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (external_slot) {
        if (external_slot.p && (!current || dirty[1] & /*$$scope*/
        8)) {
          update_slot_base(
            external_slot,
            external_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[34],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[34]
            ) : get_slot_changes(
              external_slot_template,
              /*$$scope*/
              ctx2[34],
              dirty,
              get_external_slot_changes
            ),
            get_external_slot_context
          );
        }
      }
      if (
        /*header*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*header*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_43(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }
      if (!current || dirty[0] & /*contentClassName*/
      512 && div0_class_value !== (div0_class_value = classnames(
        "modal-content",
        /*contentClassName*/
        ctx2[9]
      ))) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classes*/
      16384) {
        attr_dev(
          div1,
          "class",
          /*classes*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*labelledBy*/
      32) {
        attr_dev(
          div2,
          "aria-labelledby",
          /*labelledBy*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*modalClassName, fade, staticModal*/
      1281 && div2_class_value !== (div2_class_value = classnames(
        "modal",
        /*modalClassName*/
        ctx2[8],
        {
          fade: (
            /*fade*/
            ctx2[10]
          ),
          "position-static": (
            /*staticModal*/
            ctx2[0]
          )
        }
      ))) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(external_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      add_render_callback(() => {
        if (!current)
          return;
        if (div2_outro)
          div2_outro.end(1);
        div2_intro = create_in_transition(div2, modalIn, {});
        div2_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(external_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      if (div2_intro)
        div2_intro.invalidate();
      div2_outro = create_out_transition(div2, modalOut, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (external_slot)
        external_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      ctx[32](null);
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(227:6) {#if isOpen}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let modalheader;
  let current;
  modalheader = new ModalHeader_default({
    props: {
      toggle: (
        /*toggle*/
        ctx[4]
      ),
      id: (
        /*labelledBy*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalheader.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(modalheader.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(modalheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalheader_changes = {};
      if (dirty[0] & /*toggle*/
      16)
        modalheader_changes.toggle = /*toggle*/
        ctx2[4];
      if (dirty[0] & /*labelledBy*/
      32)
        modalheader_changes.id = /*labelledBy*/
        ctx2[5];
      if (dirty[0] & /*header*/
      8 | dirty[1] & /*$$scope*/
      8) {
        modalheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalheader.$set(modalheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(248:14) {#if header}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*header*/
        ctx[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*header*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*header*/
      8)
        set_data_dev(
          t,
          /*header*/
          ctx2[3]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(249:16) <ModalHeader {toggle} id={labelledBy}>",
    ctx
  });
  return block;
}
function create_else_block17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[31].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[34],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[34],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[34]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[34],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(257:14) {:else}",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let modalbody;
  let current;
  modalbody = new ModalBody_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalbody.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(modalbody.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(modalbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalbody_changes = {};
      if (dirty[1] & /*$$scope*/
      8) {
        modalbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbody.$set(modalbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(253:14) {#if body}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[31].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[34],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[34],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[34]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[34],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(254:16) <ModalBody>",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let div;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[1] && create_if_block_210(ctx)
  );
  let div_levels = [
    { class: (
      /*wrapClassName*/
      ctx[7]
    ) },
    { tabindex: "-1" },
    /*$$restProps*/
    ctx[21]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, tabindex: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file58, 225, 4, 5081);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*isOpen*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*isOpen*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_210(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*wrapClassName*/
        128) && { class: (
          /*wrapClassName*/
          ctx2[7]
        ) },
        { tabindex: "-1" },
        dirty[0] & /*$$restProps*/
        2097152 && /*$$restProps*/
        ctx2[21]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(224:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*outer*/
    ctx[13]
  );
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot4] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & /*fade, isOpen*/
      1026 | dirty[1] & /*$$scope*/
      8) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty[0] & /*outer*/
      8192 && switch_value !== (switch_value = /*outer*/
      ctx2[13])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(267:0) {#if backdrop && !staticModal}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let modalbackdrop;
  let current;
  modalbackdrop = new ModalBackdrop_default({
    props: {
      fade: (
        /*fade*/
        ctx[10]
      ),
      isOpen: (
        /*isOpen*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalbackdrop.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(modalbackdrop.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(modalbackdrop, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalbackdrop_changes = {};
      if (dirty[0] & /*fade*/
      1024)
        modalbackdrop_changes.fade = /*fade*/
        ctx2[10];
      if (dirty[0] & /*isOpen*/
      2)
        modalbackdrop_changes.isOpen = /*isOpen*/
        ctx2[1];
      modalbackdrop.$set(modalbackdrop_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalbackdrop.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalbackdrop.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalbackdrop, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(268:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment59(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*_isMounted*/
    ctx[11] && create_if_block_113(ctx)
  );
  let if_block1 = (
    /*backdrop*/
    ctx[6] && !/*staticModal*/
    ctx[0] && create_if_block22(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*_isMounted*/
        ctx2[11]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*_isMounted*/
          2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_113(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*backdrop*/
        ctx2[6] && !/*staticModal*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*backdrop, staticModal*/
          65) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block22(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var openCount = 0;
var dialogBaseClass = "modal-dialog";
function instance59($$self, $$props, $$invalidate) {
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "static",
    "isOpen",
    "autoFocus",
    "body",
    "centered",
    "container",
    "fullscreen",
    "header",
    "scrollable",
    "size",
    "toggle",
    "labelledBy",
    "backdrop",
    "wrapClassName",
    "modalClassName",
    "contentClassName",
    "fade",
    "unmountOnClose",
    "returnFocusAfterClose"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["external", "default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { static: staticModal = false } = $$props;
  let { isOpen = false } = $$props;
  let { autoFocus = true } = $$props;
  let { body = false } = $$props;
  let { centered = false } = $$props;
  let { container = void 0 } = $$props;
  let { fullscreen = false } = $$props;
  let { header = void 0 } = $$props;
  let { scrollable = false } = $$props;
  let { size = "" } = $$props;
  let { toggle = void 0 } = $$props;
  let { labelledBy = header ? `modal-${uuid()}` : void 0 } = $$props;
  let { backdrop = true } = $$props;
  let { wrapClassName = "" } = $$props;
  let { modalClassName = "" } = $$props;
  let { contentClassName = "" } = $$props;
  let { fade: fade2 = true } = $$props;
  let { unmountOnClose = true } = $$props;
  let { returnFocusAfterClose = true } = $$props;
  let hasOpened = false;
  let _isMounted = false;
  let _triggeringElement;
  let _originalBodyPadding;
  let _lastIsOpen = isOpen;
  let _lastHasOpened = hasOpened;
  let _dialog;
  let _mouseDownElement;
  let _removeEscListener;
  onMount(() => {
    if (isOpen) {
      init2();
      hasOpened = true;
    }
    if (hasOpened && autoFocus) {
      setFocus();
    }
  });
  onDestroy(() => {
    destroy();
    if (hasOpened) {
      close();
    }
  });
  afterUpdate(() => {
    if (isOpen && !_lastIsOpen) {
      init2();
      hasOpened = true;
    }
    if (autoFocus && hasOpened && !_lastHasOpened) {
      setFocus();
    }
    _lastIsOpen = isOpen;
    _lastHasOpened = hasOpened;
  });
  function setFocus() {
    if (_dialog && _dialog.parentNode && typeof _dialog.parentNode.focus === "function") {
      _dialog.parentNode.focus();
    }
  }
  function init2() {
    try {
      _triggeringElement = document.activeElement;
    } catch (err) {
      _triggeringElement = null;
    }
    if (!staticModal) {
      _originalBodyPadding = getOriginalBodyPadding();
      conditionallyUpdateScrollbar();
      if (openCount === 0) {
        document.body.className = classnames(document.body.className, "modal-open");
      }
      ++openCount;
    }
    $$invalidate(11, _isMounted = true);
  }
  function manageFocusAfterClose() {
    if (_triggeringElement) {
      if (typeof _triggeringElement.focus === "function" && returnFocusAfterClose) {
        _triggeringElement.focus();
      }
      _triggeringElement = null;
    }
  }
  function destroy() {
    manageFocusAfterClose();
  }
  function close() {
    if (openCount <= 1) {
      document.body.classList.remove("modal-open");
    }
    manageFocusAfterClose();
    openCount = Math.max(0, openCount - 1);
    setScrollbarWidth(_originalBodyPadding);
  }
  function handleBackdropClick(e) {
    if (e.target === _mouseDownElement) {
      if (!isOpen || !backdrop) {
        return;
      }
      const backdropElem = _dialog ? _dialog.parentNode : null;
      if (backdrop === true && backdropElem && e.target === backdropElem && toggle) {
        e.stopPropagation();
        toggle(e);
      }
    }
  }
  function onModalOpened() {
    dispatch("open");
    _removeEscListener = browserEvent(document, "keydown", (event) => {
      if (event.key && event.key === "Escape") {
        if (toggle && backdrop === true) {
          if (_removeEscListener)
            _removeEscListener();
          toggle(event);
        }
      }
    });
  }
  function onModalClosing() {
    dispatch("closing");
    if (_removeEscListener) {
      _removeEscListener();
    }
  }
  function onModalClosed() {
    dispatch("close");
    if (unmountOnClose) {
      destroy();
    }
    close();
    if (_isMounted) {
      hasOpened = false;
    }
    $$invalidate(11, _isMounted = false);
  }
  function handleBackdropMouseDown(e) {
    _mouseDownElement = e.target;
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      _dialog = $$value;
      $$invalidate(12, _dialog);
    });
  }
  const introstart_handler = () => dispatch("opening");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(22, className = $$new_props.class);
    if ("static" in $$new_props)
      $$invalidate(0, staticModal = $$new_props.static);
    if ("isOpen" in $$new_props)
      $$invalidate(1, isOpen = $$new_props.isOpen);
    if ("autoFocus" in $$new_props)
      $$invalidate(23, autoFocus = $$new_props.autoFocus);
    if ("body" in $$new_props)
      $$invalidate(2, body = $$new_props.body);
    if ("centered" in $$new_props)
      $$invalidate(24, centered = $$new_props.centered);
    if ("container" in $$new_props)
      $$invalidate(25, container = $$new_props.container);
    if ("fullscreen" in $$new_props)
      $$invalidate(26, fullscreen = $$new_props.fullscreen);
    if ("header" in $$new_props)
      $$invalidate(3, header = $$new_props.header);
    if ("scrollable" in $$new_props)
      $$invalidate(27, scrollable = $$new_props.scrollable);
    if ("size" in $$new_props)
      $$invalidate(28, size = $$new_props.size);
    if ("toggle" in $$new_props)
      $$invalidate(4, toggle = $$new_props.toggle);
    if ("labelledBy" in $$new_props)
      $$invalidate(5, labelledBy = $$new_props.labelledBy);
    if ("backdrop" in $$new_props)
      $$invalidate(6, backdrop = $$new_props.backdrop);
    if ("wrapClassName" in $$new_props)
      $$invalidate(7, wrapClassName = $$new_props.wrapClassName);
    if ("modalClassName" in $$new_props)
      $$invalidate(8, modalClassName = $$new_props.modalClassName);
    if ("contentClassName" in $$new_props)
      $$invalidate(9, contentClassName = $$new_props.contentClassName);
    if ("fade" in $$new_props)
      $$invalidate(10, fade2 = $$new_props.fade);
    if ("unmountOnClose" in $$new_props)
      $$invalidate(29, unmountOnClose = $$new_props.unmountOnClose);
    if ("returnFocusAfterClose" in $$new_props)
      $$invalidate(30, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    if ("$$scope" in $$new_props)
      $$invalidate(34, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    openCount,
    classnames,
    browserEvent,
    createEventDispatcher,
    onDestroy,
    onMount,
    afterUpdate,
    modalIn,
    modalOut,
    InlineContainer: InlineContainer_default,
    ModalBackdrop: ModalBackdrop_default,
    ModalBody: ModalBody_default,
    ModalHeader: ModalHeader_default,
    Portal: Portal_default,
    conditionallyUpdateScrollbar,
    getOriginalBodyPadding,
    setScrollbarWidth,
    uuid,
    dispatch,
    className,
    staticModal,
    isOpen,
    autoFocus,
    body,
    centered,
    container,
    fullscreen,
    header,
    scrollable,
    size,
    toggle,
    labelledBy,
    backdrop,
    wrapClassName,
    modalClassName,
    contentClassName,
    fade: fade2,
    unmountOnClose,
    returnFocusAfterClose,
    hasOpened,
    _isMounted,
    _triggeringElement,
    _originalBodyPadding,
    _lastIsOpen,
    _lastHasOpened,
    _dialog,
    _mouseDownElement,
    _removeEscListener,
    setFocus,
    init: init2,
    manageFocusAfterClose,
    destroy,
    close,
    handleBackdropClick,
    onModalOpened,
    onModalClosing,
    onModalClosed,
    handleBackdropMouseDown,
    dialogBaseClass,
    outer,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(22, className = $$new_props.className);
    if ("staticModal" in $$props)
      $$invalidate(0, staticModal = $$new_props.staticModal);
    if ("isOpen" in $$props)
      $$invalidate(1, isOpen = $$new_props.isOpen);
    if ("autoFocus" in $$props)
      $$invalidate(23, autoFocus = $$new_props.autoFocus);
    if ("body" in $$props)
      $$invalidate(2, body = $$new_props.body);
    if ("centered" in $$props)
      $$invalidate(24, centered = $$new_props.centered);
    if ("container" in $$props)
      $$invalidate(25, container = $$new_props.container);
    if ("fullscreen" in $$props)
      $$invalidate(26, fullscreen = $$new_props.fullscreen);
    if ("header" in $$props)
      $$invalidate(3, header = $$new_props.header);
    if ("scrollable" in $$props)
      $$invalidate(27, scrollable = $$new_props.scrollable);
    if ("size" in $$props)
      $$invalidate(28, size = $$new_props.size);
    if ("toggle" in $$props)
      $$invalidate(4, toggle = $$new_props.toggle);
    if ("labelledBy" in $$props)
      $$invalidate(5, labelledBy = $$new_props.labelledBy);
    if ("backdrop" in $$props)
      $$invalidate(6, backdrop = $$new_props.backdrop);
    if ("wrapClassName" in $$props)
      $$invalidate(7, wrapClassName = $$new_props.wrapClassName);
    if ("modalClassName" in $$props)
      $$invalidate(8, modalClassName = $$new_props.modalClassName);
    if ("contentClassName" in $$props)
      $$invalidate(9, contentClassName = $$new_props.contentClassName);
    if ("fade" in $$props)
      $$invalidate(10, fade2 = $$new_props.fade);
    if ("unmountOnClose" in $$props)
      $$invalidate(29, unmountOnClose = $$new_props.unmountOnClose);
    if ("returnFocusAfterClose" in $$props)
      $$invalidate(30, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    if ("hasOpened" in $$props)
      hasOpened = $$new_props.hasOpened;
    if ("_isMounted" in $$props)
      $$invalidate(11, _isMounted = $$new_props._isMounted);
    if ("_triggeringElement" in $$props)
      _triggeringElement = $$new_props._triggeringElement;
    if ("_originalBodyPadding" in $$props)
      _originalBodyPadding = $$new_props._originalBodyPadding;
    if ("_lastIsOpen" in $$props)
      _lastIsOpen = $$new_props._lastIsOpen;
    if ("_lastHasOpened" in $$props)
      _lastHasOpened = $$new_props._lastHasOpened;
    if ("_dialog" in $$props)
      $$invalidate(12, _dialog = $$new_props._dialog);
    if ("_mouseDownElement" in $$props)
      _mouseDownElement = $$new_props._mouseDownElement;
    if ("_removeEscListener" in $$props)
      _removeEscListener = $$new_props._removeEscListener;
    if ("outer" in $$props)
      $$invalidate(13, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(14, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*className, size, fullscreen, centered, scrollable*/
    490733568) {
      $:
        $$invalidate(14, classes = classnames(dialogBaseClass, className, {
          [`modal-${size}`]: size,
          "modal-fullscreen": fullscreen === true,
          [`modal-fullscreen-${fullscreen}-down`]: fullscreen && typeof fullscreen === "string",
          [`${dialogBaseClass}-centered`]: centered,
          [`${dialogBaseClass}-scrollable`]: scrollable
        }));
    }
    if ($$self.$$.dirty[0] & /*container, staticModal*/
    33554433) {
      $:
        $$invalidate(13, outer = container === "inline" || staticModal ? InlineContainer_default : Portal_default);
    }
  };
  return [
    staticModal,
    isOpen,
    body,
    header,
    toggle,
    labelledBy,
    backdrop,
    wrapClassName,
    modalClassName,
    contentClassName,
    fade2,
    _isMounted,
    _dialog,
    outer,
    classes,
    dispatch,
    handleBackdropClick,
    onModalOpened,
    onModalClosing,
    onModalClosed,
    handleBackdropMouseDown,
    $$restProps,
    className,
    autoFocus,
    centered,
    container,
    fullscreen,
    scrollable,
    size,
    unmountOnClose,
    returnFocusAfterClose,
    slots,
    div1_binding,
    introstart_handler,
    $$scope
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance59,
      create_fragment59,
      safe_not_equal,
      {
        class: 22,
        static: 0,
        isOpen: 1,
        autoFocus: 23,
        body: 2,
        centered: 24,
        container: 25,
        fullscreen: 26,
        header: 3,
        scrollable: 27,
        size: 28,
        toggle: 4,
        labelledBy: 5,
        backdrop: 6,
        wrapClassName: 7,
        modalClassName: 8,
        contentClassName: 9,
        fade: 10,
        unmountOnClose: 29,
        returnFocusAfterClose: 30
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment59.name
    });
  }
  get class() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get static() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set static(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoFocus() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoFocus(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get centered() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set centered(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullscreen() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullscreen(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollable() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollable(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapClassName() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapClassName(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalClassName() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalClassName(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentClassName() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentClassName(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unmountOnClose() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unmountOnClose(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get returnFocusAfterClose() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set returnFocusAfterClose(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/sveltestrap/src/ModalFooter.svelte
var file59 = "node_modules/sveltestrap/src/ModalFooter.svelte";
function create_fragment60(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file59, 9, 0, 167);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalFooter", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "modal-footer"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ModalFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalFooter",
      options,
      id: create_fragment60.name
    });
  }
  get class() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalFooter_default = ModalFooter;

// node_modules/sveltestrap/src/Nav.svelte
var file60 = "node_modules/sveltestrap/src/Nav.svelte";
function create_fragment61(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let ul_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(ul, ul_data);
      add_location(ul, file60, 41, 0, 1007);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getVerticalClass(vertical) {
  if (vertical === false) {
    return false;
  } else if (vertical === true || vertical === "xs") {
    return "flex-column";
  }
  return `flex-${vertical}-column`;
}
function instance61($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "tabs",
    "pills",
    "vertical",
    "horizontal",
    "justified",
    "fill",
    "navbar",
    "card",
    "underline"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { tabs = false } = $$props;
  let { pills = false } = $$props;
  let { vertical = false } = $$props;
  let { horizontal = "" } = $$props;
  let { justified = false } = $$props;
  let { fill = false } = $$props;
  let { navbar = false } = $$props;
  let { card = false } = $$props;
  let { underline = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("tabs" in $$new_props)
      $$invalidate(3, tabs = $$new_props.tabs);
    if ("pills" in $$new_props)
      $$invalidate(4, pills = $$new_props.pills);
    if ("vertical" in $$new_props)
      $$invalidate(5, vertical = $$new_props.vertical);
    if ("horizontal" in $$new_props)
      $$invalidate(6, horizontal = $$new_props.horizontal);
    if ("justified" in $$new_props)
      $$invalidate(7, justified = $$new_props.justified);
    if ("fill" in $$new_props)
      $$invalidate(8, fill = $$new_props.fill);
    if ("navbar" in $$new_props)
      $$invalidate(9, navbar = $$new_props.navbar);
    if ("card" in $$new_props)
      $$invalidate(10, card = $$new_props.card);
    if ("underline" in $$new_props)
      $$invalidate(11, underline = $$new_props.underline);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    tabs,
    pills,
    vertical,
    horizontal,
    justified,
    fill,
    navbar,
    card,
    underline,
    getVerticalClass,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("tabs" in $$props)
      $$invalidate(3, tabs = $$new_props.tabs);
    if ("pills" in $$props)
      $$invalidate(4, pills = $$new_props.pills);
    if ("vertical" in $$props)
      $$invalidate(5, vertical = $$new_props.vertical);
    if ("horizontal" in $$props)
      $$invalidate(6, horizontal = $$new_props.horizontal);
    if ("justified" in $$props)
      $$invalidate(7, justified = $$new_props.justified);
    if ("fill" in $$props)
      $$invalidate(8, fill = $$new_props.fill);
    if ("navbar" in $$props)
      $$invalidate(9, navbar = $$new_props.navbar);
    if ("card" in $$props)
      $$invalidate(10, card = $$new_props.card);
    if ("underline" in $$props)
      $$invalidate(11, underline = $$new_props.underline);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, navbar, horizontal, vertical, tabs, card, pills, justified, fill, underline*/
    4092) {
      $:
        $$invalidate(0, classes = classnames(className, navbar ? "navbar-nav" : "nav", horizontal ? `justify-content-${horizontal}` : false, getVerticalClass(vertical), {
          "nav-tabs": tabs,
          "card-header-tabs": card && tabs,
          "nav-pills": pills,
          "card-header-pills": card && pills,
          "nav-justified": justified,
          "nav-fill": fill,
          "nav-underline": underline
        }));
    }
  };
  return [
    classes,
    $$restProps,
    className,
    tabs,
    pills,
    vertical,
    horizontal,
    justified,
    fill,
    navbar,
    card,
    underline,
    $$scope,
    slots
  ];
}
var Nav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, {
      class: 2,
      tabs: 3,
      pills: 4,
      vertical: 5,
      horizontal: 6,
      justified: 7,
      fill: 8,
      navbar: 9,
      card: 10,
      underline: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav",
      options,
      id: create_fragment61.name
    });
  }
  get class() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pills() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pills(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justified() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justified(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbar() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbar(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get card() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set card(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get underline() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set underline(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Nav_default = Nav;

// node_modules/sveltestrap/src/Navbar.svelte
var file61 = "node_modules/sveltestrap/src/Navbar.svelte";
function create_else_block18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block18.name,
    type: "else",
    source: "(44:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let container_1;
  let current;
  container_1 = new Container_default({
    props: {
      fluid: (
        /*container*/
        ctx[0] === "fluid"
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(container_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(container_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(container_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_1_changes = {};
      if (dirty & /*container*/
      1)
        container_1_changes.fluid = /*container*/
        ctx2[0] === "fluid";
      if (dirty & /*$$scope*/
      4096) {
        container_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container_1.$set(container_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(40:2) {#if container}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(41:4) <Container fluid={container === 'fluid'}>",
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let nav;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block23, create_else_block18];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*container*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let nav_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[2]
    ) }
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true, "data-bs-theme": true });
      var nav_nodes = children(nav);
      if_block.l(nav_nodes);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(nav, nav_data);
      add_location(nav, file61, 38, 0, 896);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      if_blocks[current_block_type_index].m(nav, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(nav, null);
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*theme*/
        4) && { "data-bs-theme": (
          /*theme*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getExpandClass(expand) {
  if (expand === false) {
    return false;
  } else if (expand === true || expand === "xs") {
    return "navbar-expand";
  }
  return `navbar-expand-${expand}`;
}
function instance62($$self, $$props, $$invalidate) {
  let theme;
  let classes;
  const omit_props_names = ["class", "container", "color", "dark", "expand", "fixed", "light", "sticky"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Navbar", slots, ["default"]);
  setContext("navbar", { inNavbar: true });
  let { class: className = "" } = $$props;
  let { container = "fluid" } = $$props;
  let { color = "" } = $$props;
  let { dark = false } = $$props;
  let { expand = "" } = $$props;
  let { fixed = "" } = $$props;
  let { light = false } = $$props;
  let { sticky = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("container" in $$new_props)
      $$invalidate(0, container = $$new_props.container);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("dark" in $$new_props)
      $$invalidate(6, dark = $$new_props.dark);
    if ("expand" in $$new_props)
      $$invalidate(7, expand = $$new_props.expand);
    if ("fixed" in $$new_props)
      $$invalidate(8, fixed = $$new_props.fixed);
    if ("light" in $$new_props)
      $$invalidate(9, light = $$new_props.light);
    if ("sticky" in $$new_props)
      $$invalidate(10, sticky = $$new_props.sticky);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    Container: Container_default,
    setContext,
    className,
    container,
    color,
    dark,
    expand,
    fixed,
    light,
    sticky,
    getExpandClass,
    classes,
    theme
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("container" in $$props)
      $$invalidate(0, container = $$new_props.container);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("dark" in $$props)
      $$invalidate(6, dark = $$new_props.dark);
    if ("expand" in $$props)
      $$invalidate(7, expand = $$new_props.expand);
    if ("fixed" in $$props)
      $$invalidate(8, fixed = $$new_props.fixed);
    if ("light" in $$props)
      $$invalidate(9, light = $$new_props.light);
    if ("sticky" in $$props)
      $$invalidate(10, sticky = $$new_props.sticky);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("theme" in $$props)
      $$invalidate(2, theme = $$new_props.theme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dark, light*/
    576) {
      $:
        $$invalidate(2, theme = dark ? "dark" : light ? "light" : void 0);
    }
    if ($$self.$$.dirty & /*className, expand, color, fixed, sticky*/
    1456) {
      $:
        $$invalidate(1, classes = classnames(className, "navbar", getExpandClass(expand), {
          [`bg-${color}`]: color,
          [`fixed-${fixed}`]: fixed,
          [`sticky-${sticky}`]: sticky
        }));
    }
  };
  return [
    container,
    classes,
    theme,
    $$restProps,
    className,
    color,
    dark,
    expand,
    fixed,
    light,
    sticky,
    slots,
    $$scope
  ];
}
var Navbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, {
      class: 4,
      container: 0,
      color: 5,
      dark: 6,
      expand: 7,
      fixed: 8,
      light: 9,
      sticky: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navbar",
      options,
      id: create_fragment62.name
    });
  }
  get class() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dark() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dark(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expand(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sticky() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sticky(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Navbar_default = Navbar;

// node_modules/sveltestrap/src/NavItem.svelte
var file62 = "node_modules/sveltestrap/src/NavItem.svelte";
function create_fragment63(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      if (default_slot)
        default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      add_location(li, file62, 10, 0, 219);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(3, active = $$new_props.active);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, active, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(3, active = $$new_props.active);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, active*/
    12) {
      $:
        $$invalidate(0, classes = classnames(className, "nav-item", active ? "active" : false));
    }
  };
  return [classes, $$restProps, className, active, $$scope, slots];
}
var NavItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, { class: 2, active: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavItem",
      options,
      id: create_fragment63.name
    });
  }
  get class() {
    throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavItem_default = NavItem;

// node_modules/sveltestrap/src/NavLink.svelte
var file63 = "node_modules/sveltestrap/src/NavLink.svelte";
function create_fragment64(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[3],
    { href: (
      /*href*/
      ctx[0]
    ) },
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file63, 27, 0, 472);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "click",
            /*handleClick*/
            ctx[2],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) },
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "disabled", "active", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavLink", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { disabled = false } = $$props;
  let { active = false } = $$props;
  let { href = "#" } = $$props;
  function handleClick(e) {
    if (disabled) {
      e.preventDefault();
      e.stopImmediatePropagation();
      return;
    }
    if (href === "#") {
      e.preventDefault();
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("active" in $$new_props)
      $$invalidate(6, active = $$new_props.active);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    disabled,
    active,
    href,
    handleClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("active" in $$props)
      $$invalidate(6, active = $$new_props.active);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, disabled, active*/
    112) {
      $:
        $$invalidate(1, classes = classnames(className, "nav-link", { disabled, active }));
    }
  };
  return [
    href,
    classes,
    handleClick,
    $$restProps,
    className,
    disabled,
    active,
    $$scope,
    slots,
    click_handler
  ];
}
var NavLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, {
      class: 4,
      disabled: 5,
      active: 6,
      href: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavLink",
      options,
      id: create_fragment64.name
    });
  }
  get class() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavLink_default = NavLink;

// node_modules/sveltestrap/src/NavbarBrand.svelte
var file64 = "node_modules/sveltestrap/src/NavbarBrand.svelte";
function create_fragment65(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { href: (
      /*href*/
      ctx[0]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file64, 10, 0, 192);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[6],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavbarBrand", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { href = "/" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, href, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    8) {
      $:
        $$invalidate(1, classes = classnames(className, "navbar-brand"));
    }
  };
  return [href, classes, $$restProps, className, $$scope, slots, click_handler];
}
var NavbarBrand = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, { class: 3, href: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavbarBrand",
      options,
      id: create_fragment65.name
    });
  }
  get class() {
    throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavbarBrand_default = NavbarBrand;

// node_modules/sveltestrap/src/NavbarToggler.svelte
var file65 = "node_modules/sveltestrap/src/NavbarToggler.svelte";
function fallback_block5(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "navbar-toggler-icon");
      add_location(span, file65, 11, 4, 233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block5.name,
    type: "fallback",
    source: "(11:8)      ",
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block5(ctx);
  let button_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file65, 9, 0, 169);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavbarToggler", slots, ["default"]);
  let { class: className = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "navbar-toggler"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots, click_handler];
}
var NavbarToggler = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavbarToggler",
      options,
      id: create_fragment66.name
    });
  }
  get class() {
    throw new Error("<NavbarToggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavbarToggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavbarToggler_default = NavbarToggler;

// node_modules/sveltestrap/src/OffcanvasBackdrop.svelte
var file66 = "node_modules/sveltestrap/src/OffcanvasBackdrop.svelte";
function create_if_block24(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    { role: "presentation" },
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true, class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(
        div,
        "fade",
        /*fade*/
        ctx[1]
      );
      add_location(div, file66, 12, 2, 354);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "presentation" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
      toggle_class(
        div,
        "fade",
        /*fade*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, backdropIn, {});
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(div, backdropOut, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(12:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment67(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block24(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "isOpen", "fade"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OffcanvasBackdrop", slots, []);
  let { class: className = "" } = $$props;
  let { isOpen = false } = $$props;
  let { fade: fade2 = true } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$new_props)
      $$invalidate(1, fade2 = $$new_props.fade);
  };
  $$self.$capture_state = () => ({
    classnames,
    backdropIn,
    backdropOut,
    className,
    isOpen,
    fade: fade2,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$props)
      $$invalidate(1, fade2 = $$new_props.fade);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    16) {
      $:
        $$invalidate(2, classes = classnames(className, "offcanvas-backdrop"));
    }
  };
  return [isOpen, fade2, classes, $$restProps, className, click_handler];
}
var OffcanvasBackdrop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, { class: 4, isOpen: 0, fade: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OffcanvasBackdrop",
      options,
      id: create_fragment67.name
    });
  }
  get class() {
    throw new Error("<OffcanvasBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OffcanvasBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<OffcanvasBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<OffcanvasBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<OffcanvasBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<OffcanvasBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OffcanvasBackdrop_default = OffcanvasBackdrop;

// node_modules/sveltestrap/src/OffcanvasBody.svelte
var file67 = "node_modules/sveltestrap/src/OffcanvasBody.svelte";
function create_fragment68(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file67, 9, 0, 169);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OffcanvasBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "offcanvas-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var OffcanvasBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OffcanvasBody",
      options,
      id: create_fragment68.name
    });
  }
  get class() {
    throw new Error("<OffcanvasBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OffcanvasBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OffcanvasBody_default = OffcanvasBody;

// node_modules/sveltestrap/src/OffcanvasHeader.svelte
var file68 = "node_modules/sveltestrap/src/OffcanvasHeader.svelte";
var get_close_slot_changes2 = (dirty) => ({});
var get_close_slot_context2 = (ctx) => ({});
function create_else_block19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block19.name,
    type: "else",
    source: "(17:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      1)
        set_data_dev(
          t,
          /*children*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(15:4) {#if children}",
    ctx
  });
  return block;
}
function create_if_block25(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "aria-label": true,
        class: true,
        type: true
      });
      children(button).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "aria-label",
        /*closeAriaLabel*/
        ctx[1]
      );
      attr_dev(button, "class", "btn-close");
      attr_dev(button, "type", "button");
      add_location(button, file68, 22, 6, 496);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*toggle*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*closeAriaLabel*/
      2) {
        attr_dev(
          button,
          "aria-label",
          /*closeAriaLabel*/
          ctx[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(22:4) {#if typeof toggle === 'function'}",
    ctx
  });
  return block;
}
function fallback_block6(ctx) {
  let if_block_anchor;
  let if_block = typeof /*toggle*/
  ctx[2] === "function" && create_if_block25(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (typeof /*toggle*/
      ctx2[2] === "function") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block25(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block6.name,
    type: "fallback",
    source: "(21:21)      ",
    ctx
  });
  return block;
}
function create_fragment69(ctx) {
  let div;
  let h5;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_114, create_else_block19];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const close_slot_template = (
    /*#slots*/
    ctx[7].close
  );
  const close_slot = create_slot(
    close_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_close_slot_context2
  );
  const close_slot_or_fallback = close_slot || fallback_block6(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      h5 = element("h5");
      if_block.c();
      t = space();
      if (close_slot_or_fallback)
        close_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      h5 = claim_element(div_nodes, "H5", { class: true });
      var h5_nodes = children(h5);
      if_block.l(h5_nodes);
      h5_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      if (close_slot_or_fallback)
        close_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h5, "class", "offcanvas-title");
      add_location(h5, file68, 13, 2, 319);
      set_attributes(div, div_data);
      add_location(div, file68, 12, 0, 278);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h5);
      if_blocks[current_block_type_index].m(h5, null);
      append_hydration_dev(div, t);
      if (close_slot_or_fallback) {
        close_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(h5, null);
      }
      if (close_slot) {
        if (close_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              close_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_close_slot_changes2
            ),
            get_close_slot_context2
          );
        }
      } else {
        if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/
        6)) {
          close_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(close_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(close_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (close_slot_or_fallback)
        close_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "children", "closeAriaLabel", "toggle"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OffcanvasHeader", slots, ["default", "close"]);
  let { class: className = "" } = $$props;
  let { children: children2 = void 0 } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  let { toggle = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(0, children2 = $$new_props.children);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("toggle" in $$new_props)
      $$invalidate(2, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    children: children2,
    closeAriaLabel,
    toggle,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(0, children2 = $$new_props.children);
    if ("closeAriaLabel" in $$props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("toggle" in $$props)
      $$invalidate(2, toggle = $$new_props.toggle);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    32) {
      $:
        $$invalidate(3, classes = classnames(className, "offcanvas-header"));
    }
  };
  return [
    children2,
    closeAriaLabel,
    toggle,
    classes,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var OffcanvasHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, {
      class: 5,
      children: 0,
      closeAriaLabel: 1,
      toggle: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OffcanvasHeader",
      options,
      id: create_fragment69.name
    });
  }
  get class() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OffcanvasHeader_default = OffcanvasHeader;

// node_modules/sveltestrap/src/Offcanvas.svelte
var { document: document_1 } = globals;
var file69 = "node_modules/sveltestrap/src/Offcanvas.svelte";
function add_css2(target) {
  append_styles(target, "svelte-xe7n9u", ".overflow-noscroll{overflow:hidden;padding-right:0px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT2ZmY2FudmFzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpSVUsa0JBQW9CLENBQzFCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGFBQWEsQ0FBRSxHQUNqQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJPZmZjYW52YXMuc3ZlbHRlIl19 */");
}
var get_header_slot_changes3 = (dirty) => ({});
var get_header_slot_context3 = (ctx) => ({});
function create_if_block_211(ctx) {
  let offcanvasheader;
  let current;
  offcanvasheader = new OffcanvasHeader_default({
    props: {
      toggle: (
        /*toggle*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(offcanvasheader.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(offcanvasheader.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(offcanvasheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const offcanvasheader_changes = {};
      if (dirty & /*toggle*/
      64)
        offcanvasheader_changes.toggle = /*toggle*/
        ctx2[6];
      if (dirty & /*$$scope, header*/
      268435472) {
        offcanvasheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      offcanvasheader.$set(offcanvasheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(offcanvasheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(offcanvasheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(offcanvasheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(106:4) {#if toggle || header || $$slots.header}",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*header*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*header*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*header*/
      16)
        set_data_dev(
          t,
          /*header*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(108:8) {#if header}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let t;
  let current;
  let if_block = (
    /*header*/
    ctx[4] && create_if_block_35(ctx)
  );
  const header_slot_template = (
    /*#slots*/
    ctx[25].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_header_slot_context3
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (header_slot)
        header_slot.c();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      if (header_slot)
        header_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*header*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_35(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_header_slot_changes3
            ),
            get_header_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(107:6) <OffcanvasHeader {toggle}>",
    ctx
  });
  return block;
}
function create_else_block20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block20.name,
    type: "else",
    source: "(116:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let offcanvasbody;
  let current;
  offcanvasbody = new OffcanvasBody_default({
    props: {
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(offcanvasbody.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(offcanvasbody.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(offcanvasbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const offcanvasbody_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        offcanvasbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      offcanvasbody.$set(offcanvasbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(offcanvasbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(offcanvasbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(offcanvasbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(112:4) {#if body}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(113:6) <OffcanvasBody>",
    ctx
  });
  return block;
}
function create_if_block26(ctx) {
  let offcanvasbackdrop;
  let current;
  offcanvasbackdrop = new OffcanvasBackdrop_default({
    props: {
      fade: (
        /*fade*/
        ctx[3]
      ),
      isOpen: (
        /*isOpen*/
        ctx[0]
      )
    },
    $$inline: true
  });
  offcanvasbackdrop.$on("click", function() {
    if (is_function(
      /*toggle*/
      ctx[6] ? (
        /*click_handler*/
        ctx[27]
      ) : void 0
    ))
      /*toggle*/
      (ctx[6] ? (
        /*click_handler*/
        ctx[27]
      ) : void 0).apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(offcanvasbackdrop.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(offcanvasbackdrop.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(offcanvasbackdrop, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const offcanvasbackdrop_changes = {};
      if (dirty & /*fade*/
      8)
        offcanvasbackdrop_changes.fade = /*fade*/
        ctx[3];
      if (dirty & /*isOpen*/
      1)
        offcanvasbackdrop_changes.isOpen = /*isOpen*/
        ctx[0];
      offcanvasbackdrop.$set(offcanvasbackdrop_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(offcanvasbackdrop.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(offcanvasbackdrop.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(offcanvasbackdrop, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(120:2) {#if backdrop}",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let div_aria_hidden_value;
  let div_aria_modal_value;
  let div_role_value;
  let div_style_value;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*toggle*/
    (ctx[6] || /*header*/
    ctx[4] || /*$$slots*/
    ctx[13].header) && create_if_block_211(ctx)
  );
  const if_block_creators = [create_if_block_115, create_else_block20];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*body*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[12],
    {
      "aria-hidden": div_aria_hidden_value = !/*isOpen*/
      ctx[0] ? true : void 0
    },
    {
      "aria-modal": div_aria_modal_value = /*isOpen*/
      ctx[0] ? true : void 0
    },
    { class: (
      /*classes*/
      ctx[10]
    ) },
    {
      role: div_role_value = /*isOpen*/
      ctx[0] || /*isTransitioning*/
      ctx[7] ? "dialog" : void 0
    },
    {
      style: div_style_value = `visibility: ${/*isOpen*/
      ctx[0] || /*isTransitioning*/
      ctx[7] ? "visible" : "hidden"};${/*style*/
      ctx[5]}`
    },
    { tabindex: "-1" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  let if_block2 = (
    /*backdrop*/
    ctx[1] && create_if_block26(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "aria-hidden": true,
        "aria-modal": true,
        class: true,
        role: true,
        style: true,
        tabindex: true
      });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file69, 93, 2, 2592);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      ctx[26](div);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*toggle*/
        ctx2[6] || /*header*/
        ctx2[4] || /*$$slots*/
        ctx2[13].header
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*toggle, header, $$slots*/
          8272) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_211(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        (!current || dirty & /*isOpen*/
        1 && div_aria_hidden_value !== (div_aria_hidden_value = !/*isOpen*/
        ctx2[0] ? true : void 0)) && { "aria-hidden": div_aria_hidden_value },
        (!current || dirty & /*isOpen*/
        1 && div_aria_modal_value !== (div_aria_modal_value = /*isOpen*/
        ctx2[0] ? true : void 0)) && { "aria-modal": div_aria_modal_value },
        (!current || dirty & /*classes*/
        1024) && { class: (
          /*classes*/
          ctx2[10]
        ) },
        (!current || dirty & /*isOpen, isTransitioning*/
        129 && div_role_value !== (div_role_value = /*isOpen*/
        ctx2[0] || /*isTransitioning*/
        ctx2[7] ? "dialog" : void 0)) && { role: div_role_value },
        (!current || dirty & /*isOpen, isTransitioning, style*/
        161 && div_style_value !== (div_style_value = `visibility: ${/*isOpen*/
        ctx2[0] || /*isTransitioning*/
        ctx2[7] ? "visible" : "hidden"};${/*style*/
        ctx2[5]}`)) && { style: div_style_value },
        { tabindex: "-1" }
      ]));
      if (
        /*backdrop*/
        ctx2[1]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*backdrop*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block26(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      ctx[26](null);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(93:0) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let t;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*outer*/
    ctx[9]
  );
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot6] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      t = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      t = claim_space(nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          document_1.body,
          "mousedown",
          function() {
            if (is_function(
              /*handleMouseDown*/
              ctx[11]
            ))
              ctx[11].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & /*$$scope, fade, isOpen, toggle, backdrop, $$restProps, classes, isTransitioning, style, element, body, header, $$slots*/
      268449279) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (dirty & /*outer*/
      512 && switch_value !== (switch_value = /*outer*/
      ctx[9])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let handleMouseDown;
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "backdrop",
    "body",
    "container",
    "fade",
    "header",
    "isOpen",
    "placement",
    "scroll",
    "sm",
    "md",
    "lg",
    "xl",
    "xxl",
    "style",
    "toggle"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Offcanvas", slots, ["header", "default"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { backdrop = true } = $$props;
  let { body = true } = $$props;
  let { container = "body" } = $$props;
  let { fade: fade2 = true } = $$props;
  let { header = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { placement = "start" } = $$props;
  let { scroll = false } = $$props;
  let { sm = false } = $$props;
  let { md = false } = $$props;
  let { lg = false } = $$props;
  let { xl = false } = $$props;
  let { xxl = false } = $$props;
  let { style = "" } = $$props;
  let { toggle = void 0 } = $$props;
  let bodyElement;
  let isTransitioning = false;
  let element2;
  let removeEscListener;
  onMount(() => $$invalidate(23, bodyElement = document.body));
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(8, element2);
    });
  }
  const click_handler = () => toggle();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(14, className = $$new_props.class);
    if ("backdrop" in $$new_props)
      $$invalidate(1, backdrop = $$new_props.backdrop);
    if ("body" in $$new_props)
      $$invalidate(2, body = $$new_props.body);
    if ("container" in $$new_props)
      $$invalidate(15, container = $$new_props.container);
    if ("fade" in $$new_props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$new_props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$new_props)
      $$invalidate(16, placement = $$new_props.placement);
    if ("scroll" in $$new_props)
      $$invalidate(17, scroll = $$new_props.scroll);
    if ("sm" in $$new_props)
      $$invalidate(18, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(19, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(20, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(21, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(22, xxl = $$new_props.xxl);
    if ("style" in $$new_props)
      $$invalidate(5, style = $$new_props.style);
    if ("toggle" in $$new_props)
      $$invalidate(6, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    InlineContainer: InlineContainer_default,
    OffcanvasBackdrop: OffcanvasBackdrop_default,
    OffcanvasBody: OffcanvasBody_default,
    OffcanvasHeader: OffcanvasHeader_default,
    Portal: Portal_default,
    classnames,
    browserEvent,
    getTransitionDuration,
    dispatch,
    className,
    backdrop,
    body,
    container,
    fade: fade2,
    header,
    isOpen,
    placement,
    scroll,
    sm,
    md,
    lg,
    xl,
    xxl,
    style,
    toggle,
    bodyElement,
    isTransitioning,
    element: element2,
    removeEscListener,
    outer,
    classes,
    handleMouseDown
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(14, className = $$new_props.className);
    if ("backdrop" in $$props)
      $$invalidate(1, backdrop = $$new_props.backdrop);
    if ("body" in $$props)
      $$invalidate(2, body = $$new_props.body);
    if ("container" in $$props)
      $$invalidate(15, container = $$new_props.container);
    if ("fade" in $$props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$props)
      $$invalidate(16, placement = $$new_props.placement);
    if ("scroll" in $$props)
      $$invalidate(17, scroll = $$new_props.scroll);
    if ("sm" in $$props)
      $$invalidate(18, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(19, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(20, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(21, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(22, xxl = $$new_props.xxl);
    if ("style" in $$props)
      $$invalidate(5, style = $$new_props.style);
    if ("toggle" in $$props)
      $$invalidate(6, toggle = $$new_props.toggle);
    if ("bodyElement" in $$props)
      $$invalidate(23, bodyElement = $$new_props.bodyElement);
    if ("isTransitioning" in $$props)
      $$invalidate(7, isTransitioning = $$new_props.isTransitioning);
    if ("element" in $$props)
      $$invalidate(8, element2 = $$new_props.element);
    if ("removeEscListener" in $$props)
      $$invalidate(24, removeEscListener = $$new_props.removeEscListener);
    if ("outer" in $$props)
      $$invalidate(9, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(10, classes = $$new_props.classes);
    if ("handleMouseDown" in $$props)
      $$invalidate(11, handleMouseDown = $$new_props.handleMouseDown);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*element, isOpen*/
    257) {
      $:
        if (element2) {
          $$invalidate(0, isOpen), $$invalidate(8, element2);
          $$invalidate(7, isTransitioning = true);
          dispatch(isOpen ? "opening" : "closing");
          setTimeout(
            () => {
              $$invalidate(7, isTransitioning = false);
              dispatch(isOpen ? "open" : "close");
            },
            getTransitionDuration(element2)
          );
        }
    }
    if ($$self.$$.dirty & /*bodyElement, scroll, isOpen, isTransitioning*/
    8519809) {
      $:
        if (bodyElement) {
          if (!scroll) {
            bodyElement.classList.toggle("overflow-noscroll", isOpen || isTransitioning);
          }
        }
    }
    if ($$self.$$.dirty & /*isOpen, toggle*/
    65) {
      $:
        if (isOpen && toggle && typeof window !== "undefined") {
          $$invalidate(24, removeEscListener = browserEvent(document, "keydown", (event) => {
            if (event.key && event.key === "Escape")
              toggle();
          }));
        }
    }
    if ($$self.$$.dirty & /*isOpen, removeEscListener*/
    16777217) {
      $:
        if (!isOpen && removeEscListener) {
          removeEscListener();
        }
    }
    if ($$self.$$.dirty & /*backdrop, toggle, bodyElement, isOpen*/
    8388675) {
      $:
        $$invalidate(11, handleMouseDown = backdrop && toggle && bodyElement && isOpen ? (e) => {
          if (e.target === bodyElement) {
            toggle();
          }
        } : void 0);
    }
    if ($$self.$$.dirty & /*sm, md, lg, xl, xxl, isOpen, placement, className*/
    8208385) {
      $:
        $$invalidate(10, classes = classnames(
          {
            offcanvas: !sm && !md && !lg && !xl && !xxl,
            "offcanvas-sm": sm,
            "offcanvas-md": md,
            "offcanvas-lg": lg,
            "offcanvas-xl": xl,
            "offcanvas-xxl": xxl,
            show: isOpen
          },
          `offcanvas-${placement}`,
          className
        ));
    }
    if ($$self.$$.dirty & /*container*/
    32768) {
      $:
        $$invalidate(9, outer = container === "inline" ? InlineContainer_default : Portal_default);
    }
  };
  return [
    isOpen,
    backdrop,
    body,
    fade2,
    header,
    style,
    toggle,
    isTransitioning,
    element2,
    outer,
    classes,
    handleMouseDown,
    $$restProps,
    $$slots,
    className,
    container,
    placement,
    scroll,
    sm,
    md,
    lg,
    xl,
    xxl,
    bodyElement,
    removeEscListener,
    slots,
    div_binding,
    click_handler,
    $$scope
  ];
}
var Offcanvas = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance70,
      create_fragment70,
      safe_not_equal,
      {
        class: 14,
        backdrop: 1,
        body: 2,
        container: 15,
        fade: 3,
        header: 4,
        isOpen: 0,
        placement: 16,
        scroll: 17,
        sm: 18,
        md: 19,
        lg: 20,
        xl: 21,
        xxl: 22,
        style: 5,
        toggle: 6
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Offcanvas",
      options,
      id: create_fragment70.name
    });
  }
  get class() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scroll() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scroll(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Offcanvas_default = Offcanvas;

// node_modules/sveltestrap/src/Pagination.svelte
var file70 = "node_modules/sveltestrap/src/Pagination.svelte";
function create_fragment71(ctx) {
  let nav;
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let nav_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) },
    { "aria-label": (
      /*ariaLabel*/
      ctx[0]
    ) }
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true, "aria-label": true });
      var nav_nodes = children(nav);
      ul = claim_element(nav_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        ul,
        "class",
        /*listClasses*/
        ctx[1]
      );
      add_location(ul, file70, 17, 2, 414);
      set_attributes(nav, nav_data);
      add_location(nav, file70, 16, 0, 350);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*listClasses*/
      2) {
        attr_dev(
          ul,
          "class",
          /*listClasses*/
          ctx2[1]
        );
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        (!current || dirty & /*ariaLabel*/
        1) && { "aria-label": (
          /*ariaLabel*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  let classes;
  let listClasses;
  const omit_props_names = ["class", "listClassName", "size", "ariaLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { listClassName = "" } = $$props;
  let { size = "" } = $$props;
  let { ariaLabel = "pagination" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("listClassName" in $$new_props)
      $$invalidate(5, listClassName = $$new_props.listClassName);
    if ("size" in $$new_props)
      $$invalidate(6, size = $$new_props.size);
    if ("ariaLabel" in $$new_props)
      $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    listClassName,
    size,
    ariaLabel,
    listClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("listClassName" in $$props)
      $$invalidate(5, listClassName = $$new_props.listClassName);
    if ("size" in $$props)
      $$invalidate(6, size = $$new_props.size);
    if ("ariaLabel" in $$props)
      $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    if ("listClasses" in $$props)
      $$invalidate(1, listClasses = $$new_props.listClasses);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    16) {
      $:
        $$invalidate(2, classes = classnames(className));
    }
    if ($$self.$$.dirty & /*listClassName, size*/
    96) {
      $:
        $$invalidate(1, listClasses = classnames(listClassName, "pagination", { [`pagination-${size}`]: !!size }));
    }
  };
  return [
    ariaLabel,
    listClasses,
    classes,
    $$restProps,
    className,
    listClassName,
    size,
    $$scope,
    slots
  ];
}
var Pagination = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, {
      class: 4,
      listClassName: 5,
      size: 6,
      ariaLabel: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination",
      options,
      id: create_fragment71.name
    });
  }
  get class() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listClassName() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listClassName(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default = Pagination;

// node_modules/sveltestrap/src/PaginationItem.svelte
var file71 = "node_modules/sveltestrap/src/PaginationItem.svelte";
function create_fragment72(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      if (default_slot)
        default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(li, li_data);
      add_location(li, file71, 14, 0, 256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(3, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    disabled,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(3, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, active, disabled*/
    28) {
      $:
        $$invalidate(0, classes = classnames(className, "page-item", { active, disabled }));
    }
  };
  return [classes, $$restProps, className, active, disabled, $$scope, slots];
}
var PaginationItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance72, create_fragment72, safe_not_equal, { class: 2, active: 3, disabled: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationItem",
      options,
      id: create_fragment72.name
    });
  }
  get class() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationItem_default = PaginationItem;

// node_modules/sveltestrap/src/PaginationLink.svelte
var file72 = "node_modules/sveltestrap/src/PaginationLink.svelte";
function create_else_block21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block21.name,
    type: "else",
    source: "(47:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block27(ctx) {
  let span0;
  let t0;
  let span1;
  let t1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block7(ctx);
  const block = {
    c: function create() {
      span0 = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      span1 = element("span");
      t1 = text(
        /*realLabel*/
        ctx[6]
      );
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { "aria-hidden": true });
      var span0_nodes = children(span0);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(
        span1_nodes,
        /*realLabel*/
        ctx[6]
      );
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "aria-hidden", "true");
      add_location(span0, file72, 42, 4, 948);
      attr_dev(span1, "class", "visually-hidden");
      add_location(span1, file72, 45, 4, 1024);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span0, null);
      }
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*defaultCaret*/
        32)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*realLabel*/
      64)
        set_data_dev(
          t1,
          /*realLabel*/
          ctx2[6]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span0);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(42:2) {#if previous || next || first || last}",
    ctx
  });
  return block;
}
function fallback_block7(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*defaultCaret*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*defaultCaret*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*defaultCaret*/
      32)
        set_data_dev(
          t,
          /*defaultCaret*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block7.name,
    type: "fallback",
    source: "(44:12) {defaultCaret}",
    ctx
  });
  return block;
}
function create_fragment73(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block27, create_else_block21];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*previous*/
      ctx2[1] || /*next*/
      ctx2[0] || /*first*/
      ctx2[2] || /*last*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[7]
    ) },
    { href: (
      /*href*/
      ctx[4]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      if_block.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file72, 40, 0, 849);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[14],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*classes*/
        128) && { class: (
          /*classes*/
          ctx2[7]
        ) },
        (!current || dirty & /*href*/
        16) && { href: (
          /*href*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let classes;
  let realLabel;
  const omit_props_names = ["class", "next", "previous", "first", "last", "ariaLabel", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationLink", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { next = false } = $$props;
  let { previous = false } = $$props;
  let { first = false } = $$props;
  let { last = false } = $$props;
  let { ariaLabel = "" } = $$props;
  let { href = "" } = $$props;
  let defaultAriaLabel;
  let defaultCaret;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("next" in $$new_props)
      $$invalidate(0, next = $$new_props.next);
    if ("previous" in $$new_props)
      $$invalidate(1, previous = $$new_props.previous);
    if ("first" in $$new_props)
      $$invalidate(2, first = $$new_props.first);
    if ("last" in $$new_props)
      $$invalidate(3, last = $$new_props.last);
    if ("ariaLabel" in $$new_props)
      $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
    if ("href" in $$new_props)
      $$invalidate(4, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    next,
    previous,
    first,
    last,
    ariaLabel,
    href,
    defaultAriaLabel,
    defaultCaret,
    realLabel,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("next" in $$props)
      $$invalidate(0, next = $$new_props.next);
    if ("previous" in $$props)
      $$invalidate(1, previous = $$new_props.previous);
    if ("first" in $$props)
      $$invalidate(2, first = $$new_props.first);
    if ("last" in $$props)
      $$invalidate(3, last = $$new_props.last);
    if ("ariaLabel" in $$props)
      $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
    if ("href" in $$props)
      $$invalidate(4, href = $$new_props.href);
    if ("defaultAriaLabel" in $$props)
      $$invalidate(11, defaultAriaLabel = $$new_props.defaultAriaLabel);
    if ("defaultCaret" in $$props)
      $$invalidate(5, defaultCaret = $$new_props.defaultCaret);
    if ("realLabel" in $$props)
      $$invalidate(6, realLabel = $$new_props.realLabel);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    512) {
      $:
        $$invalidate(7, classes = classnames(className, "page-link"));
    }
    if ($$self.$$.dirty & /*previous, next, first, last*/
    15) {
      $:
        if (previous) {
          $$invalidate(11, defaultAriaLabel = "Previous");
        } else if (next) {
          $$invalidate(11, defaultAriaLabel = "Next");
        } else if (first) {
          $$invalidate(11, defaultAriaLabel = "First");
        } else if (last) {
          $$invalidate(11, defaultAriaLabel = "Last");
        }
    }
    if ($$self.$$.dirty & /*ariaLabel, defaultAriaLabel*/
    3072) {
      $:
        $$invalidate(6, realLabel = ariaLabel || defaultAriaLabel);
    }
    if ($$self.$$.dirty & /*previous, next, first, last*/
    15) {
      $:
        if (previous) {
          $$invalidate(5, defaultCaret = "‹");
        } else if (next) {
          $$invalidate(5, defaultCaret = "›");
        } else if (first) {
          $$invalidate(5, defaultCaret = "«");
        } else if (last) {
          $$invalidate(5, defaultCaret = "»");
        }
    }
  };
  return [
    next,
    previous,
    first,
    last,
    href,
    defaultCaret,
    realLabel,
    classes,
    $$restProps,
    className,
    ariaLabel,
    defaultAriaLabel,
    $$scope,
    slots,
    click_handler
  ];
}
var PaginationLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, {
      class: 9,
      next: 0,
      previous: 1,
      first: 2,
      last: 3,
      ariaLabel: 10,
      href: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationLink",
      options,
      id: create_fragment73.name
    });
  }
  get class() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get next() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set next(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get previous() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set previous(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get first() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set first(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get last() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set last(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationLink_default = PaginationLink;

// node_modules/sveltestrap/src/Popover.svelte
var { Error: Error_12 } = globals;
var file73 = "node_modules/sveltestrap/src/Popover.svelte";
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
function create_if_block28(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*outer*/
    ctx[5]
  );
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot7] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*$$scope, $$restProps, classes, popperPlacement, popoverEl, children, title*/
      1048798) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & /*outer*/
      32 && switch_value !== (switch_value = /*outer*/
      ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(115:0) {#if isOpen}",
    ctx
  });
  return block;
}
function fallback_block8(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*title*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      4)
        set_data_dev(
          t,
          /*title*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block8.name,
    type: "fallback",
    source: "(126:27) {title}",
    ctx
  });
  return block;
}
function create_else_block22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block22.name,
    type: "else",
    source: "(131:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: "(129:8) {#if children}",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let div2;
  let div0;
  let t0;
  let h3;
  let t1;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[18].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_title_slot_context
  );
  const title_slot_or_fallback = title_slot || fallback_block8(ctx);
  const if_block_creators = [create_if_block_116, create_else_block22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div2_levels = [
    /*$$restProps*/
    ctx[7],
    { class: (
      /*classes*/
      ctx[6]
    ) },
    { role: "tooltip" },
    {
      "x-placement": (
        /*popperPlacement*/
        ctx[4]
      )
    }
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      h3 = element("h3");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      t1 = space();
      div1 = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "x-placement": true
      });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true, "data-popper-arrow": true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      h3 = claim_element(div2_nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      if (title_slot_or_fallback)
        title_slot_or_fallback.l(h3_nodes);
      h3_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "popover-arrow");
      attr_dev(div0, "data-popper-arrow", "");
      add_location(div0, file73, 123, 6, 3170);
      attr_dev(h3, "class", "popover-header");
      add_location(h3, file73, 124, 6, 3224);
      attr_dev(div1, "class", "popover-body");
      add_location(div1, file73, 127, 6, 3312);
      set_attributes(div2, div_data_2);
      add_location(div2, file73, 116, 4, 3023);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, h3);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(h3, null);
      }
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      ctx[19](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & /*title*/
        4)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        { role: "tooltip" },
        (!current || dirty & /*popperPlacement*/
        16) && {
          "x-placement": (
            /*popperPlacement*/
            ctx2[4]
          )
        }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if_blocks[current_block_type_index].d();
      ctx[19](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(116:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment74(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block28(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self, $$props, $$invalidate) {
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "animation",
    "children",
    "container",
    "dismissible",
    "isOpen",
    "placement",
    "target",
    "title",
    "trigger"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["title", "default"]);
  let { class: className = "" } = $$props;
  let { animation = true } = $$props;
  let { children: children2 = void 0 } = $$props;
  let { container = void 0 } = $$props;
  let { dismissible = false } = $$props;
  let { isOpen = false } = $$props;
  let { placement = "top" } = $$props;
  let { target = "" } = $$props;
  let { title = "" } = $$props;
  let { trigger = "click" } = $$props;
  let targetEl;
  let popoverEl;
  let popperInstance;
  let bsPlacement;
  let popperPlacement = placement;
  const checkPopperPlacement = {
    name: "checkPopperPlacement",
    enabled: true,
    phase: "main",
    fn({ state }) {
      $$invalidate(4, popperPlacement = state.placement);
    }
  };
  const open = () => $$invalidate(0, isOpen = true);
  const close = () => $$invalidate(0, isOpen = false);
  const toggle = () => $$invalidate(0, isOpen = !isOpen);
  onMount(() => {
    $$invalidate(15, targetEl = document.querySelector(`#${target}`));
    switch (trigger) {
      case "hover":
        targetEl.addEventListener("mouseover", open);
        targetEl.addEventListener("mouseleave", close);
        break;
      case "focus":
        targetEl.addEventListener("focus", open);
        targetEl.addEventListener("blur", close);
        break;
      default:
        targetEl.addEventListener("click", toggle);
        if (dismissible)
          targetEl.addEventListener("blur", close);
        break;
    }
    return () => {
      switch (trigger) {
        case "hover":
          targetEl.removeEventListener("mouseover", open);
          targetEl.removeEventListener("mouseleave", close);
          break;
        case "focus":
          targetEl.removeEventListener("focus", open);
          targetEl.removeEventListener("blur", close);
          break;
        default:
          targetEl.removeEventListener("click", toggle);
          if (dismissible)
            targetEl.removeEventListener("blur", close);
          break;
      }
    };
  });
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popoverEl = $$value;
      $$invalidate(3, popoverEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("animation" in $$new_props)
      $$invalidate(9, animation = $$new_props.animation);
    if ("children" in $$new_props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("container" in $$new_props)
      $$invalidate(10, container = $$new_props.container);
    if ("dismissible" in $$new_props)
      $$invalidate(11, dismissible = $$new_props.dismissible);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$new_props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("target" in $$new_props)
      $$invalidate(13, target = $$new_props.target);
    if ("title" in $$new_props)
      $$invalidate(2, title = $$new_props.title);
    if ("trigger" in $$new_props)
      $$invalidate(14, trigger = $$new_props.trigger);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    createPopper,
    classnames,
    InlineContainer: InlineContainer_default,
    Portal: Portal_default,
    className,
    animation,
    children: children2,
    container,
    dismissible,
    isOpen,
    placement,
    target,
    title,
    trigger,
    targetEl,
    popoverEl,
    popperInstance,
    bsPlacement,
    popperPlacement,
    checkPopperPlacement,
    open,
    close,
    toggle,
    outer,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("animation" in $$props)
      $$invalidate(9, animation = $$new_props.animation);
    if ("children" in $$props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("container" in $$props)
      $$invalidate(10, container = $$new_props.container);
    if ("dismissible" in $$props)
      $$invalidate(11, dismissible = $$new_props.dismissible);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("target" in $$props)
      $$invalidate(13, target = $$new_props.target);
    if ("title" in $$props)
      $$invalidate(2, title = $$new_props.title);
    if ("trigger" in $$props)
      $$invalidate(14, trigger = $$new_props.trigger);
    if ("targetEl" in $$props)
      $$invalidate(15, targetEl = $$new_props.targetEl);
    if ("popoverEl" in $$props)
      $$invalidate(3, popoverEl = $$new_props.popoverEl);
    if ("popperInstance" in $$props)
      $$invalidate(16, popperInstance = $$new_props.popperInstance);
    if ("bsPlacement" in $$props)
      $$invalidate(17, bsPlacement = $$new_props.bsPlacement);
    if ("popperPlacement" in $$props)
      $$invalidate(4, popperPlacement = $$new_props.popperPlacement);
    if ("outer" in $$props)
      $$invalidate(5, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isOpen, popoverEl, targetEl, placement, popperInstance*/
    102409) {
      $: {
        if (isOpen && popoverEl) {
          $$invalidate(16, popperInstance = createPopper(targetEl, popoverEl, {
            placement,
            modifiers: [
              checkPopperPlacement,
              {
                name: "offset",
                options: {
                  offset: () => {
                    return [0, 8];
                  }
                }
              }
            ]
          }));
        } else if (popperInstance) {
          popperInstance.destroy();
          $$invalidate(16, popperInstance = void 0);
        }
      }
    }
    if ($$self.$$.dirty & /*target*/
    8192) {
      $:
        if (!target) {
          throw new Error("Need target!");
        }
    }
    if ($$self.$$.dirty & /*popperPlacement*/
    16) {
      $: {
        if (popperPlacement === "left")
          $$invalidate(17, bsPlacement = "start");
        else if (popperPlacement === "right")
          $$invalidate(17, bsPlacement = "end");
        else
          $$invalidate(17, bsPlacement = popperPlacement);
      }
    }
    if ($$self.$$.dirty & /*className, animation, bsPlacement, isOpen*/
    131841) {
      $:
        $$invalidate(6, classes = classnames(className, "popover", animation ? "fade" : false, `bs-popover-${bsPlacement}`, isOpen ? "show" : false));
    }
    if ($$self.$$.dirty & /*container*/
    1024) {
      $:
        $$invalidate(5, outer = container === "inline" ? InlineContainer_default : Portal_default);
    }
  };
  return [
    isOpen,
    children2,
    title,
    popoverEl,
    popperPlacement,
    outer,
    classes,
    $$restProps,
    className,
    animation,
    container,
    dismissible,
    placement,
    target,
    trigger,
    targetEl,
    popperInstance,
    bsPlacement,
    slots,
    div2_binding,
    $$scope
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance74, create_fragment74, safe_not_equal, {
      class: 8,
      animation: 9,
      children: 1,
      container: 10,
      dismissible: 11,
      isOpen: 0,
      placement: 12,
      target: 13,
      title: 2,
      trigger: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment74.name
    });
  }
  get class() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animation() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animation(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dismissible() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dismissible(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trigger() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trigger(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popover_default = Popover;

// node_modules/sveltestrap/src/Progress.svelte
var file74 = "node_modules/sveltestrap/src/Progress.svelte";
function create_else_block_14(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_212, create_else_block_23];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*multi*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[7],
    { class: (
      /*classes*/
      ctx[6]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file74, 44, 2, 1003);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(44:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block29(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_117, create_else_block23];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*multi*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(28:0) {#if bar}",
    ctx
  });
  return block;
}
function create_else_block_23(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        style: true,
        role: true,
        "aria-valuenow": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*progressBarClasses*/
        ctx[5]
      );
      set_style(
        div,
        "width",
        /*percent*/
        ctx[4] + "%"
      );
      attr_dev(div, "role", "progressbar");
      attr_dev(
        div,
        "aria-valuenow",
        /*value*/
        ctx[2]
      );
      attr_dev(div, "aria-valuemin", "0");
      attr_dev(
        div,
        "aria-valuemax",
        /*max*/
        ctx[3]
      );
      add_location(div, file74, 48, 6, 1091);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*progressBarClasses*/
      32) {
        attr_dev(
          div,
          "class",
          /*progressBarClasses*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*percent*/
      16) {
        set_style(
          div,
          "width",
          /*percent*/
          ctx2[4] + "%"
        );
      }
      if (!current || dirty & /*value*/
      4) {
        attr_dev(
          div,
          "aria-valuenow",
          /*value*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*max*/
      8) {
        attr_dev(
          div,
          "aria-valuemax",
          /*max*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_23.name,
    type: "else",
    source: "(48:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_212(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(46:4) {#if multi}",
    ctx
  });
  return block;
}
function create_else_block23(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[7],
    { class: (
      /*progressBarClasses*/
      ctx[5]
    ) },
    {
      style: div_style_value = "width: " + /*percent*/
      ctx[4] + "%"
    },
    { role: "progressbar" },
    { "aria-valuenow": (
      /*value*/
      ctx[2]
    ) },
    { "aria-valuemin": "0" },
    { "aria-valuemax": (
      /*max*/
      ctx[3]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        style: true,
        role: true,
        "aria-valuenow": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file74, 31, 4, 757);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        (!current || dirty & /*progressBarClasses*/
        32) && { class: (
          /*progressBarClasses*/
          ctx2[5]
        ) },
        (!current || dirty & /*percent*/
        16 && div_style_value !== (div_style_value = "width: " + /*percent*/
        ctx2[4] + "%")) && { style: div_style_value },
        { role: "progressbar" },
        (!current || dirty & /*value*/
        4) && { "aria-valuenow": (
          /*value*/
          ctx2[2]
        ) },
        { "aria-valuemin": "0" },
        (!current || dirty & /*max*/
        8) && { "aria-valuemax": (
          /*max*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block23.name,
    type: "else",
    source: "(31:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_117(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(29:2) {#if multi}",
    ctx
  });
  return block;
}
function create_fragment75(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block29, create_else_block_14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*bar*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance75($$self, $$props, $$invalidate) {
  let classes;
  let progressBarClasses;
  let percent;
  const omit_props_names = [
    "class",
    "bar",
    "multi",
    "value",
    "max",
    "animated",
    "striped",
    "color",
    "barClassName"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Progress", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { bar = false } = $$props;
  let { multi = false } = $$props;
  let { value = 0 } = $$props;
  let { max = 100 } = $$props;
  let { animated = false } = $$props;
  let { striped = false } = $$props;
  let { color = "" } = $$props;
  let { barClassName = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("bar" in $$new_props)
      $$invalidate(0, bar = $$new_props.bar);
    if ("multi" in $$new_props)
      $$invalidate(1, multi = $$new_props.multi);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("max" in $$new_props)
      $$invalidate(3, max = $$new_props.max);
    if ("animated" in $$new_props)
      $$invalidate(9, animated = $$new_props.animated);
    if ("striped" in $$new_props)
      $$invalidate(10, striped = $$new_props.striped);
    if ("color" in $$new_props)
      $$invalidate(11, color = $$new_props.color);
    if ("barClassName" in $$new_props)
      $$invalidate(12, barClassName = $$new_props.barClassName);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    bar,
    multi,
    value,
    max,
    animated,
    striped,
    color,
    barClassName,
    percent,
    progressBarClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("bar" in $$props)
      $$invalidate(0, bar = $$new_props.bar);
    if ("multi" in $$props)
      $$invalidate(1, multi = $$new_props.multi);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("max" in $$props)
      $$invalidate(3, max = $$new_props.max);
    if ("animated" in $$props)
      $$invalidate(9, animated = $$new_props.animated);
    if ("striped" in $$props)
      $$invalidate(10, striped = $$new_props.striped);
    if ("color" in $$props)
      $$invalidate(11, color = $$new_props.color);
    if ("barClassName" in $$props)
      $$invalidate(12, barClassName = $$new_props.barClassName);
    if ("percent" in $$props)
      $$invalidate(4, percent = $$new_props.percent);
    if ("progressBarClasses" in $$props)
      $$invalidate(5, progressBarClasses = $$new_props.progressBarClasses);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    256) {
      $:
        $$invalidate(6, classes = classnames(className, "progress"));
    }
    if ($$self.$$.dirty & /*bar, className, barClassName, animated, color, striped*/
    7937) {
      $:
        $$invalidate(5, progressBarClasses = classnames("progress-bar", bar ? className || barClassName : barClassName, animated ? "progress-bar-animated" : null, color ? `text-bg-${color}` : null, striped || animated ? "progress-bar-striped" : null));
    }
    if ($$self.$$.dirty & /*value, max*/
    12) {
      $:
        $$invalidate(4, percent = parseInt(value, 10) / parseInt(max, 10) * 100);
    }
  };
  return [
    bar,
    multi,
    value,
    max,
    percent,
    progressBarClasses,
    classes,
    $$restProps,
    className,
    animated,
    striped,
    color,
    barClassName,
    $$scope,
    slots
  ];
}
var Progress = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, {
      class: 8,
      bar: 0,
      multi: 1,
      value: 2,
      max: 3,
      animated: 9,
      striped: 10,
      color: 11,
      barClassName: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Progress",
      options,
      id: create_fragment75.name
    });
  }
  get class() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bar() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bar(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multi() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multi(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animated() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animated(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get striped() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set striped(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get barClassName() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set barClassName(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Progress_default = Progress;

// node_modules/sveltestrap/src/Row.svelte
var file75 = "node_modules/sveltestrap/src/Row.svelte";
function create_fragment76(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file75, 40, 0, 1012);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[9](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getCols(cols) {
  const colsValue = parseInt(cols);
  if (!isNaN(colsValue)) {
    if (colsValue > 0) {
      return [`row-cols-${colsValue}`];
    }
  } else if (typeof cols === "object") {
    return ["xs", "sm", "md", "lg", "xl"].map((colWidth) => {
      const isXs = colWidth === "xs";
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      const value = cols[colWidth];
      if (typeof value === "number" && value > 0) {
        return `row-cols${colSizeInterfix}${value}`;
      }
      return null;
    }).filter((value) => !!value);
  }
  return [];
}
function instance76($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "noGutters", "form", "cols", "inner"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { noGutters = false } = $$props;
  let { form = false } = $$props;
  let { cols = 0 } = $$props;
  let { inner = void 0 } = $$props;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("noGutters" in $$new_props)
      $$invalidate(4, noGutters = $$new_props.noGutters);
    if ("form" in $$new_props)
      $$invalidate(5, form = $$new_props.form);
    if ("cols" in $$new_props)
      $$invalidate(6, cols = $$new_props.cols);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    noGutters,
    form,
    cols,
    inner,
    getCols,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("noGutters" in $$props)
      $$invalidate(4, noGutters = $$new_props.noGutters);
    if ("form" in $$props)
      $$invalidate(5, form = $$new_props.form);
    if ("cols" in $$props)
      $$invalidate(6, cols = $$new_props.cols);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, noGutters, form, cols*/
    120) {
      $:
        $$invalidate(1, classes = classnames(className, noGutters ? "gx-0" : null, form ? "form-row" : "row", ...getCols(cols)));
    }
  };
  return [
    inner,
    classes,
    $$restProps,
    className,
    noGutters,
    form,
    cols,
    $$scope,
    slots,
    div_binding
  ];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance76, create_fragment76, safe_not_equal, {
      class: 3,
      noGutters: 4,
      form: 5,
      cols: 6,
      inner: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment76.name
    });
  }
  get class() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutters() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutters(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get form() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cols() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cols(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Row_default = Row;

// node_modules/sveltestrap/src/Spinner.svelte
var file76 = "node_modules/sveltestrap/src/Spinner.svelte";
function fallback_block9(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Loading...");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Loading...");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block9.name,
    type: "fallback",
    source: "(20:10) Loading...",
    ctx
  });
  return block;
}
function create_fragment77(ctx) {
  let div;
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block9(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { role: "status" },
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true, class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file76, 18, 2, 399);
      set_attributes(div, div_data);
      add_location(div, file76, 17, 0, 344);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        { role: "status" },
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "type", "size", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Spinner", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { type = "border" } = $$props;
  let { size = "" } = $$props;
  let { color = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("type" in $$new_props)
      $$invalidate(3, type = $$new_props.type);
    if ("size" in $$new_props)
      $$invalidate(4, size = $$new_props.size);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    type,
    size,
    color,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("type" in $$props)
      $$invalidate(3, type = $$new_props.type);
    if ("size" in $$props)
      $$invalidate(4, size = $$new_props.size);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, size, type, color*/
    60) {
      $:
        $$invalidate(0, classes = classnames(className, size ? `spinner-${type}-${size}` : false, `spinner-${type}`, color ? `text-${color}` : false));
    }
  };
  return [classes, $$restProps, className, type, size, color, $$scope, slots];
}
var Spinner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, { class: 2, type: 3, size: 4, color: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Spinner",
      options,
      id: create_fragment77.name
    });
  }
  get class() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Spinner_default = Spinner;

// node_modules/sveltestrap/src/Styles.svelte
var { document: document_12 } = globals;
var file77 = "node_modules/sveltestrap/src/Styles.svelte";
function create_if_block30(ctx) {
  let link;
  const block = {
    c: function create() {
      link = element("link");
      this.h();
    },
    l: function claim(nodes) {
      link = claim_element(nodes, "LINK", { rel: true, href: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(link, "rel", "stylesheet");
      attr_dev(link, "href", "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css");
      add_location(link, file77, 22, 4, 565);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, link, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(link);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(22:2) {#if icons}",
    ctx
  });
  return block;
}
function create_fragment78(ctx) {
  let link;
  let if_block_anchor;
  let if_block = (
    /*icons*/
    ctx[0] && create_if_block30(ctx)
  );
  const block = {
    c: function create() {
      link = element("link");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-xjd33q", document_12.head);
      link = claim_element(head_nodes, "LINK", { rel: true, href: true });
      if (if_block)
        if_block.l(head_nodes);
      if_block_anchor = empty();
      head_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(link, "rel", "stylesheet");
      attr_dev(link, "href", "https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css");
      add_location(link, file77, 17, 2, 432);
    },
    m: function mount(target, anchor) {
      append_hydration_dev(document_12.head, link);
      if (if_block)
        if_block.m(document_12.head, null);
      append_hydration_dev(document_12.head, if_block_anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*icons*/
        ctx2[0]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block30(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      detach_dev(link);
      if (if_block)
        if_block.d(detaching);
      detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Styles", slots, []);
  let { icons = true } = $$props;
  let { theme = void 0 } = $$props;
  const writable_props = ["icons", "theme"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Styles> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icons" in $$props2)
      $$invalidate(0, icons = $$props2.icons);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
  };
  $$self.$capture_state = () => ({ icons, theme });
  $$self.$inject_state = ($$props2) => {
    if ("icons" in $$props2)
      $$invalidate(0, icons = $$props2.icons);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*theme*/
    2) {
      $:
        if (typeof document !== "undefined" && theme !== void 0) {
          if (theme === "auto" && window.matchMedia("(prefers-color-scheme: dark)").matches) {
            document.documentElement.setAttribute("data-bs-theme", "dark");
          } else {
            document.documentElement.setAttribute("data-bs-theme", theme);
          }
        }
    }
  };
  return [icons, theme];
}
var Styles = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, { icons: 0, theme: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Styles",
      options,
      id: create_fragment78.name
    });
  }
  get icons() {
    throw new Error("<Styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons(value) {
    throw new Error("<Styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Styles_default = Styles;

// node_modules/sveltestrap/src/Colgroup.svelte
var file78 = "node_modules/sveltestrap/src/Colgroup.svelte";
function create_fragment79(ctx) {
  let colgroup;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      colgroup = element("colgroup");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      colgroup = claim_element(nodes, "COLGROUP", {});
      var colgroup_nodes = children(colgroup);
      if (default_slot)
        default_slot.l(colgroup_nodes);
      colgroup_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(colgroup, file78, 6, 0, 92);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, colgroup, anchor);
      if (default_slot) {
        default_slot.m(colgroup, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(colgroup);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Colgroup", slots, ["default"]);
  setContext("colgroup", true);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Colgroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$scope, slots];
}
var Colgroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment79, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Colgroup",
      options,
      id: create_fragment79.name
    });
  }
};
var Colgroup_default = Colgroup;

// node_modules/sveltestrap/src/ResponsiveContainer.svelte
var file79 = "node_modules/sveltestrap/src/ResponsiveContainer.svelte";
function create_else_block24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block24.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block31(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*responsiveClassName*/
        ctx[1]
      );
      add_location(div, file79, 14, 2, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*responsiveClassName*/
      2) {
        attr_dev(
          div,
          "class",
          /*responsiveClassName*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(14:0) {#if responsive}",
    ctx
  });
  return block;
}
function create_fragment80(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block31, create_else_block24];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*responsive*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  let responsiveClassName;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ResponsiveContainer", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { responsive = false } = $$props;
  const writable_props = ["class", "responsive"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ResponsiveContainer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(2, className = $$props2.class);
    if ("responsive" in $$props2)
      $$invalidate(0, responsive = $$props2.responsive);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    responsive,
    responsiveClassName
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("responsive" in $$props2)
      $$invalidate(0, responsive = $$props2.responsive);
    if ("responsiveClassName" in $$props2)
      $$invalidate(1, responsiveClassName = $$props2.responsiveClassName);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, responsive*/
    5) {
      $:
        $$invalidate(1, responsiveClassName = classnames(className, {
          "table-responsive": responsive === true,
          [`table-responsive-${responsive}`]: typeof responsive === "string"
        }));
    }
  };
  return [responsive, responsiveClassName, className, $$scope, slots];
}
var ResponsiveContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, { class: 2, responsive: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ResponsiveContainer",
      options,
      id: create_fragment80.name
    });
  }
  get class() {
    throw new Error("<ResponsiveContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ResponsiveContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get responsive() {
    throw new Error("<ResponsiveContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set responsive(value) {
    throw new Error("<ResponsiveContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ResponsiveContainer_default = ResponsiveContainer;

// node_modules/sveltestrap/src/TableFooter.svelte
var file80 = "node_modules/sveltestrap/src/TableFooter.svelte";
function create_fragment81(ctx) {
  let tfoot;
  let tr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let tfoot_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let tfoot_data = {};
  for (let i = 0; i < tfoot_levels.length; i += 1) {
    tfoot_data = assign(tfoot_data, tfoot_levels[i]);
  }
  const block = {
    c: function create() {
      tfoot = element("tfoot");
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      tfoot = claim_element(nodes, "TFOOT", {});
      var tfoot_nodes = children(tfoot);
      tr = claim_element(tfoot_nodes, "TR", {});
      var tr_nodes = children(tr);
      if (default_slot)
        default_slot.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      tfoot_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file80, 7, 2, 117);
      set_attributes(tfoot, tfoot_data);
      add_location(tfoot, file80, 6, 0, 90);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tfoot, anchor);
      append_hydration_dev(tfoot, tr);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(tfoot, tfoot_data = get_spread_update(tfoot_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tfoot);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance81($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableFooter", slots, ["default"]);
  setContext("footer", true);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$restProps, $$scope, slots];
}
var TableFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment81, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableFooter",
      options,
      id: create_fragment81.name
    });
  }
};
var TableFooter_default = TableFooter;

// node_modules/sveltestrap/src/TableHeader.svelte
var file81 = "node_modules/sveltestrap/src/TableHeader.svelte";
function create_fragment82(ctx) {
  let thead;
  let tr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let thead_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let thead_data = {};
  for (let i = 0; i < thead_levels.length; i += 1) {
    thead_data = assign(thead_data, thead_levels[i]);
  }
  const block = {
    c: function create() {
      thead = element("thead");
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      thead = claim_element(nodes, "THEAD", {});
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", {});
      var tr_nodes = children(tr);
      if (default_slot)
        default_slot.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file81, 7, 2, 117);
      set_attributes(thead, thead_data);
      add_location(thead, file81, 6, 0, 90);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, thead, anchor);
      append_hydration_dev(thead, tr);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(thead);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableHeader", slots, ["default"]);
  setContext("header", true);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$restProps, $$scope, slots];
}
var TableHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableHeader",
      options,
      id: create_fragment82.name
    });
  }
};
var TableHeader_default = TableHeader;

// node_modules/sveltestrap/src/Table.svelte
var file82 = "node_modules/sveltestrap/src/Table.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
var get_default_slot_changes_1 = (dirty) => ({ row: dirty & /*rows*/
2 });
var get_default_slot_context_1 = (ctx) => ({ row: (
  /*row*/
  ctx[12]
) });
var get_default_slot_changes = (dirty) => ({ row: dirty & /*rows*/
2 });
var get_default_slot_context = (ctx) => ({ row: (
  /*row*/
  ctx[12]
) });
function create_else_block25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block25.name,
    type: "else",
    source: "(48:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block32(ctx) {
  let colgroup;
  let t0;
  let tableheader;
  let t1;
  let tbody;
  let t2;
  let tablefooter;
  let current;
  colgroup = new Colgroup_default({
    props: {
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tableheader = new TableHeader_default({
    props: {
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let each_value = (
    /*rows*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  tablefooter = new TableFooter_default({
    props: {
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(colgroup.$$.fragment);
      t0 = space();
      create_component(tableheader.$$.fragment);
      t1 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      create_component(tablefooter.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      claim_component(colgroup.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(tableheader.$$.fragment, nodes);
      t1 = claim_space(nodes);
      tbody = claim_element(nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      claim_component(tablefooter.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      add_location(tbody, file82, 37, 6, 997);
    },
    m: function mount(target, anchor) {
      mount_component(colgroup, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(tableheader, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, tbody, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      insert_hydration_dev(target, t2, anchor);
      mount_component(tablefooter, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const colgroup_changes = {};
      if (dirty & /*$$scope*/
      2048) {
        colgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      colgroup.$set(colgroup_changes);
      const tableheader_changes = {};
      if (dirty & /*$$scope, rows*/
      2050) {
        tableheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tableheader.$set(tableheader_changes);
      if (dirty & /*$$scope, rows*/
      2050) {
        each_value = /*rows*/
        ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tbody, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const tablefooter_changes = {};
      if (dirty & /*$$scope*/
      2048) {
        tablefooter_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablefooter.$set(tablefooter_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(colgroup.$$.fragment, local);
      transition_in(tableheader.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(tablefooter.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(colgroup.$$.fragment, local);
      transition_out(tableheader.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(tablefooter.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(colgroup, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(tableheader, detaching);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(tbody);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(tablefooter, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block32.name,
    type: "if",
    source: "(31:4) {#if rows}",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: "(32:6) <Colgroup>",
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, rows*/
        2050)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(35:6) <TableHeader>",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let tr;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context_1
  );
  const block = {
    c: function create() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      if (default_slot)
        default_slot.l(tr_nodes);
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file82, 39, 10, 1043);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      append_hydration_dev(tr, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, rows*/
        2050)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(39:8) {#each rows as row}",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(45:6) <TableFooter>",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let table;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block32, create_else_block25];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*rows*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let table_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let table_data = {};
  for (let i = 0; i < table_levels.length; i += 1) {
    table_data = assign(table_data, table_levels[i]);
  }
  const block = {
    c: function create() {
      table = element("table");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      if_block.l(table_nodes);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(table, table_data);
      add_location(table, file82, 29, 2, 825);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      if_blocks[current_block_type_index].m(table, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(table, null);
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(29:0) <ResponsiveContainer {responsive}>",
    ctx
  });
  return block;
}
function create_fragment83(ctx) {
  let responsivecontainer;
  let current;
  responsivecontainer = new ResponsiveContainer_default({
    props: {
      responsive: (
        /*responsive*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(responsivecontainer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(responsivecontainer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(responsivecontainer, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const responsivecontainer_changes = {};
      if (dirty & /*responsive*/
      1)
        responsivecontainer_changes.responsive = /*responsive*/
        ctx2[0];
      if (dirty & /*$$scope, $$restProps, classes, rows*/
      2062) {
        responsivecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      responsivecontainer.$set(responsivecontainer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(responsivecontainer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(responsivecontainer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(responsivecontainer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "size", "bordered", "borderless", "striped", "hover", "responsive", "rows"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { size = "" } = $$props;
  let { bordered = false } = $$props;
  let { borderless = false } = $$props;
  let { striped = false } = $$props;
  let { hover = false } = $$props;
  let { responsive = false } = $$props;
  let { rows = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(5, size = $$new_props.size);
    if ("bordered" in $$new_props)
      $$invalidate(6, bordered = $$new_props.bordered);
    if ("borderless" in $$new_props)
      $$invalidate(7, borderless = $$new_props.borderless);
    if ("striped" in $$new_props)
      $$invalidate(8, striped = $$new_props.striped);
    if ("hover" in $$new_props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("responsive" in $$new_props)
      $$invalidate(0, responsive = $$new_props.responsive);
    if ("rows" in $$new_props)
      $$invalidate(1, rows = $$new_props.rows);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    Colgroup: Colgroup_default,
    ResponsiveContainer: ResponsiveContainer_default,
    TableFooter: TableFooter_default,
    TableHeader: TableHeader_default,
    className,
    size,
    bordered,
    borderless,
    striped,
    hover,
    responsive,
    rows,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(5, size = $$new_props.size);
    if ("bordered" in $$props)
      $$invalidate(6, bordered = $$new_props.bordered);
    if ("borderless" in $$props)
      $$invalidate(7, borderless = $$new_props.borderless);
    if ("striped" in $$props)
      $$invalidate(8, striped = $$new_props.striped);
    if ("hover" in $$props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("responsive" in $$props)
      $$invalidate(0, responsive = $$new_props.responsive);
    if ("rows" in $$props)
      $$invalidate(1, rows = $$new_props.rows);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, size, bordered, borderless, striped, hover*/
    1008) {
      $:
        $$invalidate(2, classes = classnames(className, "table", size ? "table-" + size : false, bordered ? "table-bordered" : false, borderless ? "table-borderless" : false, striped ? "table-striped" : false, hover ? "table-hover" : false));
    }
  };
  return [
    responsive,
    rows,
    classes,
    $$restProps,
    className,
    size,
    bordered,
    borderless,
    striped,
    hover,
    slots,
    $$scope
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, {
      class: 4,
      size: 5,
      bordered: 6,
      borderless: 7,
      striped: 8,
      hover: 9,
      responsive: 0,
      rows: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment83.name
    });
  }
  get class() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bordered() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bordered(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderless() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderless(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get striped() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set striped(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get responsive() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set responsive(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/sveltestrap/src/TabHeader.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(8:0) <Nav {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let nav;
  let current;
  const nav_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let nav_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < nav_spread_levels.length; i += 1) {
    nav_props = assign(nav_props, nav_spread_levels[i]);
  }
  nav = new Nav_default({ props: nav_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(nav.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(nav.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(nav, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const nav_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(nav_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        nav_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nav.$set(nav_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(nav.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(nav.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(nav, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance84($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabHeader", slots, ["default"]);
  setContext("tabs", true);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext, Nav: Nav_default });
  return [$$restProps, slots, $$scope];
}
var TabHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment84, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabHeader",
      options,
      id: create_fragment84.name
    });
  }
};
var TabHeader_default = TabHeader;

// node_modules/sveltestrap/src/TabContent.svelte
var file83 = "node_modules/sveltestrap/src/TabContent.svelte";
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(29:2) <TabHeader     class={classnames({ 'me-3': vertical })}     {pills}     tabs={!pills}     {vertical}   >",
    ctx
  });
  return block;
}
function create_fragment85(ctx) {
  let div;
  let tabheader;
  let t;
  let current;
  tabheader = new TabHeader_default({
    props: {
      class: classnames({ "me-3": (
        /*vertical*/
        ctx[1]
      ) }),
      pills: (
        /*pills*/
        ctx[0]
      ),
      tabs: !/*pills*/
      ctx[0],
      vertical: (
        /*vertical*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(tabheader.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(tabheader.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file83, 27, 0, 653);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(tabheader, div, null);
      append_hydration_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const tabheader_changes = {};
      if (dirty & /*vertical*/
      2)
        tabheader_changes.class = classnames({ "me-3": (
          /*vertical*/
          ctx2[1]
        ) });
      if (dirty & /*pills*/
      1)
        tabheader_changes.pills = /*pills*/
        ctx2[0];
      if (dirty & /*pills*/
      1)
        tabheader_changes.tabs = !/*pills*/
        ctx2[0];
      if (dirty & /*vertical*/
      2)
        tabheader_changes.vertical = /*vertical*/
        ctx2[1];
      if (dirty & /*$$scope*/
      64) {
        tabheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabheader.$set(tabheader_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabheader.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabheader.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(tabheader);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "pills", "vertical"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabContent", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { pills = false } = $$props;
  let { vertical = false } = $$props;
  const activeTabId = writable();
  setContext("tabContent", {
    activeTabId,
    setActiveTab: (tabId) => {
      activeTabId.set(tabId);
      dispatch("tab", tabId);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("pills" in $$new_props)
      $$invalidate(0, pills = $$new_props.pills);
    if ("vertical" in $$new_props)
      $$invalidate(1, vertical = $$new_props.vertical);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    writable,
    classnames,
    TabHeader: TabHeader_default,
    dispatch,
    className,
    pills,
    vertical,
    activeTabId,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("pills" in $$props)
      $$invalidate(0, pills = $$new_props.pills);
    if ("vertical" in $$props)
      $$invalidate(1, vertical = $$new_props.vertical);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, vertical*/
    18) {
      $:
        $$invalidate(2, classes = classnames("tab-content", className, { "d-flex align-items-start": vertical }));
    }
  };
  return [pills, vertical, classes, $$restProps, className, slots, $$scope];
}
var TabContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, { class: 4, pills: 0, vertical: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabContent",
      options,
      id: create_fragment85.name
    });
  }
  get class() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pills() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pills(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabContent_default = TabContent;

// node_modules/sveltestrap/src/TabPane.svelte
var file84 = "node_modules/sveltestrap/src/TabPane.svelte";
var get_tab_slot_changes = (dirty) => ({});
var get_tab_slot_context = (ctx) => ({});
function create_else_block26(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file84, 36, 2, 914);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block26.name,
    type: "else",
    source: "(36:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block33(ctx) {
  let navitem;
  let current;
  navitem = new NavItem_default({
    props: {
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(navitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(navitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(navitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navitem_changes = {};
      if (dirty & /*$$scope, tabOpen, disabled, tabId, tab*/
      16399) {
        navitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navitem.$set(navitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block33.name,
    type: "if",
    source: "(29:0) {#if tabs}",
    ctx
  });
  return block;
}
function create_if_block_118(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*tab*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*tab*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tab*/
      2)
        set_data_dev(
          t,
          /*tab*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_118.name,
    type: "if",
    source: "(32:6) {#if tab}",
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let t;
  let current;
  let if_block = (
    /*tab*/
    ctx[1] && create_if_block_118(ctx)
  );
  const tab_slot_template = (
    /*#slots*/
    ctx[12].tab
  );
  const tab_slot = create_slot(
    tab_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_tab_slot_context
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (tab_slot)
        tab_slot.c();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      if (tab_slot)
        tab_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (tab_slot) {
        tab_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*tab*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_118(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (tab_slot) {
        if (tab_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            tab_slot,
            tab_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              tab_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_tab_slot_changes
            ),
            get_tab_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tab_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tab_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (tab_slot)
        tab_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: "(31:4) <NavLink active={tabOpen} {disabled} on:click={() => setActiveTab(tabId)}>",
    ctx
  });
  return block;
}
function create_default_slot11(ctx) {
  let navlink;
  let current;
  navlink = new NavLink_default({
    props: {
      active: (
        /*tabOpen*/
        ctx[3]
      ),
      disabled: (
        /*disabled*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  navlink.$on(
    "click",
    /*click_handler*/
    ctx[13]
  );
  const block = {
    c: function create() {
      create_component(navlink.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(navlink.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(navlink, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navlink_changes = {};
      if (dirty & /*tabOpen*/
      8)
        navlink_changes.active = /*tabOpen*/
        ctx2[3];
      if (dirty & /*disabled*/
      1)
        navlink_changes.disabled = /*disabled*/
        ctx2[0];
      if (dirty & /*$$scope, tab*/
      16386) {
        navlink_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navlink.$set(navlink_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navlink.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navlink.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navlink, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(30:2) <NavItem>",
    ctx
  });
  return block;
}
function create_fragment86(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block33, create_else_block26];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tabs*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled", "tab", "tabId"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $activeTabId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabPane", slots, ["tab", "default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { tab = void 0 } = $$props;
  let { tabId = void 0 } = $$props;
  const tabs = getContext("tabs");
  const { activeTabId, setActiveTab } = getContext("tabContent");
  validate_store(activeTabId, "activeTabId");
  component_subscribe($$self, activeTabId, (value) => $$invalidate(11, $activeTabId = value));
  onMount(() => {
    if (active)
      setActiveTab(tabId);
  });
  let tabOpen = active;
  const click_handler = () => setActiveTab(tabId);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(10, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("tab" in $$new_props)
      $$invalidate(1, tab = $$new_props.tab);
    if ("tabId" in $$new_props)
      $$invalidate(2, tabId = $$new_props.tabId);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    NavItem: NavItem_default,
    NavLink: NavLink_default,
    classnames,
    className,
    active,
    disabled,
    tab,
    tabId,
    tabs,
    activeTabId,
    setActiveTab,
    tabOpen,
    classes,
    $activeTabId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(10, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("tab" in $$props)
      $$invalidate(1, tab = $$new_props.tab);
    if ("tabId" in $$props)
      $$invalidate(2, tabId = $$new_props.tabId);
    if ("tabOpen" in $$props)
      $$invalidate(3, tabOpen = $$new_props.tabOpen);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$activeTabId, tabId*/
    2052) {
      $:
        if ($activeTabId !== void 0)
          $$invalidate(3, tabOpen = $activeTabId === tabId);
    }
    if ($$self.$$.dirty & /*className, tabOpen*/
    520) {
      $:
        $$invalidate(4, classes = classnames("tab-pane", className, { active: tabOpen, show: tabOpen }));
    }
  };
  return [
    disabled,
    tab,
    tabId,
    tabOpen,
    classes,
    tabs,
    activeTabId,
    setActiveTab,
    $$restProps,
    className,
    active,
    $activeTabId,
    slots,
    click_handler,
    $$scope
  ];
}
var TabPane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, {
      class: 9,
      active: 10,
      disabled: 0,
      tab: 1,
      tabId: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabPane",
      options,
      id: create_fragment86.name
    });
  }
  get class() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tab() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tab(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabId() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabId(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabPane_default = TabPane;

// node_modules/sveltestrap/src/ToastBody.svelte
var file85 = "node_modules/sveltestrap/src/ToastBody.svelte";
function create_fragment87(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file85, 9, 0, 165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance87($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "toast-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ToastBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastBody",
      options,
      id: create_fragment87.name
    });
  }
  get class() {
    throw new Error("<ToastBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToastBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastBody_default = ToastBody;

// node_modules/sveltestrap/src/ToastHeader.svelte
var file86 = "node_modules/sveltestrap/src/ToastHeader.svelte";
var get_close_slot_changes3 = (dirty) => ({});
var get_close_slot_context3 = (ctx) => ({});
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx) => ({});
function create_else_block27(ctx) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[8].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_icon_slot_context
  );
  const block = {
    c: function create() {
      if (icon_slot)
        icon_slot.c();
    },
    l: function claim(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_icon_slot_changes
            ),
            get_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block27.name,
    type: "else",
    source: "(29:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_119(ctx) {
  let svg;
  let rect;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        width: true,
        height: true,
        xmlns: true,
        preserveAspectRatio: true,
        focusable: true,
        role: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", { fill: true, width: true, height: true });
      children(rect).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "fill", "currentColor");
      attr_dev(rect, "width", "100%");
      attr_dev(rect, "height", "100%");
      add_location(rect, file86, 26, 6, 640);
      attr_dev(svg, "class", svg_class_value = `rounded text-${/*icon*/
      ctx[0]}`);
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "preserveAspectRatio", "xMidYMid slice");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "role", "img");
      add_location(svg, file86, 17, 4, 426);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      1 && svg_class_value !== (svg_class_value = `rounded text-${/*icon*/
      ctx2[0]}`)) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_119.name,
    type: "if",
    source: "(17:2) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block34(ctx) {
  let current;
  const close_slot_template = (
    /*#slots*/
    ctx[8].close
  );
  const close_slot = create_slot(
    close_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_close_slot_context3
  );
  const close_slot_or_fallback = close_slot || fallback_block10(ctx);
  const block = {
    c: function create() {
      if (close_slot_or_fallback)
        close_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (close_slot_or_fallback)
        close_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (close_slot_or_fallback) {
        close_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (close_slot) {
        if (close_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              close_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_close_slot_changes3
            ),
            get_close_slot_context3
          );
        }
      } else {
        if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/
        6)) {
          close_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(close_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (close_slot_or_fallback)
        close_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block34.name,
    type: "if",
    source: "(35:2) {#if toggle}",
    ctx
  });
  return block;
}
function fallback_block10(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      close: true,
      "aria-label": (
        /*closeAriaLabel*/
        ctx[2]
      )
    },
    $$inline: true
  });
  button.$on("click", function() {
    if (is_function(
      /*toggle*/
      ctx[1]
    ))
      ctx[1].apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*closeAriaLabel*/
      4)
        button_changes["aria-label"] = /*closeAriaLabel*/
        ctx[2];
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block10.name,
    type: "fallback",
    source: "(36:23)        ",
    ctx
  });
  return block;
}
function create_fragment88(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t0;
  let strong;
  let t1;
  let current;
  const if_block_creators = [create_if_block_119, create_else_block27];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*icon*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let if_block1 = (
    /*toggle*/
    ctx[1] && create_if_block34(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t0 = space();
      strong = element("strong");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      strong = claim_element(div_nodes, "STRONG", { class: true });
      var strong_nodes = children(strong);
      if (default_slot)
        default_slot.l(strong_nodes);
      strong_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        strong,
        "class",
        /*tagClassName*/
        ctx[3]
      );
      add_location(strong, file86, 31, 2, 752);
      set_attributes(div, div_data);
      add_location(div, file86, 15, 0, 370);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, strong);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      append_hydration_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t0);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*tagClassName*/
      8) {
        attr_dev(
          strong,
          "class",
          /*tagClassName*/
          ctx2[3]
        );
      }
      if (
        /*toggle*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*toggle*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block34(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance88($$self, $$props, $$invalidate) {
  let classes;
  let tagClassName;
  const omit_props_names = ["class", "icon", "toggle", "closeAriaLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastHeader", slots, ["icon", "default", "close"]);
  let { class: className = "" } = $$props;
  let { icon = null } = $$props;
  let { toggle = null } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("icon" in $$new_props)
      $$invalidate(0, icon = $$new_props.icon);
    if ("toggle" in $$new_props)
      $$invalidate(1, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    Button: Button_default,
    className,
    icon,
    toggle,
    closeAriaLabel,
    tagClassName,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("icon" in $$props)
      $$invalidate(0, icon = $$new_props.icon);
    if ("toggle" in $$props)
      $$invalidate(1, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("tagClassName" in $$props)
      $$invalidate(3, tagClassName = $$new_props.tagClassName);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    64) {
      $:
        $$invalidate(4, classes = classnames(className, "toast-header"));
    }
    if ($$self.$$.dirty & /*icon*/
    1) {
      $:
        $$invalidate(3, tagClassName = classnames("me-auto", { "ms-2": icon != null }));
    }
  };
  return [
    icon,
    toggle,
    closeAriaLabel,
    tagClassName,
    classes,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var ToastHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {
      class: 6,
      icon: 0,
      toggle: 1,
      closeAriaLabel: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastHeader",
      options,
      id: create_fragment88.name
    });
  }
  get class() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastHeader_default = ToastHeader;

// node_modules/sveltestrap/src/Toast.svelte
var file87 = "node_modules/sveltestrap/src/Toast.svelte";
function create_if_block35(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block1;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*header*/
    ctx[4] && create_if_block_213(ctx)
  );
  const if_block_creators = [create_if_block_120, create_else_block28];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*body*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[6]
    ) },
    { role: "alert" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file87, 36, 2, 863);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "introstart",
            /*introstart_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            /*introend_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            /*outrostart_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            /*outroend_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*header*/
        ctx[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*header*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_213(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx[8],
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx[6]
        ) },
        { role: "alert" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            fade,
            {
              duration: (
                /*fade*/
                ctx[3] && /*duration*/
                ctx[2]
              )
            },
            true
          );
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      if (!div_transition)
        div_transition = create_bidirectional_transition(
          div,
          fade,
          {
            duration: (
              /*fade*/
              ctx[3] && /*duration*/
              ctx[2]
            )
          },
          false
        );
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block35.name,
    type: "if",
    source: "(36:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_if_block_213(ctx) {
  let toastheader;
  let current;
  toastheader = new ToastHeader_default({
    props: {
      toggle: (
        /*toggle*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toastheader.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toastheader.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toastheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toastheader_changes = {};
      if (dirty & /*toggle*/
      32)
        toastheader_changes.toggle = /*toggle*/
        ctx2[5];
      if (dirty & /*$$scope, header*/
      131088) {
        toastheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toastheader.$set(toastheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toastheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(47:4) {#if header}",
    ctx
  });
  return block;
}
function create_default_slot_17(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*header*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*header*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*header*/
      16)
        set_data_dev(
          t,
          /*header*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: "(48:6) <ToastHeader {toggle}>",
    ctx
  });
  return block;
}
function create_else_block28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block28.name,
    type: "else",
    source: "(56:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_120(ctx) {
  let toastbody;
  let current;
  toastbody = new ToastBody_default({
    props: {
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toastbody.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toastbody.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toastbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toastbody_changes = {};
      if (dirty & /*$$scope*/
      131072) {
        toastbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toastbody.$set(toastbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toastbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_120.name,
    type: "if",
    source: "(52:4) {#if body}",
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(53:6) <ToastBody>",
    ctx
  });
  return block;
}
function create_fragment89(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block35(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block35(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance89($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "autohide", "body", "delay", "duration", "fade", "header", "isOpen", "toggle"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toast", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { autohide = false } = $$props;
  let { body = false } = $$props;
  let { delay = 5e3 } = $$props;
  let { duration = 200 } = $$props;
  let { fade: fade2 = true } = $$props;
  let { header = void 0 } = $$props;
  let { isOpen = true } = $$props;
  let { toggle = null } = $$props;
  let timeout;
  onDestroy(() => {
    return () => clearTimeout(timeout);
  });
  const introstart_handler = () => dispatch("opening");
  const introend_handler = () => dispatch("open");
  const outrostart_handler = () => dispatch("closing");
  const outroend_handler = () => dispatch("close");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("autohide" in $$new_props)
      $$invalidate(10, autohide = $$new_props.autohide);
    if ("body" in $$new_props)
      $$invalidate(1, body = $$new_props.body);
    if ("delay" in $$new_props)
      $$invalidate(11, delay = $$new_props.delay);
    if ("duration" in $$new_props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("fade" in $$new_props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$new_props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$new_props)
      $$invalidate(5, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    fadeTrans: fade,
    ToastBody: ToastBody_default,
    ToastHeader: ToastHeader_default,
    classnames,
    dispatch,
    className,
    autohide,
    body,
    delay,
    duration,
    fade: fade2,
    header,
    isOpen,
    toggle,
    timeout,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("autohide" in $$props)
      $$invalidate(10, autohide = $$new_props.autohide);
    if ("body" in $$props)
      $$invalidate(1, body = $$new_props.body);
    if ("delay" in $$props)
      $$invalidate(11, delay = $$new_props.delay);
    if ("duration" in $$props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("fade" in $$props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$props)
      $$invalidate(5, toggle = $$new_props.toggle);
    if ("timeout" in $$props)
      timeout = $$new_props.timeout;
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isOpen, autohide, delay*/
    3073) {
      $:
        if (isOpen && autohide) {
          timeout = setTimeout(() => $$invalidate(0, isOpen = false), delay);
        }
    }
    if ($$self.$$.dirty & /*className, isOpen*/
    513) {
      $:
        $$invalidate(6, classes = classnames(className, "toast", { show: isOpen }));
    }
  };
  return [
    isOpen,
    body,
    duration,
    fade2,
    header,
    toggle,
    classes,
    dispatch,
    $$restProps,
    className,
    autohide,
    delay,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    $$scope
  ];
}
var Toast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, {
      class: 9,
      autohide: 10,
      body: 1,
      delay: 11,
      duration: 2,
      fade: 3,
      header: 4,
      isOpen: 0,
      toggle: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toast",
      options,
      id: create_fragment89.name
    });
  }
  get class() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autohide() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autohide(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delay() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delay(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toast_default = Toast;

// node_modules/sveltestrap/src/Tooltip.svelte
var file88 = "node_modules/sveltestrap/src/Tooltip.svelte";
function create_if_block36(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*outer*/
    ctx[5]
  );
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot13] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*$$scope, $$restProps, classes, id, popperPlacement, tooltipEl, children*/
      262366) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & /*outer*/
      32 && switch_value !== (switch_value = /*outer*/
      ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block36.name,
    type: "if",
    source: "(121:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_else_block29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block29.name,
    type: "else",
    source: "(135:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_121(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_121.name,
    type: "if",
    source: "(133:8) {#if children}",
    ctx
  });
  return block;
}
function create_default_slot13(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_121, create_else_block29];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div2_levels = [
    /*$$restProps*/
    ctx[7],
    { class: (
      /*classes*/
      ctx[6]
    ) },
    { id: (
      /*id*/
      ctx[2]
    ) },
    { role: "tooltip" },
    {
      "x-placement": (
        /*popperPlacement*/
        ctx[3]
      )
    }
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        class: true,
        id: true,
        role: true,
        "x-placement": true
      });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true, "data-popper-arrow": true });
      children(div0).forEach(detach_dev);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "tooltip-arrow");
      attr_dev(div0, "data-popper-arrow", "");
      add_location(div0, file88, 130, 6, 3255);
      attr_dev(div1, "class", "tooltip-inner");
      add_location(div1, file88, 131, 6, 3309);
      set_attributes(div2, div_data_2);
      add_location(div2, file88, 122, 4, 3097);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t);
      append_hydration_dev(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      ctx[17](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        (!current || dirty & /*id*/
        4) && { id: (
          /*id*/
          ctx2[2]
        ) },
        { role: "tooltip" },
        (!current || dirty & /*popperPlacement*/
        8) && {
          "x-placement": (
            /*popperPlacement*/
            ctx2[3]
          )
        }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if_blocks[current_block_type_index].d();
      ctx[17](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(122:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment90(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block36(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block36(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance90($$self, $$props, $$invalidate) {
  let classes;
  let outer;
  const omit_props_names = ["class", "animation", "children", "container", "id", "isOpen", "placement", "target"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { animation = true } = $$props;
  let { children: children2 = void 0 } = $$props;
  let { container = void 0 } = $$props;
  let { id = `tooltip_${uuid()}` } = $$props;
  let { isOpen = false } = $$props;
  let { placement = "top" } = $$props;
  let { target = "" } = $$props;
  let bsPlacement;
  let popperInstance;
  let popperPlacement = placement;
  let targetEl;
  let tooltipEl;
  const checkPopperPlacement = {
    name: "checkPopperPlacement",
    enabled: true,
    phase: "main",
    fn({ state }) {
      $$invalidate(3, popperPlacement = state.placement);
    }
  };
  const open = () => $$invalidate(0, isOpen = true);
  const close = () => $$invalidate(0, isOpen = false);
  onMount(registerEventListeners);
  onDestroy(unregisterEventListeners);
  function registerEventListeners() {
    if (target == null || target.length == 0) {
      $$invalidate(15, targetEl = null);
      return;
    }
    try {
      if (target instanceof HTMLElement) {
        $$invalidate(15, targetEl = target);
      }
    } catch (e) {
    }
    if (targetEl == null) {
      try {
        $$invalidate(15, targetEl = document.querySelector(`#${target}`));
      } catch (e) {
      }
    }
    if (targetEl) {
      targetEl.addEventListener("mouseover", open);
      targetEl.addEventListener("mouseleave", close);
      targetEl.addEventListener("focus", open);
      targetEl.addEventListener("blur", close);
    }
  }
  function unregisterEventListeners() {
    if (targetEl) {
      targetEl.removeEventListener("mouseover", open);
      targetEl.removeEventListener("mouseleave", close);
      targetEl.removeEventListener("focus", open);
      targetEl.removeEventListener("blur", close);
      targetEl.removeAttribute("aria-describedby");
    }
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tooltipEl = $$value;
      $$invalidate(4, tooltipEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("animation" in $$new_props)
      $$invalidate(9, animation = $$new_props.animation);
    if ("children" in $$new_props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("container" in $$new_props)
      $$invalidate(10, container = $$new_props.container);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$new_props)
      $$invalidate(11, placement = $$new_props.placement);
    if ("target" in $$new_props)
      $$invalidate(12, target = $$new_props.target);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    createPopper,
    classnames,
    uuid,
    InlineContainer: InlineContainer_default,
    Portal: Portal_default,
    className,
    animation,
    children: children2,
    container,
    id,
    isOpen,
    placement,
    target,
    bsPlacement,
    popperInstance,
    popperPlacement,
    targetEl,
    tooltipEl,
    checkPopperPlacement,
    open,
    close,
    registerEventListeners,
    unregisterEventListeners,
    outer,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("animation" in $$props)
      $$invalidate(9, animation = $$new_props.animation);
    if ("children" in $$props)
      $$invalidate(1, children2 = $$new_props.children);
    if ("container" in $$props)
      $$invalidate(10, container = $$new_props.container);
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$props)
      $$invalidate(11, placement = $$new_props.placement);
    if ("target" in $$props)
      $$invalidate(12, target = $$new_props.target);
    if ("bsPlacement" in $$props)
      $$invalidate(13, bsPlacement = $$new_props.bsPlacement);
    if ("popperInstance" in $$props)
      $$invalidate(14, popperInstance = $$new_props.popperInstance);
    if ("popperPlacement" in $$props)
      $$invalidate(3, popperPlacement = $$new_props.popperPlacement);
    if ("targetEl" in $$props)
      $$invalidate(15, targetEl = $$new_props.targetEl);
    if ("tooltipEl" in $$props)
      $$invalidate(4, tooltipEl = $$new_props.tooltipEl);
    if ("outer" in $$props)
      $$invalidate(5, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isOpen, tooltipEl, targetEl, placement, popperInstance*/
    51217) {
      $: {
        if (isOpen && tooltipEl) {
          $$invalidate(14, popperInstance = createPopper(targetEl, tooltipEl, {
            placement,
            modifiers: [checkPopperPlacement]
          }));
        } else if (popperInstance) {
          popperInstance.destroy();
          $$invalidate(14, popperInstance = void 0);
        }
      }
    }
    if ($$self.$$.dirty & /*target*/
    4096) {
      $:
        if (target) {
          unregisterEventListeners();
          registerEventListeners();
        }
    }
    if ($$self.$$.dirty & /*targetEl, isOpen, id*/
    32773) {
      $:
        if (targetEl) {
          if (isOpen)
            targetEl.setAttribute("aria-describedby", id);
          else
            targetEl.removeAttribute("aria-describedby");
        }
    }
    if ($$self.$$.dirty & /*popperPlacement*/
    8) {
      $: {
        if (popperPlacement === "left")
          $$invalidate(13, bsPlacement = "start");
        else if (popperPlacement === "right")
          $$invalidate(13, bsPlacement = "end");
        else
          $$invalidate(13, bsPlacement = popperPlacement);
      }
    }
    if ($$self.$$.dirty & /*className, animation, bsPlacement, isOpen*/
    8961) {
      $:
        $$invalidate(6, classes = classnames(className, "tooltip", animation ? "fade" : false, `bs-tooltip-${bsPlacement}`, isOpen ? "show" : false));
    }
    if ($$self.$$.dirty & /*container*/
    1024) {
      $:
        $$invalidate(5, outer = container === "inline" ? InlineContainer_default : Portal_default);
    }
  };
  return [
    isOpen,
    children2,
    id,
    popperPlacement,
    tooltipEl,
    outer,
    classes,
    $$restProps,
    className,
    animation,
    container,
    placement,
    target,
    bsPlacement,
    popperInstance,
    targetEl,
    slots,
    div2_binding,
    $$scope
  ];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, {
      class: 8,
      animation: 9,
      children: 1,
      container: 10,
      id: 2,
      isOpen: 0,
      placement: 11,
      target: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment90.name
    });
  }
  get class() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animation() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animation(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;
export {
  Accordion_default as Accordion,
  AccordionHeader_default as AccordionHeader,
  AccordionItem_default as AccordionItem,
  Alert_default as Alert,
  Badge_default as Badge,
  Breadcrumb_default as Breadcrumb,
  BreadcrumbItem_default as BreadcrumbItem,
  Button_default as Button,
  ButtonDropdown_default as ButtonDropdown,
  ButtonGroup_default as ButtonGroup,
  ButtonToolbar_default as ButtonToolbar,
  Card_default as Card,
  CardBody_default as CardBody,
  CardColumns_default as CardColumns,
  CardDeck_default as CardDeck,
  CardFooter_default as CardFooter,
  CardGroup_default as CardGroup,
  CardHeader_default as CardHeader,
  CardImg_default as CardImg,
  CardImgOverlay_default as CardImgOverlay,
  CardLink_default as CardLink,
  CardSubtitle_default as CardSubtitle,
  CardText_default as CardText,
  CardTitle_default as CardTitle,
  Carousel_default as Carousel,
  CarouselCaption_default as CarouselCaption,
  CarouselControl_default as CarouselControl,
  CarouselIndicators_default as CarouselIndicators,
  CarouselItem_default as CarouselItem,
  Col_default as Col,
  Collapse_default as Collapse,
  Column_default as Column,
  Container_default as Container,
  Dropdown_default as Dropdown,
  DropdownItem_default as DropdownItem,
  DropdownMenu_default as DropdownMenu,
  DropdownToggle_default as DropdownToggle,
  Fade_default as Fade,
  Figure_default as Figure,
  Form_default as Form,
  FormCheck_default as FormCheck,
  FormFeedback_default as FormFeedback,
  FormGroup_default as FormGroup,
  FormText_default as FormText,
  Icon_default as Icon,
  Image_default as Image,
  InlineContainer_default as InlineContainer,
  Input_default as Input,
  InputGroup_default as InputGroup,
  InputGroupText_default as InputGroupText,
  Jumbotron_default as Jumbotron,
  Label_default as Label,
  ListGroup_default as ListGroup,
  ListGroupItem_default as ListGroupItem,
  Modal_default as Modal,
  ModalBackdrop_default as ModalBackdrop,
  ModalBody_default as ModalBody,
  ModalFooter_default as ModalFooter,
  ModalHeader_default as ModalHeader,
  Nav_default as Nav,
  NavItem_default as NavItem,
  NavLink_default as NavLink,
  Navbar_default as Navbar,
  NavbarBrand_default as NavbarBrand,
  NavbarToggler_default as NavbarToggler,
  Offcanvas_default as Offcanvas,
  OffcanvasBackdrop_default as OffcanvasBackdrop,
  OffcanvasBody_default as OffcanvasBody,
  OffcanvasHeader_default as OffcanvasHeader,
  Pagination_default as Pagination,
  PaginationItem_default as PaginationItem,
  PaginationLink_default as PaginationLink,
  Popover_default as Popover,
  Portal_default as Portal,
  Progress_default as Progress,
  Row_default as Row,
  Spinner_default as Spinner,
  Styles_default as Styles,
  TabContent_default as TabContent,
  TabPane_default as TabPane,
  Table_default as Table,
  Toast_default as Toast,
  ToastBody_default as ToastBody,
  ToastHeader_default as ToastHeader,
  Tooltip_default as Tooltip
};
//# sourceMappingURL=sveltestrap.js.map
