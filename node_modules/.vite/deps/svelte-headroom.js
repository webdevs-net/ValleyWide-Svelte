import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  add_render_callback,
  append_styles,
  attr_dev,
  children,
  claim_element,
  createEventDispatcher,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  insert_hydration_dev,
  listen_dev,
  null_to_empty,
  run_all,
  safe_not_equal,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-RVLVW3YK.js";
import "./chunk-76J2PTFD.js";

// node_modules/svelte-headroom/src/validation.js
var warn = (msg, val) => console.warn(`[svelte-headroom]:`, msg, val);
function validate({ duration, offset, tolerance }) {
  if (typeof offset !== "number")
    warn("The `offset` prop is not a number: ", offset);
  if (typeof tolerance !== "number")
    warn("The `tolerance` prop is not a number: ", tolerance);
  if (typeof duration !== "string")
    warn("The `duration` prop is not a string such as '200ms': ", duration);
}

// node_modules/svelte-headroom/src/index.svelte
var file = "node_modules/svelte-headroom/src/index.svelte";
function add_css(target) {
  append_styles(target, "svelte-1ql6gaa", "div.svelte-1ql6gaa{position:fixed;width:100%;top:0;transition:transform 300ms linear;transform:translateY(0%)}.svelte-headroom--unpin.svelte-1ql6gaa{transform:translateY(-100%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguc3ZlbHRlIiwibWFwcGluZ3MiOiJBQThDRSxrQkFBSSxDQUNGLFFBQVEsQ0FBRSxLQUFLLENBQ2YsS0FBSyxDQUFFLElBQUksQ0FDWCxHQUFHLENBQUUsQ0FBQyxDQUNOLFVBQVUsQ0FBRSxTQUFTLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FDbEMsU0FBUyxDQUFFLFdBQVcsRUFBRSxDQUMxQixDQUVBLHNDQUF3QixDQUN0QixTQUFTLENBQUUsV0FBVyxLQUFLLENBQzdCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbImluZGV4LnN2ZWx0ZSJdfQ== */");
}
function create_fragment(ctx) {
  let scrolling = false;
  let clear_scrolling = () => {
    scrolling = false;
  };
  let scrolling_timeout;
  let div;
  let div_class_value;
  let action_action;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowscroll*/
    ctx[9]
  );
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(
        /*headerClass*/
        ctx[0]
      ) + " svelte-1ql6gaa");
      add_location(div, file, 60, 0, 1314);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "scroll", () => {
            scrolling = true;
            clearTimeout(scrolling_timeout);
            scrolling_timeout = setTimeout(clear_scrolling, 100);
            ctx[9]();
          }),
          action_destroyer(action_action = /*action*/
          ctx[2].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*y*/
      2 && !scrolling) {
        scrolling = true;
        clearTimeout(scrolling_timeout);
        scrollTo(
          window.pageXOffset,
          /*y*/
          ctx2[1]
        );
        scrolling_timeout = setTimeout(clear_scrolling, 100);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*headerClass*/
      1 && div_class_value !== (div_class_value = null_to_empty(
        /*headerClass*/
        ctx2[0]
      ) + " svelte-1ql6gaa")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Src", slots, ["default"]);
  let { duration = "300ms" } = $$props;
  let { offset = 0 } = $$props;
  let { tolerance = 0 } = $$props;
  let headerClass = "";
  let lastHeaderClass = "";
  let y = 0;
  let lastY = 0;
  let prefix = "svelte-headroom--";
  const dispatch = createEventDispatcher();
  function deriveClass(y2 = 0, scrolled = 0) {
    if (y2 < offset)
      return "";
    if (Math.abs(scrolled) < tolerance)
      return headerClass;
    if (scrolled > 0)
      return "";
    if (scrolled < 0)
      return `${prefix}unpin`;
    return headerClass;
  }
  function updateClass(y2 = 0) {
    const scrolledPxs = lastY - y2;
    const result = deriveClass(y2, scrolledPxs);
    lastY = y2;
    return result;
  }
  function action(node) {
    node.style.transitionDuration = duration;
  }
  const writable_props = ["duration", "offset", "tolerance"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Src> was created with unknown prop '${key}'`);
  });
  function onwindowscroll() {
    $$invalidate(1, y = window.pageYOffset);
  }
  $$self.$$set = ($$props2) => {
    if ("duration" in $$props2)
      $$invalidate(3, duration = $$props2.duration);
    if ("offset" in $$props2)
      $$invalidate(4, offset = $$props2.offset);
    if ("tolerance" in $$props2)
      $$invalidate(5, tolerance = $$props2.tolerance);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    validate,
    duration,
    offset,
    tolerance,
    headerClass,
    lastHeaderClass,
    y,
    lastY,
    prefix,
    dispatch,
    deriveClass,
    updateClass,
    action
  });
  $$self.$inject_state = ($$props2) => {
    if ("duration" in $$props2)
      $$invalidate(3, duration = $$props2.duration);
    if ("offset" in $$props2)
      $$invalidate(4, offset = $$props2.offset);
    if ("tolerance" in $$props2)
      $$invalidate(5, tolerance = $$props2.tolerance);
    if ("headerClass" in $$props2)
      $$invalidate(0, headerClass = $$props2.headerClass);
    if ("lastHeaderClass" in $$props2)
      $$invalidate(6, lastHeaderClass = $$props2.lastHeaderClass);
    if ("y" in $$props2)
      $$invalidate(1, y = $$props2.y);
    if ("lastY" in $$props2)
      lastY = $$props2.lastY;
    if ("prefix" in $$props2)
      prefix = $$props2.prefix;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*duration, offset, tolerance, y, headerClass, lastHeaderClass*/
    123) {
      $: {
        validate({ duration, offset, tolerance });
        $$invalidate(0, headerClass = updateClass(y));
        if (headerClass !== lastHeaderClass) {
          dispatch(headerClass ? "unpin" : "pin");
        }
        $$invalidate(6, lastHeaderClass = headerClass);
      }
    }
  };
  return [
    headerClass,
    y,
    action,
    duration,
    offset,
    tolerance,
    lastHeaderClass,
    $$scope,
    slots,
    onwindowscroll
  ];
}
var Src = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { duration: 3, offset: 4, tolerance: 5 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Src",
      options,
      id: create_fragment.name
    });
  }
  get duration() {
    throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tolerance() {
    throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tolerance(value) {
    throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var src_default = Src;
export {
  src_default as default
};
//# sourceMappingURL=svelte-headroom.js.map
