import { SymbolType } from './types';
export function generateNavigationOptions({ totalItems, pageSize, currentPage, limit, showStepOptions = false }) {
    const totalPages = Math.ceil(totalItems / pageSize);
    const limited = limit && totalPages > getLimitThreshold(limit);
    const options = limited
        ? generateLimitedOptions({ totalPages, limit, currentPage })
        : generateUnlimitedOptions({ totalPages });
    return showStepOptions ? addStepOptions({ options, currentPage, totalPages }) : options;
}
function generateUnlimitedOptions({ totalPages }) {
    return new Array(totalPages).fill(null).map((_, index) => ({
        type: 'number',
        value: index + 1
    }));
}
function generateLimitedOptions({ totalPages, limit, currentPage }) {
    const boundarySize = limit * 2 + 2;
    const firstBoundary = 1 + boundarySize;
    const lastBoundary = totalPages - boundarySize;
    const totalShownPages = firstBoundary + 2;
    if (currentPage <= firstBoundary - limit) {
        return Array(totalShownPages)
            .fill(null)
            .map((_, index) => {
            if (index === totalShownPages - 1) {
                return {
                    type: 'number',
                    value: totalPages
                };
            }
            else if (index === totalShownPages - 2) {
                return {
                    type: 'symbol',
                    symbol: SymbolType.ELLIPSIS,
                    value: firstBoundary + 1
                };
            }
            return {
                type: 'number',
                value: index + 1
            };
        });
    }
    else if (currentPage >= lastBoundary + limit) {
        return Array(totalShownPages)
            .fill(null)
            .map((_, index) => {
            if (index === 0) {
                return {
                    type: 'number',
                    value: 1
                };
            }
            else if (index === 1) {
                return {
                    type: 'symbol',
                    symbol: SymbolType.ELLIPSIS,
                    value: lastBoundary - 1
                };
            }
            return {
                type: 'number',
                value: lastBoundary + index - 2
            };
        });
    }
    else if (currentPage >= firstBoundary - limit && currentPage <= lastBoundary + limit) {
        return Array(totalShownPages)
            .fill(null)
            .map((_, index) => {
            if (index === 0) {
                return {
                    type: 'number',
                    value: 1
                };
            }
            else if (index === 1) {
                return {
                    type: 'symbol',
                    symbol: SymbolType.ELLIPSIS,
                    value: currentPage - limit + (index - 2)
                };
            }
            else if (index === totalShownPages - 1) {
                return {
                    type: 'number',
                    value: totalPages
                };
            }
            else if (index === totalShownPages - 2) {
                return {
                    type: 'symbol',
                    symbol: SymbolType.ELLIPSIS,
                    value: currentPage + limit + 1
                };
            }
            return {
                type: 'number',
                value: currentPage - limit + (index - 2)
            };
        });
    }
    return [];
}
function addStepOptions({ options, currentPage, totalPages }) {
    return [
        {
            type: 'symbol',
            symbol: SymbolType.PREVIOUS_PAGE,
            value: currentPage <= 1 ? 1 : currentPage - 1
        },
        ...(options || []),
        {
            type: 'symbol',
            symbol: SymbolType.NEXT_PAGE,
            value: currentPage >= totalPages ? totalPages : currentPage + 1
        }
    ];
}
function getLimitThreshold(limit) {
    const maximumUnlimitedPages = 3; // This means we cannot limit 3 pages or less
    const numberOfBoundaryPages = 2; // The first and last pages are always shown
    return limit * 2 + maximumUnlimitedPages + numberOfBoundaryPages;
}
