/*
Copyright (c) NAVER Corp.
name: @egjs/svelte-grid
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-grid
version: 1.14.2
*/
import { SvelteComponent, init, safe_not_equal, create_slot, assign, element, set_attributes, insert, update_slot, get_spread_update, transition_in, transition_out, detach, exclude_internal_props, binding_callbacks } from 'svelte/internal';
import { createEventDispatcher, beforeUpdate, onMount, afterUpdate, onDestroy } from 'svelte';
import { GRID_EVENTS, GRID_METHODS, MasonryGrid, JustifiedGrid, FrameGrid, PackingGrid } from '@egjs/grid';

/* src/Grid.svelte generated by Svelte v3.35.0 */

function create_fragment(ctx) {
  let div;
  let current;
  const default_slot_template =
  /*#slots*/
  ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx,
  /*$$scope*/
  ctx[4], null);
  let div_levels = [
  /*attributes*/
  ctx[1]];
  let div_data = {};

  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }

  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
    },

    m(target, anchor) {
      insert(target, div, anchor);

      if (default_slot) {
        default_slot.m(div, null);
      }
      /*div_binding*/


      ctx[6](div);
      current = true;
    },

    p(ctx, [dirty]) {
      if (default_slot) {
        if (default_slot.p && dirty &
        /*$$scope*/
        16) {
          update_slot(default_slot, default_slot_template, ctx,
          /*$$scope*/
          ctx[4], dirty, null, null);
        }
      }

      set_attributes(div, div_data = get_spread_update(div_levels, [dirty &
      /*attributes*/
      2 &&
      /*attributes*/
      ctx[1]]));
    },

    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },

    o(local) {
      transition_out(default_slot, local);
      current = false;
    },

    d(detaching) {
      if (detaching) detach(div);
      if (default_slot) default_slot.d(detaching);
      /*div_binding*/

      ctx[6](null);
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  let {
    GridClass
  } = $$props;
  const dispatch = createEventDispatcher();
  let container;
  let grid;
  let attributes = {};

  function updateAttributes() {
    $$invalidate(1, attributes = { ...$$props
    });
    const defaultOptions = GridClass.defaultOptions;
    delete attributes["GridClass"];

    for (const name in defaultOptions) {
      delete attributes[name];
    }
  }

  beforeUpdate(() => {
    updateAttributes();

    if (!grid) {
      return;
    }

    const propertyTypes = GridClass.propertyTypes;

    for (const name in propertyTypes) {
      if (name in $$props) {
        grid[name] = $$props[name];
      }
    }
  });
  onMount(() => {
    const defaultOptions = GridClass.defaultOptions;
    const options = {};

    for (const name in defaultOptions) {
      if (name in $$props) {
        options[name] = $$props[name];
      }
    }

    grid = new GridClass(container, options);
    GRID_EVENTS.forEach(name => {
      grid.on(name, e => {
        dispatch(name, e);
      });
    });
    grid.renderItems();
  });
  afterUpdate(() => {

    const propertyTypes = GridClass.propertyTypes;

    for (const name in propertyTypes) {
      if (name in $$props) {
        grid[name] = $$props[name];
      }
    }

    grid.syncElements();
  });
  onDestroy(() => {
    grid && grid.destroy();
  });

  function getInstance() {
    return grid;
  }

  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }

  $$self.$$set = $$new_props => {
    $$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("GridClass" in $$new_props) $$invalidate(2, GridClass = $$new_props.GridClass);
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };

  $$props = exclude_internal_props($$props);
  return [container, attributes, GridClass, getInstance, $$scope, slots, div_binding];
}

class Grid$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      GridClass: 2,
      getInstance: 3
    });
  }

  get getInstance() {
    return this.$$.ctx[3];
  }

}

/**
 * egjs-grid
 * Copyright (c) 2021-present NAVER Corp.
 * MIT license
 */
var Grid = /*#__PURE__*/(() => {
  const prototype = Grid$1.prototype;

  if (prototype) {
    GRID_METHODS.forEach(name => {
      if (name in prototype) {
        return;
      }

      prototype[name] = function (...args) {
        const self = this.getInstance();
        const result = self[name](...args);

        if (result === self) {
          return this;
        } else {
          return result;
        }
      };
    });
  }

  return Grid$1;
})();

let SvelteMasonryGrid;

if (typeof Grid$1 === "object") {
  SvelteMasonryGrid = Grid$1;
} else {
  SvelteMasonryGrid = class SvelteMasonryGrid extends Grid$1 {
    constructor(options) {
      options.props.GridClass = MasonryGrid;
      super(options);
    }

  };
}

let SvelteJustifiedGrid;

if (typeof Grid$1 === "object") {
  SvelteJustifiedGrid = Grid$1;
} else {
  SvelteJustifiedGrid = class SvelteJustifiedGrid extends Grid$1 {
    constructor(options) {
      options.props.GridClass = JustifiedGrid;
      super(options);
    }

  };
}

let SvelteFrameGrid;

if (typeof Grid$1 === "object") {
  SvelteFrameGrid = Grid$1;
} else {
  SvelteFrameGrid = class SvelteFrameGrid extends Grid$1 {
    constructor(options) {
      options.props.GridClass = FrameGrid;
      super(options);
    }

  };
}

let SveltePackingGrid;

if (typeof Grid$1 === "object") {
  SveltePackingGrid = Grid$1;
} else {
  SveltePackingGrid = class SveltePackingGrid extends Grid$1 {
    constructor(options) {
      options.props.GridClass = PackingGrid;
      super(options);
    }

  };
}

export { SvelteFrameGrid as FrameGrid, Grid, SvelteJustifiedGrid as JustifiedGrid, SvelteMasonryGrid as MasonryGrid, SveltePackingGrid as PackingGrid };
//# sourceMappingURL=grid.esm.js.map
